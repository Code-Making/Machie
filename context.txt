/data/data/com.termux/files/home/machine
├── README.md
├── analysis_options.yaml
├── analyze.sh
├── android
│   ├── app
│   │   ├── build.gradle.kts
│   │   └── src
│   │       ├── debug
│   │       │   └── AndroidManifest.xml
│   │       ├── main
│   │       │   ├── AndroidManifest.xml
│   │       │   ├── kotlin
│   │       │   │   └── com
│   │       │   │       └── thomasdumonet
│   │       │   │           └── machine
│   │       │   │               └── MainActivity.kt
│   │       │   └── res
│   │       │       ├── drawable
│   │       │       │   ├── background.png
│   │       │       │   ├── launch_background.xml
│   │       │       │   └── not_icon.png
│   │       │       ├── drawable-hdpi
│   │       │       │   ├── android12splash.png
│   │       │       │   ├── ic_launcher_background.png
│   │       │       │   ├── ic_launcher_foreground.png
│   │       │       │   ├── ic_launcher_monochrome.png
│   │       │       │   ├── ic_stat___.png
│   │       │       │   └── splash.png
│   │       │       ├── drawable-mdpi
│   │       │       │   ├── android12splash.png
│   │       │       │   ├── ic_launcher_background.png
│   │       │       │   ├── ic_launcher_foreground.png
│   │       │       │   ├── ic_launcher_monochrome.png
│   │       │       │   ├── ic_stat___.png
│   │       │       │   └── splash.png
│   │       │       ├── drawable-night-hdpi
│   │       │       │   └── android12splash.png
│   │       │       ├── drawable-night-mdpi
│   │       │       │   └── android12splash.png
│   │       │       ├── drawable-night-xhdpi
│   │       │       │   └── android12splash.png
│   │       │       ├── drawable-night-xxhdpi
│   │       │       │   └── android12splash.png
│   │       │       ├── drawable-night-xxxhdpi
│   │       │       │   └── android12splash.png
│   │       │       ├── drawable-v21
│   │       │       │   ├── background.png
│   │       │       │   └── launch_background.xml
│   │       │       ├── drawable-xhdpi
│   │       │       │   ├── android12splash.png
│   │       │       │   ├── ic_launcher_background.png
│   │       │       │   ├── ic_launcher_foreground.png
│   │       │       │   ├── ic_launcher_monochrome.png
│   │       │       │   ├── ic_stat___.png
│   │       │       │   └── splash.png
│   │       │       ├── drawable-xxhdpi
│   │       │       │   ├── android12splash.png
│   │       │       │   ├── ic_launcher_background.png
│   │       │       │   ├── ic_launcher_foreground.png
│   │       │       │   ├── ic_launcher_monochrome.png
│   │       │       │   ├── ic_stat___.png
│   │       │       │   └── splash.png
│   │       │       ├── drawable-xxxhdpi
│   │       │       │   ├── android12splash.png
│   │       │       │   ├── ic_launcher_background.png
│   │       │       │   ├── ic_launcher_foreground.png
│   │       │       │   ├── ic_launcher_monochrome.png
│   │       │       │   ├── ic_stat___.png
│   │       │       │   └── splash.png
│   │       │       ├── mipmap-anydpi-v26
│   │       │       │   └── ic_launcher.xml
│   │       │       ├── mipmap-hdpi
│   │       │       │   └── ic_launcher.png
│   │       │       ├── mipmap-mdpi
│   │       │       │   └── ic_launcher.png
│   │       │       ├── mipmap-xhdpi
│   │       │       │   └── ic_launcher.png
│   │       │       ├── mipmap-xxhdpi
│   │       │       │   └── ic_launcher.png
│   │       │       ├── mipmap-xxxhdpi
│   │       │       │   └── ic_launcher.png
│   │       │       ├── values
│   │       │       │   └── styles.xml
│   │       │       ├── values-night
│   │       │       │   └── styles.xml
│   │       │       ├── values-night-v31
│   │       │       │   └── styles.xml
│   │       │       ├── values-v31
│   │       │       │   └── styles.xml
│   │       │       └── xml
│   │       │           └── file_paths.xml
│   │       └── profile
│   │           └── AndroidManifest.xml
│   ├── build.gradle.kts
│   ├── gradle
│   │   └── wrapper
│   │       └── gradle-wrapper.properties
│   ├── gradle.properties
│   └── settings.gradle.kts
├── assets
│   ├── fonts
│   │   ├── FiraCode
│   │   │   ├── FiraCode-Bold.ttf
│   │   │   ├── FiraCode-Light.ttf
│   │   │   ├── FiraCode-Medium.ttf
│   │   │   ├── FiraCode-Regular.ttf
│   │   │   └── FiraCode-SemiBold.ttf
│   │   ├── JetBrainsMono-Bold.ttf
│   │   ├── JetBrainsMono-BoldItalic.ttf
│   │   ├── JetBrainsMono-ExtraBold.ttf
│   │   ├── JetBrainsMono-ExtraBoldItalic.ttf
│   │   ├── JetBrainsMono-ExtraLight.ttf
│   │   ├── JetBrainsMono-ExtraLightItalic.ttf
│   │   ├── JetBrainsMono-Italic.ttf
│   │   ├── JetBrainsMono-Light.ttf
│   │   ├── JetBrainsMono-LightItalic.ttf
│   │   ├── JetBrainsMono-Medium.ttf
│   │   ├── JetBrainsMono-MediumItalic.ttf
│   │   ├── JetBrainsMono-Regular.ttf
│   │   ├── JetBrainsMono-SemiBold.ttf
│   │   ├── JetBrainsMono-SemiBoldItalic.ttf
│   │   ├── JetBrainsMono-Thin.ttf
│   │   ├── JetBrainsMono-ThinItalic.ttf
│   │   ├── RobotoMono
│   │   │   ├── RobotoMono-Bold.ttf
│   │   │   ├── RobotoMono-BoldItalic.ttf
│   │   │   ├── RobotoMono-ExtraLight.ttf
│   │   │   ├── RobotoMono-ExtraLightItalic.ttf
│   │   │   ├── RobotoMono-Italic.ttf
│   │   │   ├── RobotoMono-Light.ttf
│   │   │   ├── RobotoMono-LightItalic.ttf
│   │   │   ├── RobotoMono-Medium.ttf
│   │   │   ├── RobotoMono-MediumItalic.ttf
│   │   │   ├── RobotoMono-Regular.ttf
│   │   │   ├── RobotoMono-SemiBold.ttf
│   │   │   ├── RobotoMono-SemiBoldItalic.ttf
│   │   │   ├── RobotoMono-Thin.ttf
│   │   │   └── RobotoMono-ThinItalic.ttf
│   │   └── SourceSans3
│   │       ├── SourceSans3-Black.ttf
│   │       ├── SourceSans3-BlackItalic.ttf
│   │       ├── SourceSans3-Bold.ttf
│   │       ├── SourceSans3-BoldItalic.ttf
│   │       ├── SourceSans3-ExtraBold.ttf
│   │       ├── SourceSans3-ExtraBoldItalic.ttf
│   │       ├── SourceSans3-ExtraLight.ttf
│   │       ├── SourceSans3-ExtraLightItalic.ttf
│   │       ├── SourceSans3-Italic.ttf
│   │       ├── SourceSans3-Light.ttf
│   │       ├── SourceSans3-LightItalic.ttf
│   │       ├── SourceSans3-Medium.ttf
│   │       ├── SourceSans3-MediumItalic.ttf
│   │       ├── SourceSans3-Regular.ttf
│   │       ├── SourceSans3-SemiBold.ttf
│   │       └── SourceSans3-SemiBoldItalic.ttf
│   └── icons
│       └── android
│           ├── play_store_512.png
│           └── res
│               ├── mipmap-anydpi-v26
│               │   └── ic_launcher.xml
│               ├── mipmap-hdpi
│               │   ├── ic_launcher.png
│               │   ├── ic_launcher_background.png
│               │   ├── ic_launcher_foreground.png
│               │   └── ic_launcher_monochrome.png
│               ├── mipmap-mdpi
│               │   ├── ic_launcher.png
│               │   ├── ic_launcher_background.png
│               │   ├── ic_launcher_foreground.png
│               │   └── ic_launcher_monochrome.png
│               ├── mipmap-xhdpi
│               │   ├── ic_launcher.png
│               │   ├── ic_launcher_background.png
│               │   ├── ic_launcher_foreground.png
│               │   └── ic_launcher_monochrome.png
│               ├── mipmap-xxhdpi
│               │   ├── ic_launcher.png
│               │   ├── ic_launcher_background.png
│               │   ├── ic_launcher_foreground.png
│               │   └── ic_launcher_monochrome.png
│               └── mipmap-xxxhdpi
│                   ├── ic_launcher.png
│                   ├── ic_launcher_background.png
│                   ├── ic_launcher_foreground.png
│                   └── ic_launcher_monochrome.png
├── build.sh
├── context.txt
├── lib
│   ├── app
│   │   ├── app_commands.dart
│   │   ├── app_notifier.dart
│   │   ├── app_screen.dart
│   │   ├── app_state.dart
│   │   └── lifecycle.dart
│   ├── asset_cache
│   │   ├── asset_loader_registry.dart
│   │   ├── asset_models.dart
│   │   ├── asset_providers.dart
│   │   └── core_asset_loaders.dart
│   ├── command
│   │   ├── command_models.dart
│   │   ├── command_notifier.dart
│   │   └── command_widgets.dart
│   ├── data
│   │   ├── cache
│   │   │   ├── background_task
│   │   │   │   ├── android_foreground_cache_service.dart
│   │   │   │   ├── background_cache_service.dart
│   │   │   │   ├── hot_state_task_handler.dart
│   │   │   │   ├── isolate_cache_service.dart
│   │   │   │   └── web_concurrent_cache_service.dart
│   │   │   ├── hot_state_cache_service.dart
│   │   │   ├── type_adapter_registry.dart
│   │   │   └── type_adapters.dart
│   │   ├── content_provider
│   │   │   ├── file_content_provider.dart
│   │   │   └── internal_file_content_provider.dart
│   │   ├── dto
│   │   │   ├── app_state_dto.dart
│   │   │   ├── project_dto.dart
│   │   │   └── tab_hot_state_dto.dart
│   │   ├── file_handler
│   │   │   ├── file_handler.dart
│   │   │   ├── local_file_handler.dart
│   │   │   └── local_file_handler_saf.dart
│   │   ├── repositories
│   │   │   ├── app_state_repository.dart
│   │   │   ├── cache
│   │   │   │   ├── cache_repository.dart
│   │   │   │   └── hive_cache_repository.dart
│   │   │   └── project
│   │   │       ├── local_folder_persistence_strategy.dart
│   │   │       ├── persistence
│   │   │       │   ├── persistence_strategy_factory.dart
│   │   │       │   └── persistence_strategy_registry.dart
│   │   │       ├── project_repository.dart
│   │   │       ├── project_state_persistence_strategy.dart
│   │   │       └── simple_state_persistence_strategy.dart
│   │   └── shared_preferences.dart
│   ├── editor
│   │   ├── models
│   │   │   ├── editor_command_context.dart
│   │   │   ├── editor_plugin_models.dart
│   │   │   ├── editor_tab_models.dart
│   │   │   └── text_editing_capability.dart
│   │   ├── plugins
│   │   │   ├── code_editor
│   │   │   │   ├── code_editor_hot_state_adapter.dart
│   │   │   │   ├── code_editor_hot_state_dto.dart
│   │   │   │   ├── code_editor_models.dart
│   │   │   │   ├── code_editor_plugin.dart
│   │   │   │   ├── code_editor_settings_widget.dart
│   │   │   │   ├── code_editor_widgets.dart
│   │   │   │   ├── logic
│   │   │   │   │   ├── code_editor_logic.dart
│   │   │   │   │   ├── code_editor_types.dart
│   │   │   │   │   └── code_editor_utils.dart
│   │   │   │   └── widgets
│   │   │   │       ├── code_editor_ui.dart
│   │   │   │       ├── code_find_panel_view.dart
│   │   │   │       ├── custom_code_line_number.dart
│   │   │   │       └── goto_line_dialog.dart
│   │   │   ├── editor_plugin_registry.dart
│   │   │   ├── flow_graph
│   │   │   │   ├── asset
│   │   │   │   │   ├── flow_asset_models.dart
│   │   │   │   │   └── flow_loaders.dart
│   │   │   │   ├── core_nodes.dart
│   │   │   │   ├── flow_graph_asset_resolver.dart
│   │   │   │   ├── flow_graph_command_context.dart
│   │   │   │   ├── flow_graph_editor_plugin.dart
│   │   │   │   ├── flow_graph_editor_tab.dart
│   │   │   │   ├── flow_graph_editor_widget.dart
│   │   │   │   ├── flow_graph_notifier.dart
│   │   │   │   ├── flow_graph_parameter_parser.dart
│   │   │   │   ├── flow_graph_settings_model.dart
│   │   │   │   ├── models
│   │   │   │   │   ├── flow_graph_models.dart
│   │   │   │   │   ├── flow_references.dart
│   │   │   │   │   └── flow_schema_models.dart
│   │   │   │   ├── services
│   │   │   │   │   └── flow_export_service.dart
│   │   │   │   ├── utils
│   │   │   │   │   └── flow_layout_utils.dart
│   │   │   │   └── widgets
│   │   │   │       ├── flow_connection_painter.dart
│   │   │   │       ├── flow_graph_canvas.dart
│   │   │   │       ├── flow_graph_export_dialog.dart
│   │   │   │       ├── flow_graph_settings_widget.dart
│   │   │   │       ├── node_palette.dart
│   │   │   │       ├── property_tiled_object_picker.dart
│   │   │   │       └── schema_node_widget.dart
│   │   │   ├── glitch_editor
│   │   │   │   ├── glitch_editor_hot_state_adapter.dart
│   │   │   │   ├── glitch_editor_hot_state_dto.dart
│   │   │   │   ├── glitch_editor_math.dart
│   │   │   │   ├── glitch_editor_models.dart
│   │   │   │   ├── glitch_editor_plugin.dart
│   │   │   │   ├── glitch_editor_state.dart
│   │   │   │   ├── glitch_editor_widget.dart
│   │   │   │   └── glitch_toolbar.dart
│   │   │   ├── llm_editor
│   │   │   │   ├── llm_editor_controller.dart
│   │   │   │   ├── llm_editor_hot_state.dart
│   │   │   │   ├── llm_editor_models.dart
│   │   │   │   ├── llm_editor_plugin.dart
│   │   │   │   ├── llm_editor_settings_widget.dart
│   │   │   │   ├── llm_editor_types.dart
│   │   │   │   ├── llm_editor_widget.dart
│   │   │   │   ├── providers
│   │   │   │   │   ├── llm_provider.dart
│   │   │   │   │   └── llm_provider_factory.dart
│   │   │   │   └── widgets
│   │   │   │       ├── chat_bubble.dart
│   │   │   │       ├── context_widgets.dart
│   │   │   │       ├── editing_chat_bubble.dart
│   │   │   │       ├── llm_editor_dialogs.dart
│   │   │   │       └── streaming_chat_bubble.dart
│   │   │   ├── recipe_tex
│   │   │   │   ├── recipe_editor_widget.dart
│   │   │   │   ├── recipe_tex_command_context.dart
│   │   │   │   ├── recipe_tex_hot_state.dart
│   │   │   │   ├── recipe_tex_hot_state_adapter.dart
│   │   │   │   ├── recipe_tex_models.dart
│   │   │   │   └── recipe_tex_plugin.dart
│   │   │   ├── refactor_editor
│   │   │   │   ├── occurrence_list_item.dart
│   │   │   │   ├── refactor_editor_controller.dart
│   │   │   │   ├── refactor_editor_hot_state.dart
│   │   │   │   ├── refactor_editor_models.dart
│   │   │   │   ├── refactor_editor_plugin.dart
│   │   │   │   ├── refactor_editor_settings_widget.dart
│   │   │   │   └── refactor_editor_widget.dart
│   │   │   ├── termux_terminal
│   │   │   │   ├── services
│   │   │   │   │   └── termux_bridge_service.dart
│   │   │   │   ├── termux_hot_state.dart
│   │   │   │   ├── termux_hot_state_adapter.dart
│   │   │   │   ├── termux_terminal_models.dart
│   │   │   │   ├── termux_terminal_plugin.dart
│   │   │   │   └── widgets
│   │   │   │       ├── termux_settings_widget.dart
│   │   │   │       ├── termux_terminal_widget.dart
│   │   │   │       └── termux_toolbar.dart
│   │   │   ├── texture_packer
│   │   │   │   ├── services
│   │   │   │   │   └── pixi_export_service.dart
│   │   │   │   ├── texture_packer_asset_resolver.dart
│   │   │   │   ├── texture_packer_command_context.dart
│   │   │   │   ├── texture_packer_editor_models.dart
│   │   │   │   ├── texture_packer_editor_widget.dart
│   │   │   │   ├── texture_packer_loader.dart
│   │   │   │   ├── texture_packer_models.dart
│   │   │   │   ├── texture_packer_notifier.dart
│   │   │   │   ├── texture_packer_plugin.dart
│   │   │   │   ├── texture_packer_preview_state.dart
│   │   │   │   ├── texture_packer_settings.dart
│   │   │   │   └── widgets
│   │   │   │       ├── hierarchy_panel.dart
│   │   │   │       ├── preview_app_bar.dart
│   │   │   │       ├── preview_view.dart
│   │   │   │       ├── slicing_app_bar.dart
│   │   │   │       ├── slicing_properties_dialog.dart
│   │   │   │       ├── slicing_view.dart
│   │   │   │       ├── source_images_panel.dart
│   │   │   │       ├── texture_packer_export_dialog.dart
│   │   │   │       ├── texture_packer_file_dialog.dart
│   │   │   │       └── texture_packer_settings_widget.dart
│   │   │   └── tiled_editor
│   │   │       ├── image_load_result.dart
│   │   │       ├── inspector
│   │   │       │   ├── inspector_dialog.dart
│   │   │       │   ├── property_descriptors.dart
│   │   │       │   ├── property_widgets.dart
│   │   │       │   └── tiled_reflectors.dart
│   │   │       ├── models
│   │   │       │   └── object_class_model.dart
│   │   │       ├── project_tsx_provider.dart
│   │   │       ├── providers
│   │   │       │   └── project_schema_provider.dart
│   │   │       ├── tiled_asset_resolver.dart
│   │   │       ├── tiled_command_context.dart
│   │   │       ├── tiled_editor_models.dart
│   │   │       ├── tiled_editor_plugin.dart
│   │   │       ├── tiled_editor_settings_model.dart
│   │   │       ├── tiled_editor_widget.dart
│   │   │       ├── tiled_export_service.dart
│   │   │       ├── tiled_map_notifier.dart
│   │   │       ├── tiled_map_painter.dart
│   │   │       ├── tiled_paint_tools.dart
│   │   │       ├── tmj_writer.dart
│   │   │       ├── tmx_writer.dart
│   │   │       ├── tmx_writer_extensions.dart
│   │   │       └── widgets
│   │   │           ├── export_dialog.dart
│   │   │           ├── layers_panel.dart
│   │   │           ├── map_properties_dialog.dart
│   │   │           ├── new_layer_dialog.dart
│   │   │           ├── new_tileset_dialog.dart
│   │   │           ├── object_editor_app_bar.dart
│   │   │           ├── paint_editor_app_bar.dart
│   │   │           ├── sprite_picker_dialog.dart
│   │   │           ├── tile_palette.dart
│   │   │           └── tiled_editor_settings_widget.dart
│   │   ├── services
│   │   │   ├── editor_service.dart
│   │   │   └── language
│   │   │       ├── language_models.dart
│   │   │       └── language_registry.dart
│   │   ├── tab_context_commands.dart
│   │   ├── tab_metadata_notifier.dart
│   │   └── widgets
│   │       └── editor_widgets.dart
│   ├── explorer
│   │   ├── common
│   │   │   ├── file_explorer_commands.dart
│   │   │   ├── file_explorer_widgets.dart
│   │   │   └── file_operations_footer.dart
│   │   ├── explorer_plugin_models.dart
│   │   ├── explorer_plugin_registry.dart
│   │   ├── explorer_workspace_state.dart
│   │   ├── plugins
│   │   │   ├── file_explorer
│   │   │   │   ├── file_explorer_plugin.dart
│   │   │   │   ├── file_explorer_state.dart
│   │   │   │   └── file_explorer_view.dart
│   │   │   ├── git_explorer
│   │   │   │   ├── git_explorer_plugin.dart
│   │   │   │   ├── git_explorer_state.dart
│   │   │   │   ├── git_explorer_view.dart
│   │   │   │   ├── git_file_content_provider.dart
│   │   │   │   ├── git_object_file.dart
│   │   │   │   ├── git_provider.dart
│   │   │   │   └── git_storage_provider.dart
│   │   │   └── search_explorer
│   │   │       ├── search_explorer_plugin.dart
│   │   │       ├── search_explorer_settings.dart
│   │   │       ├── search_explorer_settings_widget.dart
│   │   │       ├── search_explorer_state.dart
│   │   │       └── search_explorer_view.dart
│   │   ├── services
│   │   │   └── explorer_service.dart
│   │   └── widgets
│   │       ├── explorer_host_drawer.dart
│   │       ├── new_project_screen.dart
│   │       └── persistence_selection_screen.dart
│   ├── logs
│   │   ├── logs_models.dart
│   │   └── logs_provider.dart
│   ├── main.dart
│   ├── platform
│   │   ├── platform_file_service.dart
│   │   └── saf_platform_file_service.dart
│   ├── project
│   │   ├── handlers
│   │   │   ├── local_project_settings.dart
│   │   │   ├── local_project_settings_ui.dart
│   │   │   └── local_project_type_handler.dart
│   │   ├── project_models.dart
│   │   ├── project_settings_models.dart
│   │   ├── project_settings_notifier.dart
│   │   ├── project_type_handler.dart
│   │   ├── project_type_handler_registry.dart
│   │   └── services
│   │       ├── project_hierarchy_service.dart
│   │       └── project_service.dart
│   ├── settings
│   │   ├── setting_override_widget.dart
│   │   ├── settings_models.dart
│   │   ├── settings_notifier.dart
│   │   └── settings_screen.dart
│   ├── utils
│   │   ├── clipboard.dart
│   │   ├── code_themes.dart
│   │   ├── file_traversal_util.dart
│   │   ├── llm_highlight_util.dart
│   │   ├── texture_packer_algo.dart
│   │   └── toast.dart
│   └── widgets
│       ├── dialogs
│       │   ├── file_explorer_dialogs.dart
│       │   ├── folder_picker_dialog.dart
│       │   └── save_as_dialog.dart
│       ├── file_list_view.dart
│       └── markdown_builders.dart
├── pubspec.yaml
├── sandbox
│   ├── Room_Builder_48x48.png
│   ├── Room_Builder_subfiles_48x48
│   │   ├── Room_Builder_3d_walls_48x48.png
│   │   ├── Room_Builder_Arched_Entryways_48x48.png
│   │   ├── Room_Builder_Floor_Connectors_48x48.png
│   │   ├── Room_Builder_Floor_Paths_48x48.png
│   │   ├── Room_Builder_Floor_Shadows_48x48.png
│   │   ├── Room_Builder_Floors_48x48.png
│   │   ├── Room_Builder_Walls_48x48.png
│   │   ├── Room_Builder_baseboards_48x48.png
│   │   └── Room_Builder_borders_48x48.png
│   ├── Theme_Sorter_48x48
│   │   ├── 10_Birthday_party_48x48.png
│   │   ├── 11_Halloween_48x48.png
│   │   ├── 12_Kitchen_48x48.png
│   │   ├── 13_Conference_Hall_48x48.png
│   │   ├── 14_Basement_48x48.png
│   │   ├── 15_Christmas_48x48.png
│   │   ├── 16_Grocery_store_48x48.png
│   │   ├── 17_Visibile_Upstairs_System_48x48.png
│   │   ├── 18_Jail_48x48.png
│   │   ├── 19_Hospital_48x48.png
│   │   ├── 1_Generic_48x48.png
│   │   ├── 20_Japanese_interiors_48x48.png
│   │   ├── 21_Clothing_Store_48x48.png
│   │   ├── 22_Museum_48x48.png
│   │   ├── 23_Television_and_Film_Studio_48x48.png
│   │   ├── 23_Tevelision_and_Film_Studio_Shadowless_48x48.png
│   │   ├── 24_Ice_Cream_Shop_48x48.png
│   │   ├── 25_Shooting_Range_48x48.png
│   │   ├── 26_Condominium_48x48.png
│   │   ├── 2_LivingRoom_48x48.png
│   │   ├── 3_Bathroom_48x48.png
│   │   ├── 4_Bedroom_48x48.png
│   │   ├── 5_Classroom_and_library_48x48.png
│   │   ├── 6_Music_and_sport_48x48.png
│   │   ├── 7_Art_48x48.png
│   │   ├── 8_Gym_48x48.png
│   │   └── 9_Fishing_48x48.png
│   ├── ecs_schema.json
│   ├── exp
│   │   ├── aaa.json
│   │   ├── context.txt
│   │   ├── export_toast.json
│   │   ├── llll.json
│   │   ├── packed_atlas.png
│   │   └── tast.json
│   ├── exp2
│   │   ├── aaa.tmx
│   │   ├── export_toast.tpacker
│   │   ├── llll.tmx
│   │   ├── packed_atlas.png
│   │   └── tast.fg
│   ├── flowSchena.llm
│   ├── map
│   │   ├── aaa.tmx
│   │   ├── ecs_schema.json
│   │   ├── flow_schema.json
│   │   ├── llll.tmx
│   │   ├── tast.fg
│   │   └── toast.tpacker
│   ├── old
│   │   ├── aaa.tmx
│   │   ├── asset.llm
│   │   ├── asset2.llm
│   │   ├── asset3.llm
│   │   ├── atlass.json
│   │   ├── atlass.png
│   │   ├── export.llm
│   │   ├── flow.llm
│   │   ├── flow2.llm
│   │   ├── packed_atlas.json
│   │   ├── packed_atlas.png
│   │   ├── res.llm
│   │   ├── resolver.llm
│   │   ├── schemaTile.llm
│   │   ├── tast.json
│   │   ├── test.json
│   │   ├── test.png
│   │   ├── test.tmx
│   │   └── tri.llm
│   └── xterm.llm
└── test
    └── widget_test.dart

122 directories, 451 files

// FILE: analysis_options.yaml

# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https:
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https:
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule
    prefer_relative_imports: true
# Additional information about this file can be found at
# https:
analyzer:
  plugins:
    - custom_lint
// FILE: lib/app/app_commands.dart


import 'package:flutter/material.dart';

import '../command/command_models.dart';
import 'app_notifier.dart';

class AppCommands {
  static const String scratchpadTabId = 'internal_scratchpad_tab';

  static List<Command> getCommands() => [
    BaseCommand(
      id: 'show_logs',
      label: 'Show Logs',
      icon: const Icon(Icons.bug_report),
      defaultPositions: [AppCommandPositions.appBar],
      sourcePlugin: 'App',
      execute: (ref) async {
        final navigatorKey = ref.read(navigatorKeyProvider);
        navigatorKey.currentState?.pushNamed('/logs');
      },
    ),
    BaseCommand(
      id: 'show_settings',
      label: 'Show Settings',
      icon: const Icon(Icons.settings),
      defaultPositions: [AppCommandPositions.appBar],
      sourcePlugin: 'App',
      execute: (ref) async {
        final navigatorKey = ref.read(navigatorKeyProvider);
        navigatorKey.currentState?.pushNamed('/settings');
      },
    ),
    BaseCommand(
      id: 'toggle_fullscreen',
      label: 'Toggle Fullscreen',
      icon: const Icon(Icons.fullscreen),
      defaultPositions: [AppCommandPositions.appBar],
      sourcePlugin: 'App',
      execute: (ref) async {
        ref.read(appNotifierProvider.notifier).toggleFullScreen();
      },
    ),
  ];
}

// FILE: lib/app/app_notifier.dart


import 'dart:async';

import 'package:flutter/material.dart';

import 'package:collection/collection.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../data/file_handler/file_handler.dart';
import '../data/shared_preferences.dart';
import '../project/project_type_handler_registry.dart';
import '../data/repositories/app_state_repository.dart';
import '../data/repositories/project/project_repository.dart';
import '../editor/models/editor_tab_models.dart';
import '../editor/plugins/editor_plugin_registry.dart';
import '../editor/services/editor_service.dart';
import '../data/content_provider/file_content_provider.dart';
import '../editor/tab_metadata_notifier.dart';
import '../widgets/dialogs/file_explorer_dialogs.dart';
import '../explorer/services/explorer_service.dart';
import '../logs/logs_provider.dart';
import '../project/project_models.dart';
import '../project/services/project_service.dart';
import '../utils/clipboard.dart';
import '../utils/toast.dart';
import 'app_state.dart';

final appNotifierProvider = AsyncNotifierProvider<AppNotifier, AppState>(
  AppNotifier.new,
);

final navigatorKeyProvider = Provider((ref) => GlobalKey<NavigatorState>());
final rootScaffoldMessengerKeyProvider = Provider(
  (ref) => GlobalKey<ScaffoldMessengerState>(),
);

class AppNotifier extends AsyncNotifier<AppState> {
  late AppStateRepository _appStateRepository;
  late ProjectService _projectService;
  late EditorService _editorService;
  late ExplorerService _explorerService;
  late Talker _talker;
  @override
  Future<AppState> build() async {
    _talker = ref.read(talkerProvider);
    _appStateRepository = AppStateRepository(
      await ref.watch(sharedPreferencesProvider.future),
      _talker,
    );
    _projectService = ref.watch(projectServiceProvider);
    _editorService = ref.watch(editorServiceProvider);
    _explorerService = ref.watch(explorerServiceProvider);

    ref.listen<AsyncValue<FileOperationEvent>>(fileOperationStreamProvider, (
      previous,
      next,
    ) {
      next.whenData((event) {
        _handleFileOperationEvent(event);
      });
    });

    final appStateDto = await _appStateRepository.loadAppStateDto();
    _talker.info("AppState loaded");

    if (appStateDto.lastOpenedProjectId != null) {
      _talker.info("Attempting to rehydrate last opened project.");
      final meta = appStateDto.knownProjects.firstWhereOrNull(
        (p) => p.id == appStateDto.lastOpenedProjectId,
      );
      if (meta != null) {
        try {
          final project = await _openProjectWithRecovery(
            meta,
            projectStateJson: appStateDto.currentProjectDto?.toJson(),
          );

          if (project != null) {
            _talker.info("Project rehydrated successfully.");
            return AppState(
              knownProjects: appStateDto.knownProjects,
              lastOpenedProjectId: appStateDto.lastOpenedProjectId,
              currentProject: project,
            );
          }
        } catch (e, st) {
          ref
              .read(talkerProvider)
              .handle(e, st, 'Failed to auto-open last project');
        }
      }
    }

    return AppState(
      knownProjects: appStateDto.knownProjects,
      lastOpenedProjectId: appStateDto.lastOpenedProjectId,
    );
  }


  Future<Project?> _openProjectWithRecovery(
    ProjectMetadata meta, {
    Map<String, dynamic>? projectStateJson,
  }) async {
    try {
      final projectDto = await _projectService.openProjectDto(
        meta,
        projectStateJson: projectStateJson,
      );
      final liveSession = await _editorService.rehydrateTabSession(
        projectDto,
        meta,
      );
      final liveWorkspace = _explorerService.rehydrateWorkspace(
        projectDto.workspace,
      );
      final liveSettings = _projectService.rehydrateProjectSettings(
        projectDto.settings,
        meta,
      );
      return Project(
        metadata: meta,
        session: liveSession,
        workspace: liveWorkspace,
        settings: liveSettings,
      );
    } on ProjectPermissionDeniedException catch (e) {
      final context = ref.read(navigatorKeyProvider).currentContext;

      if (context == null || !context.mounted) {
        _talker.error(
          "Permission denied for project '${e.metadata.name}', but no UI context was available to ask for permission again. Aborting open.",
        );
        return null;
      }

      final bool wantsToGrant = await showConfirmDialog(
        context,
        title: 'Permission Required',
        content:
            'Access to the project folder "${e.metadata.name}" has been lost. Please re-grant access.',
      );

      if (wantsToGrant == true) {
        final bool permissionGranted =
            await _projectService.recoverPermissionForProject(e.metadata, context);

        if (permissionGranted) {
          _talker.info("Permission re-granted. Retrying project open...");
          return await _openProjectWithRecovery(
            meta,
            projectStateJson: projectStateJson,
          );
        } else {
           _talker.warning(
            "User attempted to re-grant permission for project ${e.metadata.name}, but failed.",
          );
           MachineToast.error("Permission not granted.");
        }
      } else {
        _talker.warning(
          "User cancelled permission recovery for project ${e.metadata.name}.",
        );
        MachineToast.error("Could not open project: Permission not granted.");
      }
      
      return null;
    }
  }
  
  void _handleFileOperationEvent(FileOperationEvent event) {
    final project = state.value?.currentProject;
    if (project == null) return;

    switch (event) {
      case FileCreateEvent():
        break;
      case FileModifyEvent(modifiedFile: final modifiedFile):
        break;
      case FileRenameEvent(oldFile: final oldFile, newFile: final newFile):
        _editorService.updateTabForRenamedFile(oldFile.uri, newFile);
        break;

      case FileDeleteEvent(deletedFile: final deletedFile):
        final metadataMap = ref.read(tabMetadataProvider);
        final tabIdToDelete =
            metadataMap.entries
                .firstWhereOrNull(
                  (entry) => entry.value.file.uri == deletedFile.uri,
                )
                ?.key;

        if (tabIdToDelete != null) {
          final tabIndex = project.session.tabs.indexWhere(
            (t) => t.id == tabIdToDelete,
          );
          if (tabIndex != -1) {
            final newProject = _editorService.closeTab(project, tabIndex);
            updateCurrentProject(newProject);
          }
        }
        break;
    }
  }

  Future<UnsavedChangesAction> _handleUnsavedChanges(
    List<EditorTab> tabsToCheck,
  ) async {
    final metadataMap = ref.read(tabMetadataProvider);

    final dirtyTabsMetadata =
        tabsToCheck
            .map((tab) => metadataMap[tab.id])
            .whereNotNull()
            .where(
              (metadata) =>
                  metadata.isDirty && metadata.file is! VirtualDocumentFile,
            )
            .toList();

    if (dirtyTabsMetadata.isEmpty) {
      return UnsavedChangesAction.discard;
    }

    final context = ref.read(navigatorKeyProvider).currentContext;
    if (context == null || !context.mounted) {
      _talker.warning(
        'Cannot prompt to save dirty tabs: No valid BuildContext.',
      );
      return UnsavedChangesAction.cancel;
    }

    return await showUnsavedChangesDialog(
          context,
          dirtyFiles: dirtyTabsMetadata,
        ) ??
        UnsavedChangesAction.cancel;
  }


  Future<void> openKnownProject(String projectId) async {
    await _updateState((s) async {
      if (s.currentProject?.id == projectId) return s;
      if (s.currentProject != null) {
        final bool didClose = await closeProject();
        if (!didClose) return s;
        s = state.value!;
      }
      final meta = s.knownProjects.firstWhere((p) => p.id == projectId);
      
      final finalProject = await _openProjectWithRecovery(
        meta,
        projectStateJson: null,
      );

      if (finalProject != null) {
        return s.copyWith(
          currentProject: finalProject,
          lastOpenedProjectId: finalProject.id,
        );
      } else {
        return s.copyWith(clearCurrentProject: true);
      }
    });
    await saveAppState();
  }

  Future<bool> closeProject() async {
    final projectToClose = state.value?.currentProject;
    if (projectToClose == null) return true;

    final allTabs = projectToClose.session.tabs;
    final action = await _handleUnsavedChanges(allTabs);

    switch (action) {
      case UnsavedChangesAction.save:
        await _editorService.saveTabs(projectToClose, allTabs);
        break;
      case UnsavedChangesAction.discard:
        break;
      case UnsavedChangesAction.cancel:
        return false;
    }

    await _projectService.closeProject(projectToClose);
    _updateStateSync((s) => s.copyWith(clearCurrentProject: true));

    return true;
  }
  
  Future<void> createNewProject(ProjectMetadata newMetadata) async {
    await _updateState((s) async {
      if (s.currentProject != null) {
        final bool didClose = await closeProject();
        if (!didClose) return s;
        s = state.value!;
      }

      final projectDto = await _projectService.openProjectDto(newMetadata);

      final liveSession = await _editorService.rehydrateTabSession(
        projectDto,
        newMetadata,
      );
      final liveWorkspace = _explorerService.rehydrateWorkspace(
        projectDto.workspace,
      );
      final liveSettings = _projectService.rehydrateProjectSettings(
        projectDto.settings,
        newMetadata,
      );

      final finalProject = Project(
        metadata: newMetadata,
        session: liveSession,
        workspace: liveWorkspace,
        settings: liveSettings,
      );

      final knownProjects = s.knownProjects.where((p) => p.id != newMetadata.id).toList();

      return s.copyWith(
        currentProject: finalProject,
        lastOpenedProjectId: finalProject.id,
        knownProjects: [...knownProjects, newMetadata],
      );
    });
    await saveAppState();
  }

  Future<void> removeKnownProject(String projectId) async {
    await _updateState((s) async {
      if (s.currentProject?.id == projectId) {
        final bool didClose = await closeProject();
        if (!didClose) return s;
        s = state.value!;
      }

      final projectToRemove = s.knownProjects.firstWhereOrNull((p) => p.id == projectId);
      
      if (projectToRemove != null && projectToRemove.persistenceTypeId == 'simple_state') {
        final prefs = await ref.read(sharedPreferencesProvider.future);
        final storageKey = 'project_state_${projectToRemove.id}';
        await prefs.remove(storageKey);
        _talker.info('Cleared long-term state for removed simple project: ${projectToRemove.name}');
      }

      return s.copyWith(
        knownProjects: s.knownProjects.where((p) => p.id != projectId).toList(),
      );
    });
    await saveAppState();
  }

  /// Opens a file in a new editor tab.
  Future<bool> openFileInEditor(
    DocumentFile file, {
    EditorPlugin? explicitPlugin,
    Completer<EditorWidgetState>? onReadyCompleter,
  }) async {
    final project = state.value?.currentProject;
    if (project == null) return false;

    final result = await _editorService.openFile(
      project,
      file,
      explicitPlugin: explicitPlugin,
      onReadyCompleter: onReadyCompleter,
    );

    switch (result) {
      case OpenFileSuccess(project: final newProject):
        updateCurrentProject(newProject);
        WidgetsBinding.instance.scheduleFrame();
        return true;

      case OpenFileShowChooser(plugins: final plugins):
        final context = ref.read(navigatorKeyProvider).currentContext;
        if (context == null || !context.mounted) return false;
        final chosenPlugin = await showOpenWithDialog(context, plugins);
        if (chosenPlugin != null) {
          return await openFileInEditor(file, explicitPlugin: chosenPlugin);
        }
        return false;

      case OpenFileError(message: final msg):
        MachineToast.error(msg);
        return false;
    }
  }


  void switchTab(int index) {
    final project = state.value?.currentProject;
    if (project == null) return;
    final newProject = _editorService.switchTab(project, index);
    updateCurrentProject(newProject);
  }

  void reorderTabs(int oldIndex, int newIndex) {
    final project = state.value?.currentProject;
    if (project == null) return;
    final newProject = _editorService.reorderTabs(project, oldIndex, newIndex);
    updateCurrentProject(newProject);
  }

  void closeTab(int index) async {
    final project = state.value?.currentProject;
    if (project == null) return;

    final tabToClose = project.session.tabs[index];
    final action = await _handleUnsavedChanges([tabToClose]);

    switch (action) {
      case UnsavedChangesAction.save:
        await _editorService.saveTab(project, tabToClose);
        break;
      case UnsavedChangesAction.discard:
        break;
      case UnsavedChangesAction.cancel:
        return;
    }

    final currentProject = state.value?.currentProject;
    if (currentProject == null) return;

    final newIndex = currentProject.session.tabs.indexOf(tabToClose);
    if (newIndex != -1) {
      final newProject = _editorService.closeTab(currentProject, newIndex);
      updateCurrentProject(newProject);
      WidgetsBinding.instance.scheduleFrame();
    }
  }

  void closeMultipleTabs(List<int> indicesToClose) async {
    final project = state.value?.currentProject;
    if (project == null || indicesToClose.isEmpty) return;

    final sortedIndices = indicesToClose..sort((a, b) => b.compareTo(a));

    var newProject = project;
    for (final index in sortedIndices) {
      newProject = _editorService.closeTab(newProject, index);
    }

    updateCurrentProject(newProject);
    WidgetsBinding.instance.scheduleFrame();
  }

  void toggleFullScreen() {
    _updateStateSync((s) => s.copyWith(isFullScreen: !s.isFullScreen));
    saveAppState();
  }

  void updateCurrentProject(Project newProject) {
    _updateStateSync((s) => s.copyWith(currentProject: newProject));
  }


  Future<void> saveAppState() async {
    final project = state.value?.currentProject;
    if (project != null) {
      await ref.read(editorServiceProvider).flushAllHotTabs();
    }
    await saveNonHotState();
  }

  Future<void> saveNonHotState() async {
    final appState = state.value;
    if (appState == null) return;

    final currentProject = appState.currentProject;

    if (currentProject != null) {
      await _projectService.saveProject(currentProject);
    }
    
    final registry = ref.read(fileContentProviderRegistryProvider);
    final liveTabMetadata = ref.read(tabMetadataProvider);
    
    final appStateDto = appState.toDto(liveTabMetadata, registry);
    await _appStateRepository.saveAppStateDto(appStateDto);
  }

  void setBottomToolbarOverride(Widget? widget) =>
      _updateStateSync((s) => s.copyWith(bottomToolbarOverride: widget));

  void clearBottomToolbarOverride() =>
      _updateStateSync((s) => s.copyWith(clearBottomToolbarOverride: true));

  void clearClipboard() => ref.read(clipboardProvider.notifier).state = null;

  Future<void> _updateState(Future<AppState> Function(AppState) updater) async {
    final previousState = state.value;
    if (previousState == null) return;
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async => await updater(previousState));
  }

  void _updateStateSync(AppState Function(AppState) updater) {
    final previousState = state.value;
    if (previousState == null) return;
    state = AsyncData(updater(previousState));
  }
}

// FILE: lib/app/app_screen.dart


import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import 'package:back_button_interceptor/back_button_interceptor.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../command/command_widgets.dart';
import '../editor/widgets/editor_widgets.dart';
import '../editor/models/editor_command_context.dart';
import '../editor/models/editor_plugin_models.dart';
import '../editor/tab_metadata_notifier.dart';
import '../widgets/dialogs/file_explorer_dialogs.dart';
import '../explorer/widgets/explorer_host_drawer.dart';
import '../settings/settings_notifier.dart';
import 'app_notifier.dart';

class AppScreen extends ConsumerStatefulWidget {
  const AppScreen({super.key});

  @override
  ConsumerState<AppScreen> createState() => _AppScreenState();
}

class _AppScreenState extends ConsumerState<AppScreen> {
  late final GlobalKey<ScaffoldState> _scaffoldKey;
  bool _isExitDialogShowing = false;

  @override
  void initState() {
    super.initState();
    _scaffoldKey = GlobalKey<ScaffoldState>();
    BackButtonInterceptor.add(_backButtonInterceptor);
  }

  @override
  void dispose() {
    BackButtonInterceptor.remove(_backButtonInterceptor);
    super.dispose();
  }

  Future<bool> _backButtonInterceptor(
    bool stopDefaultButtonEvent,
    RouteInfo info,
  ) async {

    if (!mounted) return false;

    bool canPop = Navigator.of(context).canPop();
    final currentRouteName = ModalRoute.of(context)?.settings.name;
    if (currentRouteName != '/') {
      return false;
    }
    if (canPop == true) {
      return false;
    }
    if (_scaffoldKey.currentState?.isDrawerOpen ?? false) {
      return false;
    }


    final isFullScreen =
        ref.read(appNotifierProvider).value?.isFullScreen ?? false;
    if (isFullScreen) {
      ref.read(appNotifierProvider.notifier).toggleFullScreen();
      return true;
    }

    if (_isExitDialogShowing) {
      return true;
    }

    try {
      _isExitDialogShowing = true;

      final shouldExit = await showConfirmDialog(
        context,
        title: 'Exit App?',
        content: 'Are you sure you want to close the application?',
      );

      if (shouldExit) {
        await SystemNavigator.pop();
      }
    } finally {
      _isExitDialogShowing = false;
    }

    return true;
  }

  @override
  Widget build(BuildContext context) {
    final appState = ref.watch(appNotifierProvider).value;
    final currentTab = appState?.currentProject?.session.currentTab;
    final currentPlugin = currentTab?.plugin;
    final isFullScreen = appState?.isFullScreen ?? false;

    final currentTabMetadata = ref.watch(
      tabMetadataProvider.select(
        (metadataMap) => currentTab != null ? metadataMap[currentTab.id] : null,
      ),
    );
    final appBarTitle = currentTabMetadata?.title ?? 'Machine';

    final generalSettings =
        ref.watch(
          settingsProvider.select(
            (s) => s.pluginSettings[GeneralSettings] as GeneralSettings?,
          ),
        ) ??
        GeneralSettings();

    final double toolbarHeight =
        Theme.of(context).appBarTheme.toolbarHeight ?? kToolbarHeight;

    return Scaffold(
      key: _scaffoldKey,
      appBar:
          (!isFullScreen || !generalSettings.hideAppBarInFullScreen)
              ? _AppScreenAppBar(
                scaffoldKey: _scaffoldKey,
                currentPlugin: currentPlugin,
                appBarTitle: appBarTitle,
                height: toolbarHeight,
              )
              : null,
      drawer: const ExplorerHostDrawer(),
      body: Column(
        children: [
          if (!isFullScreen || !generalSettings.hideTabBarInFullScreen)
            TabBarWidget(),
          const Expanded(child: FocusScope(child: EditorView())),
          if (currentPlugin != null &&
              (!isFullScreen || !generalSettings.hideBottomToolbarInFullScreen))
            currentPlugin.buildToolbar(ref),
        ],
      ),
    );
  }
}

class _AppScreenAppBar extends ConsumerWidget implements PreferredSizeWidget {
  const _AppScreenAppBar({
    required this.scaffoldKey,
    required this.currentPlugin,
    required this.appBarTitle,
    required this.height,
  });

  final GlobalKey<ScaffoldState> scaffoldKey;
  final EditorPlugin? currentPlugin;
  final String appBarTitle;
  final double height;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final appBarOverride = ref.watch(
      activeCommandContextProvider.select((context) => context.appBarOverride),
    );

    if (appBarOverride != null) {
      return appBarOverride;
    }

    return AppBar(
      leading: IconButton(
        icon: const Icon(Icons.menu),
        onPressed: () => scaffoldKey.currentState?.openDrawer(),
      ),
      actions: [
        if (currentPlugin != null)
          currentPlugin!.wrapCommandToolbar(const AppBarCommands())
        else
          const AppBarCommands(),
      ],
      title: Text(appBarTitle),
    );
  }

  @override
  Size get preferredSize {
    return Size.fromHeight(height);
  }
}

// FILE: lib/app/app_state.dart

import 'package:flutter/material.dart';

import 'package:collection/collection.dart';

import '../data/content_provider/file_content_provider.dart';
import '../project/project_models.dart';

import '../data/dto/app_state_dto.dart';
import '../data/dto/project_dto.dart';
import '../editor/tab_metadata_notifier.dart';

@immutable
class AppState {
  final List<ProjectMetadata> knownProjects;
  final String? lastOpenedProjectId;
  final Project? currentProject;

  final Widget? bottomToolbarOverride;
  final bool isFullScreen;

  const AppState({
    this.knownProjects = const [],
    this.lastOpenedProjectId,
    this.currentProject,
    this.bottomToolbarOverride,
    this.isFullScreen = false,
  });

  factory AppState.initial() => const AppState();

  AppStateDto toDto(
    Map<String, TabMetadata> liveTabMetadata,
    FileContentProviderRegistry registry,
  ) {
    final ProjectDto? projectDto =
        currentProject?.toDto(liveTabMetadata, registry);
    
    return AppStateDto(
      knownProjects: knownProjects,
      lastOpenedProjectId: lastOpenedProjectId,
      currentProjectDto: projectDto,
    );
  }

  AppState copyWith({
    List<ProjectMetadata>? knownProjects,
    String? lastOpenedProjectId,
    Project? currentProject,
    bool clearCurrentProject = false,
    Widget? bottomToolbarOverride,
    bool clearBottomToolbarOverride = false,
    bool? isFullScreen,
  }) {
    return AppState(
      knownProjects: knownProjects ?? List.from(this.knownProjects),
      lastOpenedProjectId: lastOpenedProjectId ?? this.lastOpenedProjectId,
      currentProject:
          clearCurrentProject ? null : (currentProject ?? this.currentProject),
      bottomToolbarOverride:
          clearBottomToolbarOverride
              ? null
              : bottomToolbarOverride ?? this.bottomToolbarOverride,
      isFullScreen: isFullScreen ?? this.isFullScreen,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    final listEquals = const DeepCollectionEquality().equals;

    return other is AppState &&
        listEquals(other.knownProjects, knownProjects) &&
        other.lastOpenedProjectId == lastOpenedProjectId &&
        other.currentProject == currentProject &&
        other.bottomToolbarOverride == bottomToolbarOverride &&
        other.isFullScreen == isFullScreen;
  }

  @override
  int get hashCode => Object.hash(
    const DeepCollectionEquality().hash(knownProjects),
    lastOpenedProjectId,
    currentProject,
    bottomToolbarOverride,
    isFullScreen,
  );
}

// FILE: lib/app/lifecycle.dart

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'app_notifier.dart';
import '../logs/logs_provider.dart';
import '../data/cache/hot_state_cache_service.dart';

class LifecycleHandler extends ConsumerStatefulWidget {
  final Widget child;
  final Talker talker;
  const LifecycleHandler({
    super.key,
    required this.child,
    required this.talker,
  });
  @override
  ConsumerState<LifecycleHandler> createState() => _LifecycleHandlerState();
}

class _LifecycleHandlerState extends ConsumerState<LifecycleHandler>
    with WidgetsBindingObserver {
  Timer? _heartbeatTimer;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    if (WidgetsBinding.instance.lifecycleState == AppLifecycleState.resumed) {
      _startHeartbeat();
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _stopHeartbeat();
    super.dispose();
  }

  void _startHeartbeat() {
    _stopHeartbeat();
    _heartbeatTimer = Timer.periodic(const Duration(seconds: 15), (timer) {
      ref.read(hotStateCacheServiceProvider).sendHeartbeat();
    });
    ref.read(hotStateCacheServiceProvider).sendHeartbeat();
    ref.read(talkerProvider).info('[Lifecycle] Heartbeat started.');
  }

  void _stopHeartbeat() {
    _heartbeatTimer?.cancel();
    _heartbeatTimer = null;
    ref.read(talkerProvider).info('[Lifecycle] Heartbeat stopped.');
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) async {
    super.didChangeAppLifecycleState(state);

    final hotStateCacheService = ref.read(hotStateCacheServiceProvider);

    if (state == AppLifecycleState.resumed) {
      _startHeartbeat();
      await hotStateCacheService.notifyUiResumed();
    } else {
      _stopHeartbeat();
    }

    if (state == AppLifecycleState.paused) {
      ref
          .read(talkerProvider)
          .info(
            '[Lifecycle] App paused. Flushing state and notifying service.',
          );
      await hotStateCacheService.flush();
      await ref.read(appNotifierProvider.notifier).saveNonHotState();
      await hotStateCacheService.notifyUiPaused();
    }

    if (state == AppLifecycleState.detached) {
      ref
          .read(talkerProvider)
          .info('[Lifecycle] App detached. Stopping service immediately.');
      await hotStateCacheService.flush();
      await ref.read(appNotifierProvider.notifier).saveNonHotState();
    }
  }

  @override
  Widget build(BuildContext context) {
    return widget.child;
  }
}

// FILE: lib/editor/models/editor_command_context.dart


import 'package:flutter/material.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../app/app_notifier.dart';

@immutable
abstract class CommandContext {
  final Widget? appBarOverride;
  final Key? appBarOverrideKey;

  const CommandContext({this.appBarOverride, this.appBarOverrideKey});

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is CommandContext &&
        other.appBarOverrideKey == appBarOverrideKey;
  }

  @override
  int get hashCode => appBarOverrideKey.hashCode;
}

class EmptyCommandContext extends CommandContext {
  const EmptyCommandContext()
    : super(appBarOverride: null, appBarOverrideKey: null);
}

final commandContextProvider = StateProvider.family<CommandContext, String>(
  (ref, tabId) => const EmptyCommandContext(),
);
final activeCommandContextProvider = Provider<CommandContext>((ref) {
  final activeTabId = ref.watch(
    appNotifierProvider.select(
      (s) => s.value?.currentProject?.session.currentTab?.id,
    ),
  );
  if (activeTabId == null) {
    return const EmptyCommandContext();
  }
  return ref.watch(commandContextProvider(activeTabId));
});

// FILE: lib/editor/models/editor_plugin_models.dart


import 'dart:async';

import 'package:flutter/material.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../command/command_models.dart';
import '../../data/cache/type_adapters.dart';
import '../../data/file_handler/file_handler.dart';
import '../../settings/settings_models.dart';
import 'editor_tab_models.dart';
import '../../data/content_provider/file_content_provider.dart';
import '../../asset_cache/asset_models.dart';

export '../../settings/settings_models.dart';

enum PluginDataRequirement { string, bytes }

class EditorInitData {
  final EditorContent initialContent;
  final TabHotStateDto? hotState;
  final String baseContentHash;

  const EditorInitData({
    required this.initialContent,
    this.hotState,
    required this.baseContentHash,
  });
}

abstract class EditorPlugin {
  String get id;
  String get name;
  Widget get icon;
  int get priority;


  PluginDataRequirement get dataRequirement => PluginDataRequirement.string;

  bool supportsFile(DocumentFile file) => false;

  bool canOpenFileContent(String content, DocumentFile file) {
    return dataRequirement == PluginDataRequirement.string;
  }

  List<CommandPosition> getCommandPositions() => [];

  List<Command> getCommands() => [];

  List<CommandGroup> getCommandGroups() => [];
  
  List<Command> getAppCommands() => [];

  List<FileContextCommand> getFileContextMenuCommands(DocumentFile item) => [];

  List<TabContextCommand> getTabContextMenuCommands() => [];

  PluginSettings? get settings => null;

  Widget buildSettingsUI(
    PluginSettings settings,
    void Function(PluginSettings) onChanged,
  ) =>
      const SizedBox.shrink();
  Widget wrapCommandToolbar(Widget toolbar) => toolbar;

  Widget buildToolbar(WidgetRef ref) => const SizedBox.shrink();

  void activateTab(EditorTab tab, Ref ref) {}

  void deactivateTab(EditorTab tab, Ref ref) {}

  void disposeTab(EditorTab tab) {}

  Future<void> dispose() async {}


  List<FileContentProvider Function(Ref ref)>
  get fileContentProviderFactories => [];

  String? get hotStateDtoType;

  Type? get hotStateDtoRuntimeType;

  TypeAdapter<TabHotStateDto>? get hotStateAdapter;

  /// This allows the plugin to define how to load custom file types 
  List<AssetLoader> get assetLoaders => [];


  Future<EditorTab> createTab(
    DocumentFile file,
    EditorInitData initData, {
    String? id,
    Completer<EditorWidgetState>? onReadyCompleter,
  });

  EditorWidget buildEditor(EditorTab tab, WidgetRef ref);
}

abstract class PluginSettings extends MachineSettings {}

// FILE: lib/editor/models/editor_tab_models.dart

// FILE: lib/editor/editor_tab_models.dart

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';

import '../../data/dto/project_dto.dart';
import '../../data/dto/tab_hot_state_dto.dart';
import 'editor_plugin_models.dart';
import '../tab_metadata_notifier.dart';

import '../../data/content_provider/file_content_provider.dart';

export '../../data/dto/tab_hot_state_dto.dart';

@immutable
class TabSessionState {
  final List<EditorTab> tabs;
  final int currentTabIndex;
  final Map<String, TabMetadata> tabMetadata;

  const TabSessionState({
    this.tabs = const [],
    this.currentTabIndex = 0,
    this.tabMetadata = const {},
  });

  TabSessionStateDto toDto(
    Map<String, TabMetadata> liveMetadata,
    FileContentProviderRegistry registry,
  ) {
    return TabSessionStateDto(
      tabs: tabs.map((t) => t.toDto()).toList(),
      currentTabIndex: currentTabIndex,
      tabMetadata: liveMetadata.map(
        (key, value) => MapEntry(
          key,
          TabMetadataDto(
            fileUri: value.file.uri,
            isDirty: value.isDirty,
            fileName: value.file.name,
            fileType: registry.getTypeIdForFile(value.file),
          ),
        ),
      ),
    );
  }

  EditorTab? get currentTab =>
      tabs.isNotEmpty && currentTabIndex < tabs.length
          ? tabs[currentTabIndex]
          : null;

  TabSessionState copyWith({List<EditorTab>? tabs, int? currentTabIndex}) {
    return TabSessionState(
      tabs: tabs ?? List.from(this.tabs),
      currentTabIndex: currentTabIndex ?? this.currentTabIndex,
    );
  }
}

sealed class EditorContent {}

class EditorContentString extends EditorContent {
  final String content;
  EditorContentString(this.content);
}

class EditorContentBytes extends EditorContent {
  final Uint8List bytes;
  EditorContentBytes(this.bytes);
}

abstract class EditorWidget extends ConsumerStatefulWidget {
  final EditorTab tab;

  const EditorWidget({required this.tab, required super.key});
}

abstract class EditorWidgetState<T extends EditorWidget>
    extends ConsumerState<T> {
  @override
  void initState() {
    super.initState();
    init();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        onFirstFrameReady();
      }
    });
  }

  @protected
  void init();

  @protected
  void onFirstFrameReady();

  void syncCommandContext();


  void undo();
  void redo();
  Future<EditorContent> getContent();
  void onSaveSuccess(String newHash);
  Future<TabHotStateDto?> serializeHotState();
}

@immutable
abstract class WorkspaceTab {
  final String id;
  final EditorPlugin plugin;

  WorkspaceTab({required this.plugin, String? id})
    : id = id ?? const Uuid().v4();

  void dispose();
}

@immutable
abstract class EditorTab extends WorkspaceTab {
  GlobalKey<EditorWidgetState> get editorKey;

  final Completer<EditorWidgetState> onReady;

  EditorTab({
    required super.plugin,
    super.id,
    Completer<EditorWidgetState>? onReadyCompleter,
  }) : onReady = onReadyCompleter ?? Completer<EditorWidgetState>();

  @override
  void dispose();

  EditorTabDto toDto() {
    return EditorTabDto(id: id, pluginType: plugin.id);
  }
}

// FILE: lib/editor/models/text_editing_capability.dart

// FILE: lib/editor/services/text_editing_capability.dart

import 'package:flutter/foundation.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../app/app_notifier.dart';
import '../../command/command_models.dart';
import 'editor_command_context.dart';
import 'editor_plugin_models.dart';

@immutable
class TextPosition {
  final int line;
  final int column;

  const TextPosition({required this.line, required this.column});
}

@immutable
class TextRange {
  final TextPosition start;
  final TextPosition end;

  const TextRange({required this.start, required this.end});
}

@immutable
class TextSelectionDetails {
  final TextRange? range;
  final String content;

  const TextSelectionDetails({required this.range, required this.content});
}

@immutable
sealed class TextEdit {
  const TextEdit();
}

class ReplaceLinesEdit extends TextEdit {
  final int startLine;

  final int endLine;

  final String newContent;

  const ReplaceLinesEdit({
    required this.startLine,
    required this.endLine,
    required this.newContent,
  });
}

class ReplaceAllOccurrencesEdit extends TextEdit {
  final String find;
  final String replace;

  const ReplaceAllOccurrencesEdit({required this.find, required this.replace});
}

class RevealRangeEdit extends TextEdit {
  final TextRange range;
  const RevealRangeEdit({required this.range});
}

class ReplaceRangeEdit extends TextEdit {
  final TextRange range;
  final String replacement;
  const ReplaceRangeEdit({required this.range, required this.replacement});
}

class BatchReplaceRangesEdit extends TextEdit {
  final List<ReplaceRangeEdit> edits;
  const BatchReplaceRangesEdit({required this.edits});
}

mixin TextEditablePlugin on EditorPlugin {}

abstract mixin class TextEditable {
  void applyEdit(TextEdit edit) {
    switch (edit) {
      case RevealRangeEdit():
        revealRange(edit.range);
        break;
      case ReplaceLinesEdit():
        replaceLines(edit.startLine, edit.endLine, edit.newContent);
        break;
      case ReplaceAllOccurrencesEdit():
        replaceAllOccurrences(edit.find, edit.replace);
        break;
      case ReplaceRangeEdit():
        replaceSelection(edit.replacement, range: edit.range);
        break;
      case BatchReplaceRangesEdit():
        batchReplaceRanges(edit.edits);
        break;
    }
  }

  Future<TextSelectionDetails> getSelectionDetails();

  void replaceSelection(String replacement, {TextRange? range});

  Future<bool> isSelectionCollapsed();

  Future<String> getSelectedText();

  Future<String> getTextContent();

  void insertTextAtLine(int lineNumber, String textToInsert);

  void replaceLines(int startLine, int endLine, String newContent);

  void replaceAllOccurrences(String find, String replace);

  void replaceAllPattern(Pattern pattern, String replacement);

  void revealRange(TextRange range);

  void batchReplaceRanges(List<ReplaceRangeEdit> edits);
}


abstract class TextEditableCommandContext extends CommandContext {
  final bool hasSelection;

  const TextEditableCommandContext({
    required this.hasSelection,
    super.appBarOverride,
    super.appBarOverrideKey,
  });

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is TextEditableCommandContext &&
        other.hasSelection == hasSelection &&
        super == other;
  }

  @override
  int get hashCode => Object.hash(super.hashCode, hasSelection);
}

class BaseTextEditableCommand extends Command {
  final Future<void> Function(WidgetRef, TextEditable) _execute;
  final bool Function(WidgetRef, TextEditableCommandContext)? _canExecute;

  const BaseTextEditableCommand({
    required super.id,
    required super.label,
    required super.icon,
    required super.defaultPositions,
    required super.sourcePlugin,
    required Future<void> Function(WidgetRef, TextEditable) execute,
    bool Function(WidgetRef, TextEditableCommandContext)? canExecute,
  }) : _execute = execute,
       _canExecute = canExecute;

  @override
  bool canExecute(WidgetRef ref) {
    final activeContext = ref.watch(activeCommandContextProvider);
    if (activeContext is! TextEditableCommandContext) {
      return false;
    }
    return _canExecute?.call(ref, activeContext) ?? true;
  }

  @override
  Future<void> execute(WidgetRef ref) async {
    final activeTab =
        ref.read(appNotifierProvider).value?.currentProject?.session.currentTab;
    final editorState = activeTab?.editorKey.currentState;

    if (editorState != null && editorState is TextEditable) {
      final editableState = editorState as TextEditable;
      await _execute(ref, editableState);
    }
  }
}

// FILE: lib/editor/plugins/code_editor/code_editor_hot_state_adapter.dart


import '../../../data/cache/type_adapters.dart';
import 'code_editor_hot_state_dto.dart';

class CodeEditorHotStateAdapter implements TypeAdapter<CodeEditorHotStateDto> {
  static const String _contentKey = 'content';
  static const String _languageIdKey = 'languageId';
  static const String _hashKey = 'baseContentHash';

  @override
  CodeEditorHotStateDto fromJson(Map<String, dynamic> json) {
    return CodeEditorHotStateDto(
      content: json[_contentKey] as String? ?? '',
      languageId: json[_languageIdKey] as String?,
      baseContentHash: json[_hashKey] as String?,
    );
  }

  @override
  Map<String, dynamic> toJson(CodeEditorHotStateDto object) {
    return {
      _contentKey: object.content,
      _languageIdKey: object.languageId,
      _hashKey: object.baseContentHash,
    };
  }
}

// FILE: lib/editor/plugins/code_editor/code_editor_hot_state_dto.dart


import 'package:flutter/foundation.dart';

import '../../../data/dto/tab_hot_state_dto.dart';

@immutable
class CodeEditorHotStateDto extends TabHotStateDto {
  final String content;

  /// This is null if the language is just inferred from the file extension.
  final String? languageId;

  const CodeEditorHotStateDto({
    required this.content,
    this.languageId,
    super.baseContentHash,
  });
}

// FILE: lib/editor/plugins/code_editor/code_editor_models.dart

import 'package:flutter/material.dart';

import '../../models/editor_tab_models.dart';
import '../../models/text_editing_capability.dart';
import '../../models/editor_plugin_models.dart';
import 'code_editor_widgets.dart';

@immutable
class CodeEditorTab extends EditorTab {
  @override
  final GlobalKey<CodeEditorMachineState> editorKey;

  final String initialContent;
  final String? cachedContent;
  final String? initialLanguageId; 
  final String? initialBaseContentHash;

  CodeEditorTab({
    required super.plugin,
    required this.initialContent,
    this.cachedContent,
    this.initialLanguageId,
    this.initialBaseContentHash,
    super.id,
    super.onReadyCompleter,
  }) : editorKey = GlobalKey<CodeEditorMachineState>();

  @override
  void dispose() {}

  Map<String, dynamic> toJson() => {
    'type': 'code',
    'id': id,
    'pluginType': plugin.runtimeType.toString(),
  };
}

class CodeEditorSettings extends PluginSettings {
  bool wordWrap;
  double fontSize;
  String fontFamily;
  String themeName;
  double? fontHeight;
  bool fontLigatures;
  String scratchpadFilename;
  String? scratchpadLocalPath;

  CodeEditorSettings({
    this.wordWrap = false,
    this.fontSize = 14,
    this.fontFamily = 'JetBrainsMono',
    this.themeName = 'Atom One Dark',
    this.fontHeight,
    this.fontLigatures = true,
    this.scratchpadFilename = 'scratchpad.dart',
    this.scratchpadLocalPath,
  });

  @override
  Map<String, dynamic> toJson() => {
        'wordWrap': wordWrap,
        'fontSize': fontSize,
        'fontFamily': fontFamily,
        'themeName': themeName,
        'fontHeight': fontHeight,
        'fontLigatures': fontLigatures,
        'scratchpadFilename': scratchpadFilename,
        'scratchpadLocalPath': scratchpadLocalPath,
      };

  @override
  void fromJson(Map<String, dynamic> json) {
    wordWrap = json['wordWrap'] ?? false;
    fontSize = json['fontSize']?.toDouble() ?? 14;
    fontFamily = json['fontFamily'] ?? 'JetBrainsMono';
    themeName = json['themeName'] ?? 'Atom One Dark';
    fontHeight = json['fontHeight']?.toDouble();
    fontLigatures = json['fontLigatures'] ?? true;
    scratchpadFilename = json['scratchpadFilename'] ?? 'scratchpad.dart';
    scratchpadLocalPath = json['scratchpadLocalPath'] as String?;
  }

  CodeEditorSettings copyWith({
    bool? wordWrap,
    double? fontSize,
    String? fontFamily,
    String? themeName,
    double? fontHeight,
    bool setFontHeightToNull = false,
    bool? fontLigatures,
    String? scratchpadFilename,
    String? scratchpadLocalPath,
    bool setScratchpadLocalPathToNull = false,
  }) {
    return CodeEditorSettings(
      wordWrap: wordWrap ?? this.wordWrap,
      fontSize: fontSize ?? this.fontSize,
      fontFamily: fontFamily ?? this.fontFamily,
      themeName: themeName ?? this.themeName,
      fontHeight: setFontHeightToNull ? null : (fontHeight ?? this.fontHeight),
      fontLigatures: fontLigatures ?? this.fontLigatures,
      scratchpadFilename: scratchpadFilename ?? this.scratchpadFilename,
      scratchpadLocalPath: setScratchpadLocalPathToNull
          ? null
          : (scratchpadLocalPath ?? this.scratchpadLocalPath),
    );
  }

  @override
  MachineSettings clone() {
    return CodeEditorSettings(
      wordWrap: wordWrap,
      fontSize: fontSize,
      fontFamily: fontFamily,
      themeName: themeName,
      fontHeight: fontHeight,
      fontLigatures: fontLigatures,
      scratchpadFilename: scratchpadFilename,
      scratchpadLocalPath: scratchpadLocalPath,
    );
  }
}

@immutable
class CodeEditorCommandContext extends TextEditableCommandContext {
  final bool canUndo;
  final bool canRedo;
  final bool hasMark;

  const CodeEditorCommandContext({
    this.canUndo = false,
    this.canRedo = false,
    this.hasMark = false,
    required super.hasSelection,
    super.appBarOverride,
    super.appBarOverrideKey,
  });

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is CodeEditorCommandContext &&
        other.canUndo == canUndo &&
        other.canRedo == canRedo &&
        other.hasMark == hasMark &&
        super == other;
  }

  @override
  int get hashCode => Object.hash(super.hashCode, canUndo, canRedo, hasMark);
}

// FILE: lib/editor/plugins/code_editor/code_editor_plugin.dart

import 'dart:async';

import 'package:flutter/material.dart';

import 'package:collection/collection.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:re_editor/re_editor.dart';

import '../../../app/app_notifier.dart';
import '../../../command/command_models.dart';
import '../../../command/command_widgets.dart';
import '../../../data/cache/type_adapters.dart';
import '../../../data/file_handler/file_handler.dart';
import '../../../settings/settings_notifier.dart';
import '../../../data/repositories/project/project_repository.dart';
import '../../models/editor_command_context.dart';
import '../../../editor/services/editor_service.dart';
import '../../models/text_editing_capability.dart';
import '../../../logs/logs_provider.dart';
import '../../../project/project_models.dart';
import '../../../utils/toast.dart';
import '../../models/editor_tab_models.dart';
import '../../tab_metadata_notifier.dart';
import '../../models/editor_plugin_models.dart';
import 'code_editor_hot_state_adapter.dart';
import 'code_editor_hot_state_dto.dart';
import 'code_editor_models.dart';
import 'code_editor_settings_widget.dart';
import 'code_editor_widgets.dart';
import '../../../utils/code_themes.dart';

import 'package:machine/editor/services/language/language_models.dart';
import 'package:machine/editor/services/language/language_registry.dart';

class CodeEditorPlugin extends EditorPlugin with TextEditablePlugin {
  static const String pluginId = 'com.machine.code_editor';
  static const String hotStateId = 'com.machine.code_editor_state';
  static const CommandPosition selectionToolbar = CommandPosition(
    id: 'com.machine.code_editor.selection_toolbar',
    label: 'Code Selection Toolbar',
    icon: Icons.edit_attributes,
  );
  @override
  String get id => pluginId;
  @override
  String get name => 'Code Editor';
  @override
  Widget get icon => const Icon(Icons.code);
  @override
  final PluginSettings? settings = CodeEditorSettings();
  @override
  Widget buildSettingsUI(
    PluginSettings settings,
    void Function(PluginSettings) onChanged,
  ) =>
      CodeEditorSettingsUI(settings: settings as CodeEditorSettings, onChanged: onChanged);
  @override
  PluginDataRequirement get dataRequirement => PluginDataRequirement.string;

  @override
  Type? get hotStateDtoRuntimeType => CodeEditorHotStateDto;

  @override
  Widget wrapCommandToolbar(Widget toolbar) {
    return CodeEditorTapRegion(child: toolbar);
  }

  @override
  Future<void> dispose() async {}
  @override
  void disposeTab(EditorTab tab) {}

  @override
  int get priority => 0;

  @override
  bool supportsFile(DocumentFile file) {
    return Languages.isSupported(file.name);
  }


  @override
  bool canOpenFileContent(String content, DocumentFile file) {
    return true;
  }

  @override
  List<FileContextCommand> getFileContextMenuCommands(DocumentFile item) {
    return [
      BaseFileContextCommand(
        id: 'add_import',
        label: 'Add Import',
        icon: const Icon(Icons.arrow_downward),
        sourcePlugin: id,
        canExecuteFor: (ref, item) {
          final activeTab = ref.read(appNotifierProvider).value?.currentProject?.session.currentTab;
          if (activeTab is! CodeEditorTab) return false;

          // 2. Active file must support import formatting
          final activeFile = ref.read(tabMetadataProvider)[activeTab.id]?.file;
          if (activeFile == null) return false;

          final config = Languages.getForFile(activeFile.name);
          return config.importFormatter != null;
        },
        executeFor: (ref, item) async {
          await _executeAddImport(ref, item);
        },
      ),
    ];
  }

  @override
  List<TabContextCommand> getTabContextMenuCommands() {
    return [
      BaseTabContextCommand(
        id: 'add_import_from_tab',
        label: 'Add Import From Tab',
        icon: const Icon(Icons.arrow_downward, size: 20),
        sourcePlugin: id,
        canExecuteFor: (ref, activeTab, targetTab) {
          if (activeTab is! CodeEditorTab || activeTab.id == targetTab.id) return false;

          final activeFile = ref.read(tabMetadataProvider)[activeTab.id]?.file;
          if (activeFile == null) return false;

          final config = Languages.getForFile(activeFile.name);
          return config.importFormatter != null;
        },
        executeFor: (ref, activeTab, targetTab) async {
          final targetFile = ref.read(tabMetadataProvider)[targetTab.id]?.file;
          if (targetFile != null) {
            await _executeAddImport(ref, targetFile);
          }
        },
      ),
    ];
  }
  
  Future<void> _executeAddImport(WidgetRef ref, DocumentFile targetFile) async {
    final activeTab = ref.read(appNotifierProvider).value?.currentProject?.session.currentTab;
    if (activeTab == null) return;

    final activeFile = ref.read(tabMetadataProvider)[activeTab.id]?.file;
    final repo = ref.read(projectRepositoryProvider);
    
    final editorState = activeTab.editorKey.currentState;
    if (activeFile == null || repo == null || editorState is! TextEditable) {
      return;
    }
    final editable = editorState as TextEditable;

    final config = Languages.getForFile(activeFile.name);
    final formatter = config.importFormatter;
    
    if (formatter == null) {
      MachineToast.error("Imports are not supported for ${config.name}");
      return;
    }

    final relativePath = _calculateRelativePath(
      from: activeFile.uri,
      to: targetFile.uri,
      fileHandler: repo.fileHandler,
      ref: ref,
    );

    if (relativePath == null) {
      MachineToast.error('Could not calculate relative path.');
      return;
    }

    final currentContent = await editable.getTextContent();
    final lines = currentContent.split('\n');
    
    int lastImportIndex = -1;
    bool alreadyExists = false;

    for (int i = 0; i < lines.length; i++) {
      final line = lines[i];
      
      for (final pattern in config.importPatterns) {
        final match = pattern.firstMatch(line);
        if (match != null) {
          lastImportIndex = i;
          
          if (match.groupCount >= 1) {
            final existingPath = match.group(1);
            if (existingPath == relativePath) {
              alreadyExists = true;
            }
          }
        }
      }
      if (alreadyExists) break;
    }

    if (alreadyExists) {
      MachineToast.info('Import already exists.');
      return;
    }

    final importStatement = formatter(relativePath);
    final insertionLine = lastImportIndex + 1;
    
    editable.insertTextAtLine(insertionLine, "$importStatement\n");
    MachineToast.info("Added: $importStatement");
  }

  String? _calculateRelativePath({
    required String from,
    required String to,
    required FileHandler fileHandler,
    required WidgetRef ref,
  }) {
    try {
      final fromDirUri = fileHandler.getParentUri(from);

      final fromPath = fileHandler.getPathForDisplay(fromDirUri);
      final toPath = fileHandler.getPathForDisplay(to);

      final fromSegments =
          fromPath.split('/').where((s) => s.isNotEmpty).toList();
      final toSegments = toPath.split('/').where((s) => s.isNotEmpty).toList();

      int commonLength = 0;
      while (commonLength < fromSegments.length &&
          commonLength < toSegments.length &&
          fromSegments[commonLength] == toSegments[commonLength]) {
        commonLength++;
      }

      final upCount = fromSegments.length - commonLength;
      final upPath = List.filled(upCount, '..');

      final downPath = toSegments.sublist(commonLength);

      final relativePathSegments = [...upPath, ...downPath];

      if (relativePathSegments.isEmpty && toSegments.isNotEmpty) {
        return toSegments.last;
      }

      return relativePathSegments.join('/');
    } catch (e) {
      ref.read(talkerProvider).error("Failed to calculate relative path: $e");
      return null;
    }
  }

  @override
  String get hotStateDtoType => hotStateId;

  @override
  TypeAdapter<TabHotStateDto> get hotStateAdapter =>
      CodeEditorHotStateAdapter();

  @override
  List<CommandPosition> getCommandPositions() {
    return [selectionToolbar];
  }

  @override
  Future<EditorTab> createTab(
    DocumentFile file,
    EditorInitData initData, {
    String? id,
    Completer<EditorWidgetState>? onReadyCompleter,
  }) async {
    final stringContent = initData.initialContent as EditorContentString;
    final initialContent = stringContent.content;
    final initialBaseContentHash = initData.baseContentHash;
    String? cachedContent;
    String? initialLanguageId;

    if (initData.hotState is CodeEditorHotStateDto) {
      final hotState = initData.hotState as CodeEditorHotStateDto;
      cachedContent = hotState.content;
      initialLanguageId = hotState.languageId;
    } 

    return CodeEditorTab(
      plugin: this,
      initialContent: initialContent,
      cachedContent: cachedContent,
      initialLanguageId: initialLanguageId,
      initialBaseContentHash: initialBaseContentHash,
      id: id,
      onReadyCompleter: onReadyCompleter,
    );
  }

  @override
  EditorWidget buildEditor(EditorTab tab, WidgetRef ref) {
    final codeTab = tab as CodeEditorTab;

    return CodeEditorMachine(key: codeTab.editorKey, tab: codeTab);
  }

  CodeEditorMachineState? _getActiveEditorState(WidgetRef ref) {
    final tab = ref.watch(
      appNotifierProvider.select(
        (s) => s.value?.currentProject?.session.currentTab,
      ),
    );
    if (tab is! CodeEditorTab) return null;
    return tab.editorKey.currentState;
  }

  @override
  Widget buildToolbar(WidgetRef ref) {
    return CodeEditorTapRegion(child: const BottomToolbar());
  }

  @override
  List<Command> getAppCommands() => [
        BaseCommand(
          id: 'open_scratchpad',
          label: 'Open Scratchpad',
          icon: const Icon(Icons.edit_note),
          defaultPositions: [AppCommandPositions.appBar],
          sourcePlugin: 'App',
          canExecute: (ref) => true,
          execute: (ref) async {
            final settings = ref
                .read(effectiveSettingsProvider)
                .pluginSettings[CodeEditorSettings] as CodeEditorSettings?;

            final localPath = settings?.scratchpadLocalPath;

            if (localPath != null && localPath.trim().isNotEmpty) {
              // A local file path is configured, try to open it.
              final repo = ref.read(projectRepositoryProvider);
              if (repo == null) {
                MachineToast.error(
                    "A project must be open to use a local scratchpad file.");
                return;
              }

              try {
                // FileHandler works with URIs. Convert the file path to a URI string.
                // Uri.file() correctly handles platform-specific path formats.
                final fileUri = Uri.file(localPath.trim()).toString();
                final file = await repo.fileHandler.getFileMetadata(fileUri);

                if (file != null) {
                  await ref
                      .read(appNotifierProvider.notifier)
                      .openFileInEditor(file, explicitPlugin: this);
                } else {
                  MachineToast.error(
                      'Could not find local scratchpad file at: $localPath');
                }
              } catch (e) {
                MachineToast.error('Error opening local scratchpad file: $e');
                ref.read(talkerProvider).error(
                    'Error opening local scratchpad file at path "$localPath"',
                    e);
              }
            } else {
              // No local file, use the internal scratchpad.
              final filename =
                  settings?.scratchpadFilename ?? 'scratchpad.dart';

              final scratchpadFile = InternalAppFile(
                uri: 'internal:
                name: 'Scratchpad',
                modifiedDate: DateTime.now(),
              );

              await ref
                  .read(appNotifierProvider.notifier)
                  .openFileInEditor(scratchpadFile, explicitPlugin: this);
            }
          },
        ),
  ];

  @override
  List<Command> getCommands() => [
    BaseCommand(
      id: 'save',
      label: 'Save',
      icon: const Icon(Icons.save),
      defaultPositions: [AppCommandPositions.appBar],
      sourcePlugin: id,
      execute: (ref) async => ref.read(editorServiceProvider).saveCurrentTab(),
      canExecute: (ref) {
        final currentTabId = ref.watch(
          appNotifierProvider.select(
            (s) => s.value?.currentProject?.session.currentTab?.id,
          ),
        );
        if (currentTabId == null) return false;

        final metadata = ref.watch(
          tabMetadataProvider.select((m) => m[currentTabId]),
        );
        if (metadata == null) return false;

        // THE FIX: The command can only execute if the tab is dirty AND it's not a virtual file.
        return metadata.isDirty && metadata.file is! VirtualDocumentFile;
      },
    ),
    _createCommand(
      id: 'goto_line',
      label: 'Go to Line',
      icon: Icons.numbers,
      defaultPositions: [AppCommandPositions.pluginToolbar],
      execute:
          (ref, editor) =>
              editor?.showGoToLineDialog(),
    ),
    _createCommand(
      id: 'select_line',
      label: 'Select Line',
      icon:
          Icons.horizontal_rule,
      defaultPositions: [AppCommandPositions.pluginToolbar],
      execute:
          (ref, editor) =>
              editor?.selectOrExpandLines(),
    ),
    _createCommand(
      id: 'select_chunk',
      label: 'Select Chunk/Block',
      icon: Icons.unfold_more,
      defaultPositions: [AppCommandPositions.pluginToolbar],
      execute:
          (ref, editor) => editor?.selectCurrentChunk(),
    ),
    _createCommand(
      id: 'extend_selection',
      label: 'Extend Selection',
      icon: Icons.code,
      defaultPositions: [AppCommandPositions.pluginToolbar],
      execute:
          (ref, editor) => editor?.extendSelection(),
      canExecute: (ref, editor) => editor != null,
    ),
    _createCommand(
      id: 'find',
      label: 'Find',
      icon: Icons.search,
      defaultPositions: [AppCommandPositions.pluginToolbar, selectionToolbar],
      execute:
          (ref, editor) => editor?.showFindPanel(),
      canExecute: (ref, editor) => editor != null,
    ),
    _createCommand(
      id: 'find_and_replace',
      label: 'Replace',
      icon: Icons.find_replace,
      defaultPositions: [AppCommandPositions.pluginToolbar, selectionToolbar],
      execute:
          (ref, editor) => editor?.showReplacePanel(),
      canExecute: (ref, editor) => editor != null,
    ),
    _createCommand(
      id: 'set_mark',
      label: 'Set Mark',
      icon: Icons.bookmark_add,
      defaultPositions: [AppCommandPositions.pluginToolbar],
      execute: (ref, editor) => editor?.setMark(),
    ),
    BaseCommand(
      id: 'select_to_mark',
      label: 'Select to Mark',
      icon: const Icon(Icons.bookmark_added),
      defaultPositions: [AppCommandPositions.pluginToolbar],
      sourcePlugin: id,
      execute: (ref) async => _getActiveEditorState(ref)?.selectToMark(),
      canExecute: (ref) {
        final context = ref.watch(activeCommandContextProvider);
        return (context is CodeEditorCommandContext) && context.hasMark;
      },
    ),
    _createCommand(
      id: 'copy',
      label: 'Copy',
      icon: Icons.content_copy,
      defaultPositions: [AppCommandPositions.pluginToolbar, selectionToolbar],
      execute: (ref, editor) => editor?.controller.copy(),
    ),
    _createCommand(
      id: 'cut',
      label: 'Cut',
      icon: Icons.content_cut,
      defaultPositions: [AppCommandPositions.pluginToolbar, selectionToolbar],
      execute: (ref, editor) => editor?.controller.cut(),
    ),
    _createCommand(
      id: 'paste',
      label: 'Paste',
      icon: Icons.content_paste,
      defaultPositions: [AppCommandPositions.pluginToolbar, selectionToolbar],
      execute: (ref, editor) => editor?.controller.paste(),
    ),
    _createCommand(
      id: 'indent',
      label: 'Indent',
      icon: Icons.format_indent_increase,
      defaultPositions: [AppCommandPositions.pluginToolbar],
      execute: (ref, editor) {editor?.adjustSelectionIfNeeded(); editor?.controller.applyIndent(true);},
    ),
    _createCommand(
      id: 'outdent',
      label: 'Outdent',
      icon: Icons.format_indent_decrease,
      defaultPositions: [AppCommandPositions.pluginToolbar],
      execute: (ref, editor) {editor?.adjustSelectionIfNeeded(); editor?.controller.applyOutdent();},
    ),
    _createCommand(
      id: 'toggle_comment',
      label: 'Toggle Comment',
      icon: Icons.comment,
      defaultPositions: [AppCommandPositions.pluginToolbar, selectionToolbar],
      execute: (ref, editor) => editor?.toggleComments(),
    ),
    _createCommand(
      id: 'delete_comment_text',
      label: 'Delete Comment Text',
      icon: Icons.delete_sweep_outlined,
      defaultPositions: [AppCommandPositions.pluginToolbar, selectionToolbar],
      execute: (ref, editor) => editor?.deleteCommentText(),
    ),
    _createCommand(
      id: 'select_all',
      label: 'Select All',
      icon: Icons.select_all,
      defaultPositions: [AppCommandPositions.pluginToolbar],
      execute: (ref, editor) => editor?.controller.selectAll(),
    ),
    _createCommand(
      id: 'move_line_up',
      label: 'Move Line Up',
      icon: Icons.arrow_upward,
      defaultPositions: [AppCommandPositions.pluginToolbar],
      execute: (ref, editor) {editor?.adjustSelectionIfNeeded(); editor?.controller.moveSelectionLinesUp();},
    ),
    _createCommand(
      id: 'move_line_down',
      label: 'Move Line Down',
      icon: Icons.arrow_downward,
      defaultPositions: [AppCommandPositions.pluginToolbar],
      execute: (ref, editor) {editor?.adjustSelectionIfNeeded(); editor?.controller.moveSelectionLinesDown();},
    ),
    BaseCommand(
      id: 'undo',
      label: 'Undo',
      icon: const Icon(Icons.undo),
      defaultPositions: [AppCommandPositions.pluginToolbar],
      sourcePlugin: id,
      execute: (ref) async => _getActiveEditorState(ref)?.undo(),
      canExecute: (ref) {
        final context = ref.watch(activeCommandContextProvider);
        return (context is CodeEditorCommandContext) && context.canUndo;
      },
    ),
    BaseCommand(
      id: 'redo',
      label: 'Redo',
      icon: const Icon(Icons.redo),
      defaultPositions: [AppCommandPositions.pluginToolbar],
      sourcePlugin: id,
      execute: (ref) async => _getActiveEditorState(ref)?.redo(),
      canExecute: (ref) {
        final context = ref.watch(activeCommandContextProvider);
        return (context is CodeEditorCommandContext) && context.canRedo;
      },
    ),
    _createCommand(
      id: 'show_cursor',
      label: 'Show Cursor',
      icon: Icons.center_focus_strong,
      defaultPositions: [AppCommandPositions.pluginToolbar],
      execute: (ref, editor) => editor?.controller.makeCursorVisible(),
    ),
    _createCommand(
      id: 'switch_language',
      label: 'Switch Language',
      icon: Icons.language,
      defaultPositions: [AppCommandPositions.pluginToolbar],
      execute: (ref, editor) => editor?.showLanguageSelectionDialog(),
      canExecute: (ref, editor) => editor != null,
    ),
  ];

  Command _createCommand({
    required String id,
    required String label,
    required IconData icon,
    required List<CommandPosition> defaultPositions,
    required FutureOr<void> Function(WidgetRef, CodeEditorMachineState?)
    execute,
    bool Function(WidgetRef, CodeEditorMachineState?)? canExecute,
  }) {
    return BaseCommand(
      id: id,
      label: label,
      icon: Icon(icon, size: 20),
      defaultPositions: defaultPositions,
      sourcePlugin: this.id,
      execute: (ref) async {
        final editorState = _getActiveEditorState(ref);
        await execute(ref, editorState);
      },
      canExecute: (ref) {
        final editorState = _getActiveEditorState(ref);
        return canExecute?.call(ref, editorState) ?? (editorState != null);
      },
    );
  }
}

// FILE: lib/editor/plugins/code_editor/code_editor_settings_widget.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../settings/settings_notifier.dart';
import '../../../utils/code_themes.dart';
import '../../../widgets/dialogs/folder_picker_dialog.dart';
import 'code_editor_models.dart';
import '../../../app/app_notifier.dart';

class CodeEditorSettingsUI extends ConsumerStatefulWidget {
  final CodeEditorSettings settings;
  final void Function(CodeEditorSettings) onChanged;

  const CodeEditorSettingsUI({
    super.key,
    required this.settings,
    required this.onChanged,
  });

  @override
  ConsumerState<CodeEditorSettingsUI> createState() =>
      _CodeEditorSettingsUIState();
}

class _CodeEditorSettingsUIState extends ConsumerState<CodeEditorSettingsUI> {
  late final TextEditingController _filenameController;
  late final TextEditingController _localPathController;

  @override
  void initState() {
    super.initState();
    _filenameController =
        TextEditingController(text: widget.settings.scratchpadFilename);
    _localPathController =
        TextEditingController(text: widget.settings.scratchpadLocalPath ?? '');
  }

  @override
  void didUpdateWidget(covariant CodeEditorSettingsUI oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.settings.scratchpadFilename != _filenameController.text) {
      _filenameController.text = widget.settings.scratchpadFilename;
    }
    final newPath = widget.settings.scratchpadLocalPath ?? '';
    if (newPath != _localPathController.text) {
      _localPathController.text = newPath;
    }
  }

  @override
  void dispose() {
    _filenameController.dispose();
    _localPathController.dispose();
    super.dispose();
  }

  Future<void> _pickLocalFile() async {
    final project = ref.read(appNotifierProvider).value?.currentProject;
    if (project == null) {
      return;
    }

    // Show the dialog and wait for the user to select a file/folder
    final String? relativePath = await showDialog<String>(
      context: context,
      builder: (ctx) => const FileOrFolderPickerDialog(),
    );

    if (relativePath != null && mounted) {
      final fullUri = Uri.parse(project.rootUri).resolve(relativePath);
      final fullPath = fullUri.toFilePath();

      _localPathController.text = fullPath;
      widget.onChanged(
        widget.settings.copyWith(scratchpadLocalPath: fullPath),
      );
      setState(() {});
    }
  }

  void _clearLocalFile() {
    _localPathController.clear();
    widget.onChanged(
      widget.settings.copyWith(setScratchpadLocalPathToNull: true),
    );
    setState(() {});
  }

  @override
  Widget build(BuildContext context) {
    final currentSettings = widget.settings;
    final double currentFontHeightValue = currentSettings.fontHeight ?? 0.9;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        SwitchListTile(
          title: const Text('Word Wrap'),
          value: currentSettings.wordWrap,
          onChanged: (value) =>
              widget.onChanged(currentSettings.copyWith(wordWrap: value)),
        ),
        const Divider(),

        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
          child: Text(
            "Font & Display",
            style: Theme.of(context).textTheme.titleSmall,
          ),
        ),
        SwitchListTile(
          title: const Text('Enable Font Ligatures'),
          subtitle: const Text(
            'Displays special characters like "=>" as a single symbol',
          ),
          value: currentSettings.fontLigatures,
          onChanged: (value) =>
              widget.onChanged(currentSettings.copyWith(fontLigatures: value)),
        ),

        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0),
          child: DropdownButtonFormField<String>(
            decoration: const InputDecoration(labelText: 'Font Family'),
            value: currentSettings.fontFamily,
            items: const [
              DropdownMenuItem(value: 'FiraCode', child: Text('Fira Code')),
              DropdownMenuItem(
                value: 'JetBrainsMono',
                child: Text('JetBrains Mono'),
              ),
              DropdownMenuItem(value: 'RobotoMono', child: Text('Roboto Mono')),
            ],
            onChanged: (value) =>
                widget.onChanged(currentSettings.copyWith(fontFamily: value)),
          ),
        ),
        const SizedBox(height: 16),

        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0),
          child: Text('Font Size: ${currentSettings.fontSize.round()}'),
        ),
        Slider(
          value: currentSettings.fontSize,
          min: 8,
          max: 24,
          divisions: 16,
          label: currentSettings.fontSize.round().toString(),
          onChanged: (value) =>
              widget.onChanged(currentSettings.copyWith(fontSize: value)),
        ),

        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0),
          child: Text(
            'Line Height: ${currentFontHeightValue < 1.0 ? "Default" : currentFontHeightValue.toStringAsFixed(2)}',
          ),
        ),
        Slider(
          value: currentFontHeightValue,
          min: 0.9,
          max: 2.0,
          divisions: 11,
          label: currentFontHeightValue < 1.0
              ? "Default"
              : currentFontHeightValue.toStringAsFixed(2),
          onChanged: (value) {
            if (value < 1.0) {
              widget.onChanged(
                currentSettings.copyWith(setFontHeightToNull: true),
              );
            } else {
              widget.onChanged(currentSettings.copyWith(fontHeight: value));
            }
          },
        ),
        const Divider(),

        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0),
          child: DropdownButtonFormField<String>(
            decoration: const InputDecoration(labelText: 'Editor Theme'),
            value: currentSettings.themeName,
            items: CodeThemes.availableCodeThemes.keys.map((themeName) {
              return DropdownMenuItem(
                value: themeName,
                child: Text(themeName),
              );
            }).toList(),
            onChanged: (value) {
              if (value != null) {
                widget.onChanged(currentSettings.copyWith(themeName: value));
              }
            },
          ),
        ),
        const Divider(),

        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
          child: Text(
            "Scratchpad",
            style: Theme.of(context).textTheme.titleSmall,
          ),
        ),
        Padding(
          padding: const EdgeInsets.fromLTRB(16.0, 8.0, 16.0, 0),
          child: TextFormField(
            controller: _filenameController,
            decoration: const InputDecoration(
              labelText: 'Scratchpad Filename',
              hintText: 'e.g., scratchpad.dart, notes.md',
            ),
            onChanged: (value) {
              widget.onChanged(
                currentSettings.copyWith(scratchpadFilename: value),
              );
            },
          ),
        ),
        Padding(
          padding: const EdgeInsets.fromLTRB(16.0, 16.0, 16.0, 8.0),
          child: TextFormField(
            controller: _localPathController,
            decoration: InputDecoration(
              labelText: 'Local Scratchpad File (Optional)',
              hintText: 'Overrides internal scratchpad if set',
              helperText: 'Select a local file to use as the scratchpad',
              suffixIcon: _localPathController.text.trim().isEmpty
                  ? IconButton(
                      icon: const Icon(Icons.folder_open),
                      tooltip: 'Pick Local File',
                      onPressed: _pickLocalFile,
                    )
                  : IconButton(
                      icon: const Icon(Icons.close),
                      tooltip: 'Clear Path',
                      onPressed: _clearLocalFile,
                    ),
            ),
            onChanged: (value) {
              final trimmedValue = value.trim();
              if (trimmedValue.isEmpty) {
                widget.onChanged(
                  currentSettings.copyWith(setScratchpadLocalPathToNull: true),
                );
              } else {
                widget.onChanged(
                  currentSettings.copyWith(scratchpadLocalPath: trimmedValue),
                );
              }
              setState(() {});
            },
          ),
        ),
      ],
    );
  }
}
// FILE: lib/editor/plugins/code_editor/code_editor_widgets.dart

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import 'package:re_editor/re_editor.dart';
import 'package:flex_color_picker/flex_color_picker.dart';

import '../../../app/app_notifier.dart';
import '../../../data/repositories/project/project_repository.dart';
import '../../../editor/services/editor_service.dart';
import '../../../settings/settings_notifier.dart';
import '../../../utils/toast.dart';
import '../../models/editor_tab_models.dart';
import '../../tab_metadata_notifier.dart';
import 'logic/code_editor_logic.dart';
import 'code_editor_models.dart';
import 'widgets/code_find_panel_view.dart';
import '../../../utils/code_themes.dart';
import 'widgets/goto_line_dialog.dart';
import '../../models/editor_command_context.dart';
import '../../models/text_editing_capability.dart';
import 'package:machine/editor/services/language/language_models.dart';
import 'package:machine/editor/services/language/language_registry.dart';
import 'code_editor_hot_state_dto.dart';
import 'widgets/code_editor_ui.dart';
import 'logic/code_editor_types.dart';
import 'logic/code_editor_utils.dart';
import '../../../project/project_settings_notifier.dart';

class CodeEditorMachine extends EditorWidget {
  @override
  final CodeEditorTab tab;

  const CodeEditorMachine({
    required GlobalKey<CodeEditorMachineState> key,
    required this.tab,
  }) : super(key: key, tab: tab);

  @override
  CodeEditorMachineState createState() => CodeEditorMachineState();
}

class CodeEditorMachineState extends EditorWidgetState<CodeEditorMachine>
    with TextEditable {
  late final CodeLineEditingController controller;
  late final FocusNode _focusNode;
  late final CodeFindController findController;
  CodeChunkController? _chunkController;
  CodeLinePosition? _markPosition;

  late final ValueNotifier<BracketHighlightState> _bracketHighlightNotifier;

  late LanguageConfig _languageConfig;
  late CodeCommentFormatter _commentFormatter;
  
  late CodeEditorStyle _style;

  late String? _baseContentHash;


  @override
  Future<TextSelectionDetails> getSelectionDetails() async {
    final CodeLineSelection currentSelection = controller.selection;

    TextRange? textRange;
    if (!currentSelection.isCollapsed) {
      textRange = TextRange(
        start: TextPosition(
          line: currentSelection.start.index,
          column: currentSelection.start.offset,
        ),
        end: TextPosition(
          line: currentSelection.end.index,
          column: currentSelection.end.offset,
        ),
      );
    }

    return TextSelectionDetails(
      range: textRange,
      content: controller.selectedText,
    );
  }

  @override
  void replaceSelection(String replacement, {TextRange? range}) {
    if (!mounted) return;

    CodeLineSelection? selectionToReplace;

    if (range != null) {
      selectionToReplace = CodeLineSelection(
        baseIndex: range.start.line,
        baseOffset: range.start.column,
        extentIndex: range.end.line,
        extentOffset: range.end.column,
      );
    }

    controller.runRevocableOp(() {
      controller.replaceSelection(replacement, selectionToReplace);
    });
  }

  @override
  Future<bool> isSelectionCollapsed() async {
    return controller.selection.isCollapsed;
  }

  @override
  Future<String> getSelectedText() async {
    return controller.selectedText;
  }

  @override
  void revealRange(TextRange range) {
    final startPosition = CodeLinePosition(
      index: range.start.line,
      offset: range.start.column,
    );
    controller.selection = CodeLineSelection(
      baseIndex: range.start.line,
      baseOffset: range.start.column,
      extentIndex: range.end.line,
      extentOffset: range.end.column,
    );

    controller.makePositionCenterIfInvisible(startPosition);
  }

  @override
  Future<String> getTextContent() async {
    return controller.text;
  }

  @override
  void insertTextAtLine(int lineNumber, String textToInsert) {
    if (!mounted) return;

    final line = lineNumber.clamp(0, controller.codeLines.length);

    final selectionToReplace = CodeLineSelection.fromPosition(
      position: CodeLinePosition(index: line, offset: 0),
    );

    controller.runRevocableOp(() {
      controller.replaceSelection(textToInsert, selectionToReplace);
    });
  }

  @override
  void replaceAllOccurrences(String find, String replace) {
    if (!mounted) return;
    controller.replaceAll(find, replace);
  }

  @override
  void replaceLines(int startLine, int endLine, String newContent) {
    if (!mounted) return;

    final start = startLine.clamp(0, controller.codeLines.length);
    final end = endLine.clamp(0, controller.codeLines.length - 1);

    if (start > end) return;

    final selectionToReplace = CodeLineSelection(
      baseIndex: start,
      baseOffset: 0,
      extentIndex: (end + 1).clamp(0, controller.codeLines.length),
      extentOffset: 0,
    );

    controller.runRevocableOp(() {
      controller.replaceSelection(newContent, selectionToReplace);
    });
  }

  @override
  void replaceAllPattern(Pattern pattern, String replacement) {
    if (!mounted) return;
    controller.replaceAll(pattern, replacement);
  }

  @override
  void batchReplaceRanges(List<ReplaceRangeEdit> edits) {
    edits.sort((a, b) {
      final startA = a.range.start;
      final startB = b.range.start;
      if (startB.line != startA.line) {
        return startB.line.compareTo(startA.line);
      }
      return startB.column.compareTo(startA.column);
    });

    for (final edit in edits) {
      replaceSelection(edit.replacement, range: edit.range);
    }
  }

  @override
  void undo() {
    if (controller.canUndo) controller.undo();
  }

  @override
  void redo() {
    if (controller.canRedo) controller.redo();
  }

  @override
  Future<EditorContent> getContent() async {
    return EditorContentString(controller.text);
  }

  @override
  void onSaveSuccess(String newHash) {
    if (!mounted) return;
    setState(() {
      _baseContentHash = newHash;
    });
    controller.markCurrentStateAsClean();
  }

  @override
  Future<TabHotStateDto?> serializeHotState() async {
    return CodeEditorHotStateDto(
      content: controller.text,
      languageId: _languageConfig.id,
      baseContentHash: _baseContentHash,
    );
  }

  @override
  void init() {
    _focusNode = FocusNode();
    _baseContentHash = widget.tab.initialBaseContentHash;
    _bracketHighlightNotifier = ValueNotifier(const BracketHighlightState());

    final fileUri = ref.read(tabMetadataProvider)[widget.tab.id]?.file.uri;
    if (fileUri == null) {
      throw StateError("Could not find metadata for tab ID: ${widget.tab.id}");
    }

    if (widget.tab.initialLanguageId != null) {
      _languageConfig = Languages.getById(widget.tab.initialLanguageId!);
    } else {
      _languageConfig = Languages.getForFile(fileUri);
    }
        
    _updateCommentFormatter();


    controller = CodeLineEditingController(
      codeLines: CodeLines.fromText(widget.tab.initialContent),
      spanBuilder: _buildHighlightingSpan,
    );
    findController = CodeFindController(controller);

    findController.addListener(syncCommandContext);
    controller.addListener(_onControllerChange);
    controller.dirty.addListener(_onDirtyStateChange);
  }

  @override
  void onFirstFrameReady() {
    if (mounted) {
      syncCommandContext();
      if (widget.tab.cachedContent != null) {
        controller.text = widget.tab.cachedContent!;
      }
      if (!widget.tab.onReady.isCompleted) {
        widget.tab.onReady.complete(this);
      }
    }
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _updateStyleAndRecognizers();
    _updateCommentFormatter();
  }

  @override
  void didUpdateWidget(covariant CodeEditorMachine oldWidget) {
    super.didUpdateWidget(oldWidget);
    final oldFileUri = ref.read(tabMetadataProvider)[oldWidget.tab.id]?.file.uri;
    final newFileUri = ref.read(tabMetadataProvider)[widget.tab.id]?.file.uri;

    if (newFileUri != null && newFileUri != oldFileUri) {
      setState(() {
        // Reload config on file rename/change
        _languageConfig = Languages.getForFile(newFileUri);
        _updateStyleAndRecognizers();
        _updateCommentFormatter();
      });
    }
  }

  @override
  void dispose() {
    _bracketHighlightNotifier.dispose();
    findController.removeListener(syncCommandContext);
    controller.removeListener(syncCommandContext);
    controller.dirty.removeListener(_onDirtyStateChange);
    controller.dispose();
    _focusNode.dispose();
    findController.dispose();
    super.dispose();
  }

  void _updateStyleAndRecognizers() {
    final codeEditorSettings = ref.read(
      effectiveSettingsProvider.select(
        (s) => s.pluginSettings[CodeEditorSettings] as CodeEditorSettings?,
      ),
    );

    final selectedThemeName = codeEditorSettings?.themeName ?? 'Atom One Dark';
    final bool enableLigatures = codeEditorSettings?.fontLigatures ?? true;
    final List<FontFeature>? fontFeatures =
        enableLigatures
            ? null
            : const [
              FontFeature.disable('liga'),
              FontFeature.disable('clig'),
              FontFeature.disable('calt'),
            ];

    final Map<String, CodeHighlightThemeMode> languageMap = {};
    if (_languageConfig.highlightMode != null) {
      languageMap[_languageConfig.id] = CodeHighlightThemeMode(
        mode: _languageConfig.highlightMode!
      );
    }

    _style = CodeEditorStyle(
      fontHeight: codeEditorSettings?.fontHeight,
      fontSize: codeEditorSettings?.fontSize ?? 12.0,
      fontFamily: codeEditorSettings?.fontFamily ?? 'JetBrainsMono',
      fontFeatures: fontFeatures,
      codeTheme: CodeHighlightTheme(
        theme: CodeThemes.availableCodeThemes[selectedThemeName] ??
            CodeThemes.availableCodeThemes['Atom One Dark']!,
        languages: languageMap,
      ),
    );
  }
  
  void _updateCommentFormatter() {
    if (_languageConfig.comments != null) {
      _commentFormatter = DefaultCodeCommentFormatter(
        singleLinePrefix: _languageConfig.comments!.singleLine,
        multiLinePrefix: _languageConfig.comments!.blockBegin,
        multiLineSuffix: _languageConfig.comments!.blockEnd,
      );
    } else {
      _commentFormatter = DefaultCodeCommentFormatter(singleLinePrefix: '');
    }
  }

  Widget _buildSelectionAppBar() {
    return const CodeEditorSelectionAppBar();
  }


  Future<void> showGoToLineDialog() async {
    if (!mounted) return;
    final int maxLines = controller.codeLines.length;
    final int currentLine = controller.selection.start.index;
    final int? targetLineIndex = await showDialog<int>(
      context: context,
      builder:
          (ctx) => GoToLineDialog(maxLine: maxLines, currentLine: currentLine),
    );
    if (targetLineIndex != null) {
      final CodeLinePosition targetPosition = CodeLinePosition(
        index: targetLineIndex,
        offset: 0,
      );
      controller.selection = CodeLineSelection.fromPosition(
        position: targetPosition,
      );
      controller.makePositionCenterIfInvisible(targetPosition);
    }
  }

void selectOrExpandLines() {
  final CodeLineSelection currentSelection = controller.selection;
  final List<CodeLine> lines = controller.codeLines.toList();
  final bool isAlreadyFullLineSelection =
      currentSelection.start.offset == 0 &&
      currentSelection.end.offset == 0 &&
      currentSelection.end.index > currentSelection.start.index;

  if (isAlreadyFullLineSelection) {
    if (currentSelection.end.index < lines.length - 1) {
      controller.selection = currentSelection.copyWith(
        extentIndex: currentSelection.end.index + 1,
        extentOffset: 0,
      );
    } else if (currentSelection.end.index == lines.length - 1) {
      controller.selection = currentSelection.copyWith(
        extentIndex: lines.length - 1,
        extentOffset: lines.last.length,
      );
    }
  } else {
    final newStartIndex = currentSelection.start.index;
    
    if (currentSelection.end.index == lines.length - 1) {
      controller.selection = CodeLineSelection(
        baseIndex: newStartIndex,
        baseOffset: 0,
        extentIndex: lines.length - 1,
        extentOffset: lines.last.length,
      );
    } else {
      final newEndIndex = currentSelection.end.index + 1;
      controller.selection = CodeLineSelection(
        baseIndex: newStartIndex,
        baseOffset: 0,
        extentIndex: newEndIndex,
        extentOffset: 0,
      );
    }
  }
  _onControllerChange();
}

  void selectCurrentChunk() {
    if (_chunkController == null) return;
    controller.selectChunk(_chunkController!.value);
    _onControllerChange();
  }

  void extendSelection() {
    final CodeLineSelection currentSelection = controller.selection;
    CodeLineSelection? newSelection;

    final enclosingBlock = CodeEditorUtils.findSmallestEnclosingBlock(
      currentSelection,
      controller,
    );

    if (enclosingBlock != null) {
      if (currentSelection == enclosingBlock.contents) {
        newSelection = enclosingBlock.full;
      } else {
        newSelection = enclosingBlock.contents;
      }
    }

    if (newSelection != null && newSelection != currentSelection) {
      controller.selection = newSelection;
      _onControllerChange();
    }
  }
  
  void adjustSelectionIfNeeded() {
    final CodeLineSelection currentSelection = controller.selection;
    final List<CodeLine> lines = controller.codeLines.toList();
    
    final bool isMultilineWithZeroEnd = 
        currentSelection.end.index > currentSelection.start.index &&
        currentSelection.end.offset == 0;
    
    if (isMultilineWithZeroEnd) {
      final previousLineIndex = currentSelection.end.index - 1;
      if (previousLineIndex >= 0) {
        final previousLine = lines[previousLineIndex];
        controller.selection = currentSelection.copyWith(
          extentIndex: previousLineIndex,
          extentOffset: previousLine.length,
        );
        _onControllerChange();
      }
    }
  }

  void showFindPanel() {
    findController.findMode();
  }

  void showReplacePanel() {
    findController.replaceMode();
  }

  void _onImportTap(String relativePath) async {
    final appNotifier = ref.read(appNotifierProvider.notifier);
    final fileHandler = ref.read(projectRepositoryProvider)?.fileHandler;
    final currentFileMetadata = ref.read(tabMetadataProvider)[widget.tab.id];

    if (fileHandler == null || currentFileMetadata == null) return;

    try {
      final currentDirectoryUri = fileHandler.getParentUri(
        currentFileMetadata.file.uri,
      );
      final pathSegments = [
        ...currentDirectoryUri.split('%2F'),
        ...relativePath.split('/'),
      ];
      final resolvedSegments = <String>[];

      for (final segment in pathSegments) {
        if (segment == '..') {
          if (resolvedSegments.isNotEmpty) {
            resolvedSegments.removeLast();
          }
        } else if (segment != '.' && segment.isNotEmpty) {
          resolvedSegments.add(segment);
        }
      }

      final resolvedUri = resolvedSegments.join('%2F');
      final targetFile = await fileHandler.getFileMetadata(resolvedUri);

      if (targetFile != null) {
        await appNotifier.openFileInEditor(targetFile);
      } else {
        MachineToast.error('File not found: $relativePath');
      }
    } catch (e) {
      MachineToast.error('Could not open file: $e');
    }
  }
  
  Future<void> _onColorCodeTap(int lineIndex, ColorMatch match) async {
    if (!mounted) return;

    Color pickerColor = match.color;

    final result = await showDialog<Color>(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Select Color'),
          content: SingleChildScrollView(
            child: ColorPicker(
              color: pickerColor,
              onColorChanged: (Color color) => pickerColor = color,
              width: 40,
              height: 40,
              spacing: 5,
              runSpacing: 5,
              borderRadius: 4,
              wheelDiameter: 165,
              enableOpacity: true,
              showColorCode: true,
              colorCodeHasColor: true,
              pickersEnabled: const <ColorPickerType, bool>{
                ColorPickerType.both: false,
                ColorPickerType.primary: true,
                ColorPickerType.accent: true,
                ColorPickerType.bw: false,
                ColorPickerType.custom: true,
                ColorPickerType.wheel: true,
              },
            ),
          ),
          actions: <Widget>[
            TextButton(
              child: const Text('Cancel'),
              onPressed: () => Navigator.of(context).pop(),
            ),
            FilledButton(
              child: const Text('OK'),
              onPressed: () => Navigator.of(context).pop(pickerColor),
            ),
          ],
        );
      },
    );

    if (result != null && result != match.color) {
      String newColorString;
      final String originalText = match.text;

      if (originalText.startsWith('#')) {
        if (originalText.length == 7 || originalText.length == 4) {
            newColorString = '#${(result.value & 0xFFFFFF).toRadixString(16).padLeft(6, '0').toUpperCase()}';
        } else {
            newColorString = '#${result.value.toRadixString(16).padLeft(8, '0').toUpperCase()}';
        }
      } else if (originalText.startsWith('Color.fromARGB')) {
          newColorString = 'Color.fromARGB(${result.alpha}, ${result.red}, ${result.green}, ${result.blue})';
      } else if (originalText.startsWith('Color.fromRGBO')) {
          String opacity = (result.alpha / 255.0).toStringAsPrecision(2);
          if (opacity.endsWith('.0')) opacity = opacity.substring(0, opacity.length - 2);
          newColorString = 'Color.fromRGBO(${result.red}, ${result.green}, ${result.blue}, $opacity)';
      } else if (originalText.startsWith('Color(')) {
          newColorString = 'Color(0x${result.value.toRadixString(16).toUpperCase()})';
      } else {
          newColorString = '#${result.value.toRadixString(16).padLeft(8, '0').toUpperCase()}';
      }

      final rangeToReplace = TextRange(
        start: TextPosition(line: lineIndex, column: match.start),
        end: TextPosition(line: lineIndex, column: match.end),
      );

      replaceSelection(newColorString, range: rangeToReplace);
    }
  }

  void _onDirtyStateChange() {
    if (!mounted) return;
    final editorService = ref.read(editorServiceProvider);
    if (controller.dirty.value) {
      editorService.markCurrentTabDirty();
    } else {
      editorService.markCurrentTabClean();
    }
  }

  void _onControllerChange() {
    if (!mounted) return;

    _bracketHighlightNotifier
        .value = CodeEditorUtils.calculateBracketHighlights(controller);

    syncCommandContext();

    if (controller.dirty.value) {
      final project = ref.read(appNotifierProvider).value?.currentProject;
      if (project != null) {
        ref
            .read(editorServiceProvider)
            .updateAndCacheDirtyTab(project, widget.tab);
      }
    }
  }

  Map<String, dynamic> getHotState() {
    return {
      'content': controller.text,
      'languageId': _languageConfig.id,
      'baseContentHash': _baseContentHash,
    };
  }

  @override
  void syncCommandContext() {
    if (!mounted) return;

    final hasSelection = !controller.selection.isCollapsed;
    Widget? appBarOverride;
    Key? appBarOverrideKey;

    if (findController.value != null) {
      appBarOverride = CodeFindAppBar(controller: findController);
      appBarOverrideKey = ValueKey('findController_toolbar');
    } else if (hasSelection) {
      appBarOverride = _buildSelectionAppBar();
      appBarOverrideKey = const ValueKey('selection_toolbar_active');
    }

    final newContext = CodeEditorCommandContext(
      canUndo: controller.canUndo,
      canRedo: controller.canRedo,
      hasSelection: hasSelection,
      hasMark: _markPosition != null,
      appBarOverride: appBarOverride,
      appBarOverrideKey: appBarOverrideKey,
    );

    ref.read(commandContextProvider(widget.tab.id).notifier).state = newContext;
  }

  void setMark() {
    setState(() {
      _markPosition = controller.selection.base;
    });
    syncCommandContext();
  }

  void selectToMark() {
    if (_markPosition == null) return;
    final currentPosition = controller.selection.base;
    final start =
        CodeEditorUtils.comparePositions(_markPosition!, currentPosition) < 0
            ? _markPosition!
            : currentPosition;
    final end =
        CodeEditorUtils.comparePositions(_markPosition!, currentPosition) < 0
            ? currentPosition
            : _markPosition!;
    controller.selection = CodeLineSelection(
      baseIndex: start.index,
      baseOffset: start.offset,
      extentIndex: end.index,
      extentOffset: end.offset,
    );
  }

  void toggleComments() {
    adjustSelectionIfNeeded();
    final formatted = _commentFormatter.format(
      controller.value,
      controller.options.indent,
      true,
    );
    controller.runRevocableOp(() => controller.value = formatted);
  }
  
  void deleteCommentText() {
    adjustSelectionIfNeeded();
    final selection = controller.selection;
    final singleLinePrefix = _languageConfig.comments?.singleLine;

    if (singleLinePrefix == null || singleLinePrefix.isEmpty) {
      return;
    }

    final startLine = selection.start.index;
    final endLine = selection.end.index;

    final List<String> newLines = [];
    for (int i = startLine; i <= endLine; i++) {
      final line = controller.codeLines[i].text;
      final commentIndex = line.indexOf(singleLinePrefix);

      if (commentIndex != -1) {
        final contentBeforeComment = line.substring(0, commentIndex);
        if (contentBeforeComment.trim().isNotEmpty) {
          newLines.add(contentBeforeComment.trimRight());
        }
      } else {
        newLines.add(line.trimRight());
      }
    }

    final selectionToReplace = CodeLineSelection(
      baseIndex: startLine,
      baseOffset: 0,
      extentIndex: endLine,
      extentOffset: controller.codeLines[endLine].length,
    );

    controller.runRevocableOp(() {
      controller.replaceSelection(newLines.join('\n'), selectionToReplace);
    });
  }

  Future<void> showLanguageSelectionDialog() async {
    final allLanguages = Languages.all;
    
    final selectedLanguageId = await showDialog<String>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Select Language'),
        content: SizedBox(
          width: double.maxFinite,
          child: ListView.builder(
            shrinkWrap: true,
            itemCount: allLanguages.length,
            itemBuilder: (context, index) {
              final lang = allLanguages[index];
              return ListTile(
                title: Text(lang.name),
                selected: lang.id == _languageConfig.id,
                onTap: () => Navigator.pop(ctx, lang.id),
              );
            },
          ),
        ),
      ),
    );

    if (selectedLanguageId != null && selectedLanguageId != _languageConfig.id) {
      setState(() {
        _languageConfig = Languages.getById(selectedLanguageId);
        _updateStyleAndRecognizers();
        _updateCommentFormatter();
      });
      ref.read(editorServiceProvider).markCurrentTabDirty();
    }
  }

  TextSpan _buildHighlightingSpan({
    required BuildContext context,
    required int index,
    required CodeLine codeLine,
    required TextSpan textSpan,
    required TextStyle style,
  }) {
    return CodeEditorUtils.buildHighlightingSpan(
      context: context,
      index: index,
      codeLine: codeLine,
      textSpan: textSpan,
      style: style,
      bracketHighlightState: _bracketHighlightNotifier.value,
      onImportTap: _onImportTap,
      onColorCodeTap: _onColorCodeTap,
      languageConfig: _languageConfig,
    );
  }

  KeyEventResult _handleKeyEvent(FocusNode node, KeyEvent event) {
    if (!_focusNode.hasPrimaryFocus) return KeyEventResult.ignored;
    if (event is! KeyDownEvent) return KeyEventResult.ignored;

    final arrowKeyDirections = {
      LogicalKeyboardKey.arrowUp: AxisDirection.up,
      LogicalKeyboardKey.arrowDown: AxisDirection.down,
      LogicalKeyboardKey.arrowLeft: AxisDirection.left,
      LogicalKeyboardKey.arrowRight: AxisDirection.right,
    };
    final direction = arrowKeyDirections[event.logicalKey];
    final shiftPressed = HardwareKeyboard.instance.isShiftPressed;

    if (direction != null) {
      if (shiftPressed) {
        controller.extendSelection(direction);
      } else {
        controller.moveCursor(direction);
      }
      return KeyEventResult.handled;
    }
    return KeyEventResult.ignored;
  }

  @override
  Widget build(BuildContext context) {
    ref.listen(tabMetadataProvider.select((m) => m[widget.tab.id]?.file.uri), (
      previous,
      next,
    ) {
      if (previous != next && next != null) {
        setState(() {
          final newLanguageConfig = Languages.getForFile(next);
          if (newLanguageConfig.id != _languageConfig.id) {
            _languageConfig = newLanguageConfig;
            _updateStyleAndRecognizers();
          }
          _updateCommentFormatter();
        });
      }
    });

    final colorScheme = Theme.of(context).colorScheme;

    return Focus(
      onKeyEvent: _handleKeyEvent,
      autofocus: true,
      child: CodeEditor(
        controller: controller,
        focusNode: _focusNode,
        findController: findController,
        findBuilder: (context, controller, readOnly) {
          return CodeFindPanelView(
            controller: controller,
            iconSelectedColor: colorScheme.primary,
            iconColor: colorScheme.onSurface.withValues(alpha: 0.6),
            readOnly: readOnly,
          );
        },
        commentFormatter: _commentFormatter,
        verticalScrollbarWidth: 16.0,
        scrollbarBuilder: (context, child, details) {
          return GrabbableScrollbar(
            details: details,
            thickness: 16.0,
            child: child,
          );
        },
        indicatorBuilder: (
          context,
          editingController,
          chunkController,
          notifier,
        ) {
          _chunkController = chunkController;
          return CustomEditorIndicator(
            controller: editingController,
            chunkController: chunkController,
            notifier: notifier,
            bracketHighlightNotifier: _bracketHighlightNotifier,
          );
        },
        sperator: Container(
          width: 2,
          color: colorScheme.surfaceContainerHighest,
        ),
        style: _style,
        wordWrap: ref.watch(
          effectiveSettingsProvider.select(
            (s) =>
                (s.pluginSettings[CodeEditorSettings] as CodeEditorSettings?)
                    ?.wordWrap ??
                false,
          ),
        ),
      ),
    );
  }
}
// FILE: lib/editor/plugins/code_editor/logic/code_editor_logic.dart


import 'package:re_editor/re_editor.dart';


class CodeEditorLogic {
  static CodeCommentFormatter getCommentFormatter(String uri) {
    final extension = uri.split('.').last.toLowerCase();
    switch (extension) {
      case 'dart':
        return DefaultCodeCommentFormatter(
          singleLinePrefix: '
          multiLinePrefix: '/*',
          multiLineSuffix: '*/',
        );
      case 'tex':
        return DefaultCodeCommentFormatter(singleLinePrefix: '%');
      default:
        return DefaultCodeCommentFormatter(
          singleLinePrefix: '
          multiLinePrefix: '/*',
          multiLineSuffix: '*/',
        );
    }
  }
}

// FILE: lib/editor/plugins/code_editor/logic/code_editor_types.dart

import 'package:re_editor/re_editor.dart';
import 'package:flutter/material.dart';

class ColorMatch {
  final int start;
  final int end;
  final Color color;
  final String text;

  ColorMatch({
    required this.start,
    required this.end,
    required this.color,
    required this.text,
  });
}

class BracketHighlightState {
  final Set<CodeLinePosition> bracketPositions;
  final Set<int> highlightedLines;
  const BracketHighlightState({
    this.bracketPositions = const {},
    this.highlightedLines = const {},
  });
}

// FILE: lib/editor/plugins/code_editor/logic/code_editor_utils.dart


import 'dart:math';

import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:re_editor/re_editor.dart';

import '../../../services/language/language_models.dart';
import 'code_editor_types.dart';

class CodeEditorUtils {

  static BracketHighlightState calculateBracketHighlights(
    CodeLineEditingController controller,
  ) {
    final selection = controller.selection;
    if (!selection.isCollapsed) {
      return const BracketHighlightState();
    }
    final position = selection.base;
    final brackets = {'(': ')', '[': ']', '{': '}'};
    final line = controller.codeLines[position.index].text;
    Set<CodeLinePosition> newPositions = {};
    Set<int> newHighlightedLines = {};
    for (int offset in [position.offset, position.offset - 1]) {
      if (offset >= 0 && offset < line.length) {
        final char = line[offset];
        if (brackets.keys.contains(char) || brackets.values.contains(char)) {
          final currentPosition = CodeLinePosition(
            index: position.index,
            offset: offset,
          );
          final matchPosition = _findMatchingBracket(
            controller.codeLines,
            currentPosition,
            brackets,
          );
          if (matchPosition != null) {
            newPositions.add(currentPosition);
            newPositions.add(matchPosition);
            newHighlightedLines.add(currentPosition.index);
            newHighlightedLines.add(matchPosition.index);
            break;
          }
        }
      }
    }
    return BracketHighlightState(
      bracketPositions: newPositions,
      highlightedLines: newHighlightedLines,
    );
  }

  static CodeLinePosition? _findMatchingBracket(
    CodeLines codeLines,
    CodeLinePosition position,
    Map<String, String> brackets,
  ) {
    final line = codeLines[position.index].text;
    final char = line[position.offset];
    final isOpen = brackets.keys.contains(char);
    final target =
        isOpen
            ? brackets[char]
            : brackets.keys.firstWhere(
              (k) => brackets[k] == char,
              orElse: () => '',
            );
    if (target?.isEmpty ?? true) return null;

    int stack = 1;
    int index = position.index;
    int offset = position.offset;
    final direction = isOpen ? 1 : -1;

    while (true) {
      offset += direction;

      while (offset < 0 || offset >= codeLines[index].text.length) {
        if (direction > 0) {
          index++;
          if (index >= codeLines.length) return null;
          offset = 0;
        } else {
          index--;
          if (index < 0) return null;
          offset = codeLines[index].text.length - 1;
        }
      }

      final currentChar = codeLines[index].text[offset];

      if (currentChar == char) {
        stack++;
      } else if (currentChar == target) {
        stack--;
      }

      if (stack == 0) {
        return CodeLinePosition(index: index, offset: offset);
      }
    }
  }


  static TextSpan buildHighlightingSpan({
    required BuildContext context,
    required int index,
    required CodeLine codeLine,
    required TextSpan textSpan,
    required TextStyle style,
    required BracketHighlightState bracketHighlightState,
    required void Function(String) onImportTap,
    void Function(int lineIndex, ColorMatch match)? onColorCodeTap,
    required LanguageConfig languageConfig,
  }) {
    final linkedSpan = _linkifyImportPaths(
      codeLine,
      textSpan,
      style,
      onImportTap,
      languageConfig,
    );
    final rainbowSpan = _highlightColorCodes(
      codeLine,
      linkedSpan,
      style,
      onColorCodeTap != null ? (match) => onColorCodeTap(index, match) : null,
    );
    final finalSpan = _highlightBrackets(
      index,
      rainbowSpan,
      style,
      bracketHighlightState,
    );

    return finalSpan;
  }

  static TextSpan _linkifyImportPaths(
    CodeLine codeLine,
    TextSpan textSpan,
    TextStyle style,
    void Function(String) onImportTap,
    LanguageConfig config,
  ) {
    final text = codeLine.text;
    if (!(text.startsWith('import') ||
        text.startsWith('export') ||
        text.startsWith('part'))) {
      return textSpan;
    }
    if (text.contains(':')) return textSpan;
    int quote1Index = text.indexOf("'");
    String quoteChar = "'";
    if (quote1Index == -1) {
      quote1Index = text.indexOf('"');
      quoteChar = '"';
    }
    if (quote1Index == -1) return textSpan;
    final quote2Index = text.indexOf(quoteChar, quote1Index + 1);
    if (quote2Index == -1) return textSpan;
    final pathStartIndex = quote1Index + 1;
    final pathEndIndex = quote2Index;
    if (pathStartIndex >= pathEndIndex) return textSpan;

    List<TextSpan> walkAndReplace(TextSpan span, int currentPos) {
      final List<TextSpan> newChildren = [];
      final spanStart = currentPos;
      final spanText = span.text ?? '';
      final spanEnd = spanStart + spanText.length;

      if (span.children?.isNotEmpty ?? false) {
        int childPos = currentPos;
        for (final child in span.children!) {
          if (child is TextSpan) {
            newChildren.addAll(walkAndReplace(child, childPos));
            childPos += child.toPlainText().length;
          }
        }
        return [
          TextSpan(
            style: span.style,
            children: newChildren,
            recognizer: span.recognizer,
          ),
        ];
      }

      if (spanEnd <= pathStartIndex || spanStart >= pathEndIndex) {
        return [span];
      }

      final beforeText = spanText.substring(
        0,
        (pathStartIndex - spanStart).clamp(0, spanText.length),
      );
      final linkText = spanText.substring(
        (pathStartIndex - spanStart).clamp(0, spanText.length),
        (pathEndIndex - spanStart).clamp(0, spanText.length),
      );
      final afterText = spanText.substring(
        (pathEndIndex - spanStart).clamp(0, spanText.length),
      );

      if (beforeText.isNotEmpty) {
        newChildren.add(TextSpan(text: beforeText, style: span.style));
      }
      if (linkText.isNotEmpty) {
        newChildren.add(
          TextSpan(
            text: linkText,
            style: (span.style ?? style).copyWith(
              decoration: TextDecoration.underline,
            ),
            recognizer:
                TapGestureRecognizer()..onTap = () => onImportTap(linkText),
          ),
        );
      }
      if (afterText.isNotEmpty) {
        newChildren.add(TextSpan(text: afterText, style: span.style));
      }

      return newChildren;
    }

    return TextSpan(children: walkAndReplace(textSpan, 0), style: style);
  }

  static TextSpan _highlightColorCodes(
    CodeLine codeLine,
    TextSpan textSpan,
    TextStyle style,
    void Function(ColorMatch match)? onColorCodeTap,
  ) {
    final text = codeLine.text;
    final List<ColorMatch> matches = [];

    final hexColorRegex = RegExp(r'(?<!\w)#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6})\b');
    final shortHexColorRegex = RegExp(r'(?<!\w)#([A-Fa-f0-9]{3,4})\b');
    final colorConstructorRegex = RegExp(
      r'Color\(\s*(0x[A-Fa-f0-9]{1,8})\s*\)',
    );
    final fromARGBRegex = RegExp(
      r'Color\.fromARGB\(\s*([^,]+?)\s*,\s*([^,]+?)\s*,\s*([^,]+?)\s*,\s*([^,]+?)\s*\)',
    );
    final fromRGBORegex = RegExp(
      r'Color\.fromRGBO\(\s*([^,]+?)\s*,\s*([^,]+?)\s*,\s*([^,]+?)\s*,\s*([^,]+?)\s*\)',
    );

    hexColorRegex.allMatches(text).forEach((m) {
      final hex = m.group(1);
      if (hex != null) {
        final val = int.tryParse(hex, radix: 16);
        if (val != null) {
          final color = hex.length == 8 ? Color(val) : Color(0xFF000000 | val);
          matches.add(ColorMatch(start: m.start, end: m.end, color: color, text: m.group(0)!));
        }
      }
    });
    shortHexColorRegex.allMatches(text).forEach((m) {
      String hex = m.group(1)!;
      hex =
          hex.length == 3
              ? hex.split('').map((e) => e + e).join()
              : hex[0] +
                  hex[0] +
                  hex.substring(1).split('').map((e) => e + e).join();
      final val = int.tryParse(hex, radix: 16);
      if (val != null) {
        final color = hex.length == 8 ? Color(val) : Color(0xFF000000 | val);
        matches.add(ColorMatch(start: m.start, end: m.end, color: color, text: m.group(0)!));
      }
    });
    colorConstructorRegex.allMatches(text).forEach((m) {
      final hex = m.group(1);
      if (hex != null) {
        final val = int.tryParse(hex.substring(2), radix: 16);
        if (val != null) {
          matches.add(
            ColorMatch(start: m.start, end: m.end, color: Color(val), text: m.group(0)!),
          );
        }
      }
    });
    fromARGBRegex.allMatches(text).forEach((m) {
      final a = _parseColorComponent(m.group(1));
      final r = _parseColorComponent(m.group(2));
      final g = _parseColorComponent(m.group(3));
      final b = _parseColorComponent(m.group(4));
      if (a != null && r != null && g != null && b != null) {
        matches.add(
          ColorMatch(
            start: m.start,
            end: m.end,
            color: Color.fromARGB(a, r, g, b),
            text: m.group(0)!,
          ),
        );
      }
    });
    fromRGBORegex.allMatches(text).forEach((m) {
      final r = int.tryParse(m.group(1) ?? '');
      final g = int.tryParse(m.group(2) ?? '');
      final b = int.tryParse(m.group(3) ?? '');
      final o = double.tryParse(m.group(4) ?? '');
      if (r != null && g != null && b != null && o != null) {
        matches.add(
          ColorMatch(
            start: m.start,
            end: m.end,
            color: Color.fromRGBO(r, g, b, o),
            text: m.group(0)!,
          ),
        );
      }
    });

    if (matches.isEmpty) return textSpan;
    matches.sort((a, b) => a.start.compareTo(b.start));
    final uniqueMatches = <ColorMatch>[];
    int lastEnd = -1;
    for (final match in matches) {
      if (match.start >= lastEnd) {
        uniqueMatches.add(match);
        lastEnd = match.end;
      }
    }
    if (uniqueMatches.isEmpty) return textSpan;

    List<TextSpan> walkAndColor(TextSpan span, int currentPos) {
      final newChildren = <TextSpan>[];
      final spanStart = currentPos;
      final spanText = span.text ?? '';
      final spanEnd = spanStart + spanText.length;

      if (span.children?.isNotEmpty ?? false) {
        int childPos = currentPos;
        for (final child in span.children!) {
          if (child is TextSpan) {
            newChildren.addAll(walkAndColor(child, childPos));
            childPos += child.toPlainText().length;
          }
        }
        return [
          TextSpan(
            style: span.style,
            children: newChildren,
            recognizer: span.recognizer,
          ),
        ];
      }

      int lastSplitEnd = 0;
      for (final match in uniqueMatches) {
        final int effectiveStart = max(spanStart, match.start);
        final int effectiveEnd = min(spanEnd, match.end);

        if (effectiveStart < effectiveEnd) {
          if (effectiveStart > spanStart + lastSplitEnd) {
            final beforeText = spanText.substring(
              lastSplitEnd,
              effectiveStart - spanStart,
            );
            newChildren.add(TextSpan(text: beforeText, style: span.style));
          }

          final matchText = spanText.substring(
            effectiveStart - spanStart,
            effectiveEnd - spanStart,
          );
          final isDark = match.color.computeLuminance() < 0.5;
          final textColor = isDark ? Colors.white : Colors.black;

          newChildren.add(
            TextSpan(
              text: matchText,
              style: (span.style ?? style).copyWith(
                backgroundColor: match.color,
                color: textColor,
              ),
              recognizer: onColorCodeTap == null
                  ? null
                  : (TapGestureRecognizer()..onTap = () => onColorCodeTap(match)),
            ),
          );
          lastSplitEnd = effectiveEnd - spanStart;
        }
      }

      if (lastSplitEnd < spanText.length) {
        final remainingText = spanText.substring(lastSplitEnd);
        newChildren.add(TextSpan(text: remainingText, style: span.style));
      }
      return newChildren;
    }

    return TextSpan(children: walkAndColor(textSpan, 0), style: style);
  }

  static int? _parseColorComponent(String? s) {
    if (s == null) return null;
    s = s.trim();
    if (s.startsWith('0x')) {
      return int.tryParse(s.substring(2), radix: 16);
    }
    return int.tryParse(s);
  }

  static TextSpan _highlightBrackets(
    int index,
    TextSpan textSpan,
    TextStyle style,
    BracketHighlightState highlightState,
  ) {
    final highlightPositions =
        highlightState.bracketPositions
            .where((pos) => pos.index == index)
            .map((pos) => pos.offset)
            .toSet();
    if (highlightPositions.isEmpty) {
      return textSpan;
    }
    final builtSpans = <TextSpan>[];
    int currentPosition = 0;

    void processSpan(TextSpan span) {
      final text = span.text ?? '';
      final spanStyle = span.style ?? style;
      int lastSplit = 0;
      for (int i = 0; i < text.length; i++) {
        final absolutePosition = currentPosition + i;
        if (highlightPositions.contains(absolutePosition)) {
          if (i > lastSplit) {
            builtSpans.add(
              TextSpan(text: text.substring(lastSplit, i), style: spanStyle),
            );
          }
          builtSpans.add(
            TextSpan(
              text: text[i],
              style: spanStyle.copyWith(
                backgroundColor: Colors.yellow.withValues(alpha: 0.3),
                fontWeight: FontWeight.bold,
              ),
            ),
          );
          lastSplit = i + 1;
        }
      }
      if (lastSplit < text.length) {
        builtSpans.add(
          TextSpan(text: text.substring(lastSplit), style: spanStyle),
        );
      }
      currentPosition += text.length;
      if (span.children != null) {
        for (final child in span.children!) {
          if (child is TextSpan) {
            processSpan(child);
          }
        }
      }
    }

    processSpan(textSpan);
    return TextSpan(children: builtSpans, style: style);
  }


  static ({CodeLineSelection full, CodeLineSelection contents})?
  findSmallestEnclosingBlock(
    CodeLineSelection selection,
    CodeLineEditingController controller,
  ) {
    const List<String> openDelimiters = ['(', '[', '{', '"', "'"];
    CodeLinePosition scanPos = selection.start;
    while (true) {
      final char = _getChar(scanPos, controller);
      if (char != null && openDelimiters.contains(char)) {
        final openDelimiterPos = scanPos;
        final openChar = char;
        final closeChar = _getMatchingDelimiterChar(openChar);
        final closeDelimiterPos = _findMatchingDelimiter(
          openDelimiterPos,
          openChar,
          closeChar,
          controller,
        );
        if (closeDelimiterPos != null) {
          final fullBlockSelection = CodeLineSelection(
            baseIndex: openDelimiterPos.index,
            baseOffset: openDelimiterPos.offset,
            extentIndex: closeDelimiterPos.index,
            extentOffset: closeDelimiterPos.offset + 1,
          );
          if (fullBlockSelection.contains(selection)) {
            final contentSelection = CodeLineSelection(
              baseIndex: openDelimiterPos.index,
              baseOffset: openDelimiterPos.offset + 1,
              extentIndex: closeDelimiterPos.index,
              extentOffset: closeDelimiterPos.offset,
            );
            return (full: fullBlockSelection, contents: contentSelection);
          }
        }
      }
      final prevPos = _getPreviousPosition(scanPos, controller);
      if (prevPos == scanPos) {
        break;
      }
      scanPos = prevPos;
    }
    return null;
  }

  static CodeLinePosition? _findMatchingDelimiter(
    CodeLinePosition start,
    String open,
    String close,
    CodeLineEditingController controller,
  ) {
    int stack = 1;
    CodeLinePosition currentPos = _getNextPosition(start, controller);
    while (true) {
      final char = _getChar(currentPos, controller);
      if (char != null) {
        if (char == open && open != close) {
          stack++;
        } else if (char == close) {
          stack--;
        }
        if (stack == 0) {
          return currentPos;
        }
      }
      final nextPos = _getNextPosition(currentPos, controller);
      if (nextPos == currentPos) {
        break;
      }
      currentPos = nextPos;
    }
    return null;
  }

  static String _getMatchingDelimiterChar(String openChar) {
    const Map<String, String> pairs = {
      '(': ')',
      '[': ']',
      '{': '}',
      '"': '"',
      "'": "'",
    };
    return pairs[openChar]!;
  }

  static String? _getChar(
    CodeLinePosition pos,
    CodeLineEditingController controller,
  ) {
    if (pos.index < 0 || pos.index >= controller.codeLines.length) return null;
    final line = controller.codeLines[pos.index].text;
    if (pos.offset < 0 || pos.offset >= line.length) return null;
    return line[pos.offset];
  }

  static CodeLinePosition _getPreviousPosition(
    CodeLinePosition pos,
    CodeLineEditingController controller,
  ) {
    if (pos.offset > 0) {
      return CodeLinePosition(index: pos.index, offset: pos.offset - 1);
    }
    if (pos.index > 0) {
      final prevLine = controller.codeLines[pos.index - 1].text;
      return CodeLinePosition(index: pos.index - 1, offset: prevLine.length);
    }
    return pos;
  }

  static CodeLinePosition _getNextPosition(
    CodeLinePosition pos,
    CodeLineEditingController controller,
  ) {
    final line = controller.codeLines[pos.index].text;
    if (pos.offset < line.length) {
      return CodeLinePosition(index: pos.index, offset: pos.offset + 1);
    }
    if (pos.index < controller.codeLines.length - 1) {
      return CodeLinePosition(index: pos.index + 1, offset: 0);
    }
    return pos;
  }

  static int comparePositions(CodeLinePosition a, CodeLinePosition b) {
    if (a.index < b.index) return -1;
    if (a.index > b.index) return 1;
    return a.offset.compareTo(b.offset);
  }
}

// FILE: lib/editor/plugins/code_editor/widgets/code_editor_ui.dart

import 'dart:async';

import 'package:flutter/material.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:re_editor/re_editor.dart';
import '../logic/code_editor_types.dart';
import '../../../../command/command_widgets.dart';
import '../code_editor_plugin.dart';
import 'custom_code_line_number.dart';

class CustomEditorIndicator extends StatelessWidget {
  final CodeLineEditingController controller;
  final CodeChunkController chunkController;
  final CodeIndicatorValueNotifier notifier;
  final ValueNotifier<BracketHighlightState> bracketHighlightNotifier;

  const CustomEditorIndicator({
    super.key,
    required this.controller,
    required this.chunkController,
    required this.notifier,
    required this.bracketHighlightNotifier,
  });

  @override
  Widget build(BuildContext context) {
    return ValueListenableBuilder<BracketHighlightState>(
      valueListenable: bracketHighlightNotifier,
      builder: (context, bracketHighlightState, child) {
        return GestureDetector(
          behavior: HitTestBehavior.opaque,
          onTap: () {},
          child: Row(
            children: [
              CustomLineNumberWidget(
                controller: controller,
                notifier: notifier,
                highlightedLines: bracketHighlightState.highlightedLines,
              ),
              DefaultCodeChunkIndicator(
                width: 16,
                controller: chunkController,
                notifier: notifier,
              ),
            ],
          ),
        );
      },
    );
  }
}

class CustomLineNumberWidget extends StatelessWidget {
  final CodeLineEditingController controller;
  final CodeIndicatorValueNotifier notifier;
  final Set<int> highlightedLines;

  const CustomLineNumberWidget({
    super.key,
    required this.controller,
    required this.notifier,
    required this.highlightedLines,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return CustomCodeLineNumber(
      controller: controller,
      notifier: notifier,
      highlightedLines: highlightedLines,
      highlightColor: theme.colorScheme.secondary.withValues(alpha: 0.2),
      textStyle: TextStyle(
        color: theme.textTheme.bodySmall?.color?.withValues(alpha: 0.6),
        fontSize: 12,
      ),
      focusedTextStyle: TextStyle(
        color: theme.colorScheme.secondary,
        fontSize: 12,
        fontWeight: FontWeight.bold,
      ),
    );
  }
}


class CodeEditorSelectionAppBar extends ConsumerWidget {
  const CodeEditorSelectionAppBar({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final toolbar = CommandToolbar(
      position: CodeEditorPlugin.selectionToolbar,
      direction: Axis.horizontal,
    );

    return Material(
      elevation: 4.0,
      color: Theme.of(context).appBarTheme.backgroundColor,
      child: SafeArea(
        child: Container(
          height: Theme.of(context).appBarTheme.toolbarHeight ?? kToolbarHeight,
          padding: const EdgeInsets.symmetric(horizontal: 8.0),
          child: SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            reverse: true,
            child: CodeEditorTapRegion(child: toolbar),
          ),
        ),
      ),
    );
  }
}

class GrabbableScrollbar extends StatefulWidget {
  const GrabbableScrollbar({
    required this.details,
    required this.thickness,
    required this.child,
  });

  final ScrollableDetails details;
  final double thickness;
  final Widget child;

  @override
  State<GrabbableScrollbar> createState() => _GrabbableScrollbarState();
}

class _GrabbableScrollbarState extends State<GrabbableScrollbar> {
  bool _isScrolling = false;

  @override
  Widget build(BuildContext context) {
    return NotificationListener<ScrollNotification>(
      onNotification: (notification) {
        if (notification is ScrollStartNotification) {
          setState(() {
            _isScrolling = true;
          });
        } else if (notification is ScrollEndNotification) {
          Future.delayed(const Duration(milliseconds: 800), () {
            if (mounted) {
              setState(() {
                _isScrolling = false;
              });
            }
          });
        }
        return false;
      },
      child: RawScrollbar(
        controller: widget.details.controller,
        thumbVisibility: _isScrolling,
        thickness: widget.thickness,
        interactive: true,
        radius: Radius.circular(widget.thickness / 2),
        child: widget.child,
      ),
    );
  }
}

// FILE: lib/editor/plugins/code_editor/widgets/code_find_panel_view.dart


import 'dart:math';

import 'package:flutter/material.dart';

import 'package:re_editor/re_editor.dart';

class CodeFindAppBar extends StatelessWidget {
  final CodeFindController controller;

  const CodeFindAppBar({super.key, required this.controller});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return ValueListenableBuilder<CodeFindValue?>(
      valueListenable: controller,
      builder: (context, value, child) {
        if (value == null) {
          return const SizedBox.shrink();
        }

        final String result =
            (value.result == null || value.result!.matches.isEmpty)
                ? 'No results'
                : '${value.result!.index + 1}/${value.result!.matches.length}';

        return Material(
          elevation: 4.0,
          color: theme.appBarTheme.backgroundColor,
          child: SafeArea(
            child: SizedBox(
              height: theme.appBarTheme.toolbarHeight ?? kToolbarHeight,
              child: Row(
                children: [
                  IconButton(
                    icon: const Icon(Icons.close),
                    tooltip: 'Close Find',
                    onPressed: controller.close,
                  ),
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: theme.scaffoldBackgroundColor.withValues(
                        alpha: 0.8,
                      ),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      result,
                      style: TextStyle(
                        fontSize: _kDefaultFindResultFontSize,
                        color: theme.textTheme.bodySmall?.color,
                      ),
                    ),
                  ),
                  const Spacer(),
                  IconButton(
                    icon: const Icon(Icons.arrow_upward),
                    tooltip: 'Previous Match',
                    onPressed:
                        value.result == null ? null : controller.previousMatch,
                  ),
                  IconButton(
                    icon: const Icon(Icons.arrow_downward),
                    tooltip: 'Next Match',
                    onPressed:
                        value.result == null ? null : controller.nextMatch,
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}

const EdgeInsetsGeometry _kDefaultFindMargin = EdgeInsets.only(right: 10);
const double _kDefaultFindPanelWidth = 360;
const double _kDefaultFindPanelHeight = 36;
const double _kDefaultReplacePanelHeight = _kDefaultFindPanelHeight * 2;
const double _kDefaultFindIconSize = 16;
const double _kDefaultFindIconWidth = 30;
const double _kDefaultFindIconHeight = 30;
const double _kDefaultFindInputFontSize = 13;
const double _kDefaultFindResultFontSize = 12;
const EdgeInsetsGeometry _kDefaultFindPadding = EdgeInsets.only(
  left: 5,
  right: 5,
  top: 2.5,
  bottom: 2.5,
);
const EdgeInsetsGeometry _kDefaultFindInputContentPadding = EdgeInsets.only(
  left: 5,
  right: 5,
);

class CodeFindPanelView extends StatelessWidget implements PreferredSizeWidget {
  final CodeFindController controller;
  final EdgeInsetsGeometry margin;
  final bool readOnly;
  final Color? iconColor;
  final Color? iconSelectedColor;
  final double iconSize;
  final double inputFontSize;
  final double resultFontSize;
  final Color? inputTextColor;
  final Color? resultFontColor;
  final EdgeInsetsGeometry padding;
  final InputDecoration decoration;

  const CodeFindPanelView({
    super.key,
    required this.controller,
    this.margin = _kDefaultFindMargin,
    required this.readOnly,
    this.iconSelectedColor,
    this.iconColor,
    this.iconSize = _kDefaultFindIconSize,
    this.inputFontSize = _kDefaultFindInputFontSize,
    this.resultFontSize = _kDefaultFindResultFontSize,
    this.inputTextColor,
    this.resultFontColor,
    this.padding = _kDefaultFindPadding,
    this.decoration = const InputDecoration(
      filled: true,
      contentPadding: _kDefaultFindInputContentPadding,
      border: OutlineInputBorder(
        borderRadius: BorderRadius.all(Radius.circular(0)),
        gapPadding: 0,
      ),
    ),
  });

  @override
  Size get preferredSize => Size(
    double.infinity,
    controller.value == null
        ? 0
        : ((controller.value!.replaceMode
                ? _kDefaultReplacePanelHeight
                : _kDefaultFindPanelHeight) +
            margin.vertical),
  );

  @override
  Widget build(BuildContext context) {
    return ValueListenableBuilder<CodeFindValue?>(
      valueListenable: controller,
      builder: (context, value, child) {
        if (value == null) {
          return const SizedBox.shrink();
        }
        return Container(
          margin: margin,
          alignment: Alignment.topRight,
          height: preferredSize.height,
          child: ConstrainedBox(
            constraints: const BoxConstraints(
              maxWidth: _kDefaultFindPanelWidth,
            ),
            child: Material(
              elevation: 4,
              child: Column(
                children: [
                  _buildFindInputView(context, value),
                  if (value.replaceMode) _buildReplaceInputView(context, value),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildFindInputView(BuildContext context, CodeFindValue value) {

    return SizedBox(
      height: _kDefaultFindPanelHeight,
      child: Row(
        children: [
          Expanded(
            child: Padding(
              padding: padding,
              child: TextField(
                maxLines: 1,
                focusNode: controller.findInputFocusNode,
                style: TextStyle(
                  color: inputTextColor,
                  fontSize: inputFontSize,
                ),
                decoration: decoration.copyWith(
                  contentPadding:
                      (decoration.contentPadding ?? EdgeInsets.zero)
                          as EdgeInsets,
                  suffixIcon: Row(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [
                      _buildCheckText(
                        context: context,
                        text: 'Aa',
                        checked: value.option.caseSensitive,
                        onPressed: controller.toggleCaseSensitive,
                      ),
                      _buildCheckText(
                        context: context,
                        text: '.*',
                        checked: value.option.regex,
                        onPressed: () {
                          if (value.option.regex) {
                            if (value.option.multiLine) {
                              controller.toggleMultiLine();
                            }
                            if (value.option.dotAll) controller.toggleDotAll();
                          }
                          controller.toggleRegex();
                        },
                      ),
                      if (value.option.regex)
                        Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const SizedBox(width: 4),
                            _buildCheckText(
                              context: context,
                              text: 'm',
                              checked: value.option.multiLine,
                              onPressed: controller.toggleMultiLine,
                            ),
                            _buildCheckText(
                              context: context,
                              text: 's',
                              checked: value.option.dotAll,
                              onPressed: controller.toggleDotAll,
                            ),
                          ],
                        ),
                    ],
                  ),
                ),
                controller: controller.findInputController,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildReplaceInputView(BuildContext context, CodeFindValue value) {
    return SizedBox(
      height: _kDefaultFindPanelHeight,
      child: Row(
        children: [
          Expanded(
            child: Padding(
              padding: padding,
              child: TextField(
                maxLines: 1,
                focusNode: controller.replaceInputFocusNode,
                style: TextStyle(
                  color: inputTextColor,
                  fontSize: inputFontSize,
                ),
                decoration: decoration.copyWith(
                  contentPadding:
                      (decoration.contentPadding ?? EdgeInsets.zero)
                          as EdgeInsets,
                ),
                controller: controller.replaceInputController,
              ),
            ),
          ),
          _buildIconButton(
            onPressed:
                value.result == null || readOnly
                    ? null
                    : controller.replaceMatch,
            icon: Icons.done,
            tooltip: 'Replace',
          ),
          _buildIconButton(
            onPressed:
                value.result == null || readOnly
                    ? null
                    : controller.replaceAllMatches,
            icon: Icons.done_all,
            tooltip: 'Replace All',
          ),
        ],
      ),
    );
  }

  Widget _buildCheckText({
    required BuildContext context,
    required String text,
    required bool checked,
    required VoidCallback onPressed,
  }) {
    return GestureDetector(
      onTap: onPressed,
      child: MouseRegion(
        cursor: SystemMouseCursors.click,
        child: SizedBox(
          width: _kDefaultFindIconWidth * 0.75,
          child: Tooltip(
            message: text == 'm' ? 'Multiline' : (text == 's' ? 'Dot All' : ''),
            child: Text(
              text,
              style: TextStyle(
                color: checked ? iconSelectedColor : iconColor,
                fontSize: inputFontSize,
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildIconButton({
    required IconData icon,
    VoidCallback? onPressed,
    String? tooltip,
  }) {
    return IconButton(
      onPressed: onPressed,
      icon: Icon(icon, size: iconSize),
      constraints: const BoxConstraints(
        maxWidth: _kDefaultFindIconWidth,
        maxHeight: _kDefaultFindIconHeight,
      ),
      tooltip: tooltip,
      splashRadius: max(_kDefaultFindIconWidth, _kDefaultFindIconHeight) / 2,
    );
  }
}

// FILE: lib/editor/plugins/code_editor/widgets/custom_code_line_number.dart


import 'package:flutter/material.dart';
import 'package:re_editor/re_editor.dart';

class CustomCodeLineNumber extends LeafRenderObjectWidget {
  final CodeLineEditingController controller;
  final CodeIndicatorValueNotifier notifier;
  final TextStyle textStyle;
  final TextStyle focusedTextStyle;
  final Set<int> highlightedLines;
  final Color highlightColor;
  final int minNumberCount;

  const CustomCodeLineNumber({
    super.key,
    required this.notifier,
    required this.controller,
    required this.highlightedLines,
    required this.highlightColor,
    required this.textStyle,
    required this.focusedTextStyle,
    this.minNumberCount = 3,
  });

  @override
  RenderObject createRenderObject(BuildContext context) {
    return CustomCodeLineNumberRenderObject(
      controller: controller,
      notifier: notifier,
      textStyle: textStyle,
      focusedTextStyle: focusedTextStyle,
      highlightedLines: highlightedLines,
      highlightColor: highlightColor,
      minNumberCount: minNumberCount,
    );
  }

  @override
  void updateRenderObject(
    BuildContext context,
    covariant CustomCodeLineNumberRenderObject renderObject,
  ) {
    renderObject
      ..controller = controller
      ..notifier = notifier
      ..textStyle = textStyle
      ..focusedTextStyle = focusedTextStyle
      ..highlightedLines = highlightedLines
      ..highlightColor = highlightColor
      ..minNumberCount = minNumberCount;
  }
}

class CustomCodeLineNumberRenderObject extends CodeLineNumberRenderObject {
  Set<int> _highlightedLines;
  Color _highlightColor;
  late final Paint _highlightPaint;

  CodeIndicatorValueNotifier _notifier;

  CustomCodeLineNumberRenderObject({
    required super.controller,
    required CodeIndicatorValueNotifier
    notifier,
    required super.textStyle,
    required super.focusedTextStyle,
    required super.minNumberCount,
    required Set<int> highlightedLines,
    required Color highlightColor,
  }) : _highlightedLines = highlightedLines,
       _highlightColor = highlightColor,
       _notifier = notifier,
       super(notifier: notifier)
       {
    _highlightPaint = Paint()..color = _highlightColor;
  }

  @override
  set notifier(CodeIndicatorValueNotifier value) {
    if (_notifier == value) {
      return;
    }
    _notifier = value;
    super.notifier = value;
  }

  Set<int> get highlightedLines => _highlightedLines;
  set highlightedLines(Set<int> value) {
    if (_highlightedLines == value) {
      return;
    }
    _highlightedLines = value;
    markNeedsPaint();
  }

  Color get highlightColor => _highlightColor;
  set highlightColor(Color value) {
    if (_highlightColor == value) {
      return;
    }
    _highlightColor = value;
    _highlightPaint.color = value;
    markNeedsPaint();
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    final CodeIndicatorValue? value = _notifier.value;
    if (value == null) {
      return;
    }

    if (_highlightedLines.isNotEmpty) {
      for (final CodeLineRenderParagraph paragraph in value.paragraphs) {
        if (_highlightedLines.contains(paragraph.index)) {
          final Rect rect = Rect.fromLTWH(
            offset.dx,
            offset.dy + paragraph.offset.dy,
            size.width,
            paragraph.height,
          );
          context.canvas.drawRect(rect, _highlightPaint);
        }
      }
    }

    super.paint(context, offset);
  }
}

// FILE: lib/editor/plugins/code_editor/widgets/goto_line_dialog.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class GoToLineDialog extends StatefulWidget {
  final int maxLine;
  final int currentLine;

  const GoToLineDialog({
    super.key,
    required this.maxLine,
    required this.currentLine,
  });

  @override
  State<GoToLineDialog> createState() => _GoToLineDialogState();
}

class _GoToLineDialogState extends State<GoToLineDialog> {
  late final TextEditingController _controller;
  final _formKey = GlobalKey<FormState>();

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController(
      text: (widget.currentLine + 1).toString(),
    );

    _controller.selection = TextSelection(
      baseOffset: 0,
      extentOffset: _controller.text.length,
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _submit() {
    if (_formKey.currentState?.validate() ?? false) {
      final int lineNumber = int.parse(_controller.text);
      Navigator.of(context).pop(lineNumber - 1);
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Go to Line'),
      content: Form(
        key: _formKey,
        child: TextFormField(
          controller: _controller,
          autofocus: true,
          keyboardType: TextInputType.number,
          inputFormatters: [FilteringTextInputFormatter.digitsOnly],
          decoration: InputDecoration(
            labelText: 'Line Number (1 - ${widget.maxLine})',
            hintText: 'Enter line number',
          ),
          validator: (value) {
            if (value == null || value.isEmpty) {
              return 'Please enter a number';
            }
            try {
              final int number = int.parse(value);
              if (number < 1 || number > widget.maxLine) {
                return 'Must be between 1 and ${widget.maxLine}';
              }
            } catch (e) {
              return 'Invalid number';
            }
            return null;
          },
          onFieldSubmitted: (_) => _submit(),
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        FilledButton(onPressed: _submit, child: const Text('Go')),
      ],
    );
  }
}

// FILE: lib/editor/plugins/editor_plugin_registry.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'code_editor/code_editor_plugin.dart';
import 'glitch_editor/glitch_editor_plugin.dart';
import 'llm_editor/llm_editor_plugin.dart';
import '../models/editor_plugin_models.dart';
import 'recipe_tex/recipe_tex_plugin.dart';

import 'refactor_editor/refactor_editor_plugin.dart';
import 'tiled_editor/tiled_editor_plugin.dart';
import 'texture_packer/texture_packer_plugin.dart';

export '../models/editor_plugin_models.dart';
import 'flow_graph/flow_graph_editor_plugin.dart';
import 'termux_terminal/termux_terminal_plugin.dart';

final pluginRegistryProvider = Provider<Set<EditorPlugin>>(
  (_) => {
    CodeEditorPlugin(),
    GlitchEditorPlugin(),
    RecipeTexPlugin(),
    LlmEditorPlugin(),
    RefactorEditorPlugin(),
    TiledEditorPlugin(),
    TexturePackerPlugin(),
    FlowGraphEditorPlugin(),
    TermuxTerminalPlugin(),
  },
);

final activePluginsProvider =
    StateNotifierProvider<PluginManager, List<EditorPlugin>>((ref) {
      final initialPlugins = ref.read(pluginRegistryProvider);
      return PluginManager(initialPlugins);
    });

class PluginManager extends StateNotifier<List<EditorPlugin>> {
  PluginManager(Set<EditorPlugin> plugins)
    : super(_sortPlugins(plugins.toList()));

  static List<EditorPlugin> _sortPlugins(List<EditorPlugin> plugins) {
    plugins.sort((a, b) => b.priority.compareTo(a.priority));
    return plugins;
  }

  void registerPlugin(EditorPlugin plugin) {
    state = _sortPlugins([...state, plugin]);
  }

  void unregisterPlugin(EditorPlugin plugin) {
    state = _sortPlugins(state.where((p) => p != plugin).toList());
  }
}

// FILE: lib/editor/plugins/refactor_editor/occurrence_list_item.dart


import 'package:flutter/material.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:re_highlight/re_highlight.dart';
import 'package:re_highlight/styles/default.dart' as default_theme;

import '../../../utils/code_themes.dart';
import '../../../utils/llm_highlight_util.dart';
import '../../../settings/settings_notifier.dart';
import '../../plugins/code_editor/code_editor_models.dart';
import 'refactor_editor_models.dart';

class OccurrenceListItem extends ConsumerStatefulWidget {
  final RefactorResultItem item;
  final bool isSelected;
  final ValueChanged<bool?> onSelected;
  final VoidCallback onJumpTo;

  const OccurrenceListItem({
    super.key,
    required this.item,
    required this.isSelected,
    required this.onSelected,
    required this.onJumpTo,
  });

  @override
  ConsumerState<OccurrenceListItem> createState() => _OccurrenceListItemState();
}

class _OccurrenceListItemState extends ConsumerState<OccurrenceListItem> {
  late TextSpan _previewSpan;
  late Widget _leadingIcon;

  @override
  void initState() {
    super.initState();
    _computeRenderData();
  }

  @override
  void didUpdateWidget(covariant OccurrenceListItem oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.item != widget.item ||
        oldWidget.isSelected != widget.isSelected) {
      _computeRenderData();
    }
  }

  void _computeRenderData() {
    final settings =
        ref.read(
          effectiveSettingsProvider.select(
            (s) => s.pluginSettings[CodeEditorSettings] as CodeEditorSettings?,
          ),
        ) ??
        CodeEditorSettings();
    final codeThemeData =
        CodeThemes.availableCodeThemes[settings.themeName] ??
        default_theme.defaultTheme;
    final textStyle = TextStyle(fontFamily: settings.fontFamily, fontSize: 13);
    final occurrence = widget.item.occurrence;
    final leadingWhitespace = RegExp(r'^\s*');
    final whitespaceMatch = leadingWhitespace.firstMatch(
      occurrence.lineContent,
    );
    final trimmedCode = occurrence.lineContent.trimLeft();
    final trimmedLength = whitespaceMatch?.group(0)?.length ?? 0;
    LlmHighlightUtil.ensureLanguagesRegistered();
    final languageKey = CodeThemes.inferLanguageKey(occurrence.displayPath);
    final highlightResult = LlmHighlightUtil.highlight.highlight(
      code: trimmedCode,
      language: languageKey,
    );
    final renderer = TextSpanRenderer(textStyle, codeThemeData);
    highlightResult.render(renderer);
    final highlightedSpan =
        renderer.span ?? TextSpan(text: trimmedCode, style: textStyle);

    final matchStartInTrimmed = occurrence.startColumn - trimmedLength;
    final matchEndInTrimmed =
        matchStartInTrimmed + occurrence.matchedText.length;

    _previewSpan = TextSpan(
      children: _overlayHighlight(
        source: highlightedSpan,
        start: matchStartInTrimmed,
        end: matchEndInTrimmed,
        highlightStyle: TextStyle(
          backgroundColor: Theme.of(
            context,
          ).colorScheme.primary.withValues(alpha: 0.5),
          fontWeight: FontWeight.bold,
        ),
      ),
    );

    switch (widget.item.status) {
      case ResultStatus.pending:
        _leadingIcon = Checkbox(
          value: widget.isSelected,
          onChanged: widget.onSelected,
        );
        break;
      case ResultStatus.applied:
        _leadingIcon = const Icon(Icons.check_circle, color: Colors.green);
        break;
      case ResultStatus.failed:
        _leadingIcon = Tooltip(
          message: widget.item.failureReason ?? 'An unknown error occurred.',
          child: const Icon(Icons.error, color: Colors.red),
        );
        break;
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final settings =
        ref.watch(
          effectiveSettingsProvider.select(
            (s) => s.pluginSettings[CodeEditorSettings] as CodeEditorSettings?,
          ),
        ) ??
        CodeEditorSettings();
    final codeThemeData =
        CodeThemes.availableCodeThemes[settings.themeName] ??
        default_theme.defaultTheme;
    final textStyle = TextStyle(fontFamily: settings.fontFamily, fontSize: 13);
    final codeBgColor =
        codeThemeData['root']?.backgroundColor ??
        Colors.black.withValues(alpha: 0.25);
    final occurrence = widget.item.occurrence;

    return Material(
      color:
          widget.isSelected
              ? theme.colorScheme.primary.withValues(alpha: 0.1)
              : Colors.transparent,
      child: InkWell(
        onTap: widget.onJumpTo,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 8, 16, 8),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(width: 40, child: Center(child: _leadingIcon)),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Container(
                      width: double.infinity,
                      padding: const EdgeInsets.symmetric(
                        horizontal: 12,
                        vertical: 8,
                      ),
                      decoration: BoxDecoration(
                        color: codeBgColor,
                        borderRadius: BorderRadius.circular(4),
                      ),
                      child: SingleChildScrollView(
                        scrollDirection: Axis.horizontal,
                        child: Row(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Container(
                              padding: const EdgeInsets.only(right: 12.0),
                              child: Text(
                                '${occurrence.lineNumber + 1}',
                                style: textStyle.copyWith(
                                  color: Colors.grey.shade600,
                                ),
                              ),
                            ),
                            RichText(text: _previewSpan),
                          ],
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
            const Divider(height: 1, indent: 16, endIndent: 16),
          ],
        ),
      ),
    );
  }

  List<TextSpan> _overlayHighlight({
    required TextSpan source,
    required int start,
    required int end,
    required TextStyle highlightStyle,
  }) {
    final List<TextSpan> result = [];
    int currentIndex = 0;

    void processSpan(TextSpan span) {
      if (span.children != null && span.children!.isNotEmpty) {
        for (final child in span.children!) {
          if (child is TextSpan) processSpan(child);
        }
        return;
      }

      if (span.text == null || span.text!.isEmpty) return;

      final spanText = span.text!;
      final spanStart = currentIndex;
      final spanEnd = spanStart + spanText.length;
      final highlightStart = start;
      final highlightEnd = end;

      if (spanEnd <= highlightStart || spanStart >= highlightEnd) {
        result.add(span);
      } else {
        if (spanStart < highlightStart) {
          result.add(
            TextSpan(
              text: spanText.substring(0, highlightStart - spanStart),
              style: span.style,
            ),
          );
        }
        final int intersectionStart =
            (spanStart > highlightStart) ? spanStart : highlightStart;
        final int intersectionEnd =
            (spanEnd < highlightEnd) ? spanEnd : highlightEnd;
        result.add(
          TextSpan(
            text: spanText.substring(
              intersectionStart - spanStart,
              intersectionEnd - spanStart,
            ),
            style: (span.style ?? const TextStyle()).merge(highlightStyle),
          ),
        );
        if (spanEnd > highlightEnd) {
          result.add(
            TextSpan(
              text: spanText.substring(highlightEnd - spanStart),
              style: span.style,
            ),
          );
        }
      }

      currentIndex = spanEnd;
    }

    processSpan(source);
    return result;
  }
}

// FILE: lib/editor/plugins/refactor_editor/refactor_editor_controller.dart


import 'package:flutter/foundation.dart';

import 'refactor_editor_models.dart';

class RefactorController extends ChangeNotifier {
  String searchTerm;
  String replaceTerm;
  bool isRegex;
  bool isCaseSensitive;
  bool autoOpenFiles;
  RefactorMode mode;
  SearchStatus searchStatus = SearchStatus.idle;

  final List<RefactorResultItem> resultItems = [];
  final Set<RefactorResultItem> selectedItems = {};

  RefactorController({required RefactorSessionState initialState})
    : searchTerm = initialState.searchTerm,
      replaceTerm = initialState.replaceTerm,
      isRegex = initialState.isRegex,
      isCaseSensitive = initialState.isCaseSensitive,
      autoOpenFiles = initialState.autoOpenFiles,
      mode = initialState.mode;


  void updateSearchTerm(String term) {
    searchTerm = term;
    notifyListeners();
  }

  void updateReplaceTerm(String term) {
    replaceTerm = term;
    notifyListeners();
  }

  void setMode(RefactorMode newMode) {
    mode = newMode;
    resultItems.clear();
    selectedItems.clear();
    searchStatus = SearchStatus.idle;
    notifyListeners();
  }

  void toggleIsRegex(bool value) {
    isRegex = value;
    notifyListeners();
  }

  void toggleCaseSensitive(bool value) {
    isCaseSensitive = value;
    notifyListeners();
  }

  void toggleAutoOpenFiles(bool value) {
    autoOpenFiles = value;
    notifyListeners();
  }

  void toggleItemSelection(RefactorResultItem item) {
    if (item.status != ResultStatus.pending) return;
    if (selectedItems.contains(item)) {
      selectedItems.remove(item);
    } else {
      selectedItems.add(item);
    }
    notifyListeners();
  }

  void toggleSelectAll(bool isSelected) {
    selectedItems.clear();
    if (isSelected) {
      selectedItems.addAll(
        resultItems.where((item) => item.status == ResultStatus.pending),
      );
    }
    notifyListeners();
  }

  void toggleSelectAllForFile(String fileUri, bool shouldSelect) {
    final itemsForFile = resultItems.where(
      (i) =>
          i.occurrence.fileUri == fileUri && i.status == ResultStatus.pending,
    );

    if (shouldSelect) {
      selectedItems.addAll(itemsForFile);
    } else {
      selectedItems.removeAll(itemsForFile);
    }
    notifyListeners();
  }

  void startSearch() {
    searchStatus = SearchStatus.searching;
    resultItems.clear();
    selectedItems.clear();
    notifyListeners();
  }

  void completeSearch(List<RefactorOccurrence> results) {
    resultItems.addAll(
      results.map((occ) => RefactorResultItem(occurrence: occ)),
    );
    searchStatus = SearchStatus.complete;
    notifyListeners();
  }

  void failSearch() {
    searchStatus = SearchStatus.error;
    notifyListeners();
  }

  void updateItemsStatus({
    required Iterable<RefactorResultItem> processed,
    required Map<RefactorResultItem, String> failed,
  }) {
    final processedSet = processed.toSet();
    for (int i = 0; i < resultItems.length; i++) {
      final currentItem = resultItems[i];
      if (processedSet.contains(currentItem)) {
        resultItems[i] = currentItem.copyWith(status: ResultStatus.applied);
      } else if (failed.containsKey(currentItem)) {
        resultItems[i] = currentItem.copyWith(
          status: ResultStatus.failed,
          failureReason: failed[currentItem],
        );
      }
    }
    selectedItems.clear();
    notifyListeners();
  }


  List<RefactorOccurrence> searchInContent({
    required String content,
    required String fileUri,
    required String displayPath,
    required String fileContentHash,
  }) {
    if (searchTerm.isEmpty) return [];

    final occurrencesInFile = <RefactorOccurrence>[];
    final lines = content.split('\n');

    for (int i = 0; i < lines.length; i++) {
      final line = lines[i];
      Iterable<Match> matches;

      if (isRegex) {
        try {
          matches = RegExp(
            searchTerm,
            caseSensitive: isCaseSensitive,
          ).allMatches(line);
        } catch (e) {
          matches = [];
        }
      } else {
        final tempMatches = <Match>[];
        int startIndex = 0;
        final query = isCaseSensitive ? searchTerm : searchTerm.toLowerCase();
        final target = isCaseSensitive ? line : line.toLowerCase();
        while (startIndex < target.length) {
          final index = target.indexOf(query, startIndex);
          if (index == -1) break;
          tempMatches.add(
            _StringMatch(
              line,
              index,
              line.substring(index, index + searchTerm.length),
            ),
          );
          startIndex = index + searchTerm.length;
        }
        matches = tempMatches;
      }

      for (final match in matches) {

        occurrencesInFile.add(
          RefactorOccurrence(
            fileUri: fileUri,
            displayPath: displayPath,
            lineNumber: i,
            startColumn: match.start,
            lineContent: line,
            matchedText: match.group(0)!,
            fileContentHash: fileContentHash,
          ),
        );
      }
    }
    return occurrencesInFile;
  }
}

class _StringMatch implements Match {
  @override
  final String input;
  @override
  final int start;
  final String _text;
  _StringMatch(this.input, this.start, this._text);
  @override
  int get end => start + _text.length;
  @override
  String? group(int group) => group == 0 ? _text : null;
  @override
  List<String?> groups(List<int> groupIndices) =>
      groupIndices.map(group).toList();
  @override
  int get groupCount => 0;
  @override
  Pattern get pattern => throw UnimplementedError();
  @override
  String operator [](int group) => this.group(group)!;
}

// FILE: lib/editor/plugins/refactor_editor/refactor_editor_hot_state.dart


import 'package:flutter/foundation.dart';

import '../../../data/cache/type_adapters.dart';
import '../../../data/dto/tab_hot_state_dto.dart';
import 'refactor_editor_models.dart';

@immutable
class RefactorEditorHotStateDto extends TabHotStateDto {
  final String searchTerm;
  final String replaceTerm;
  final bool isRegex;
  final bool isCaseSensitive;
  final bool autoOpenFiles;
  final RefactorMode mode;

  const RefactorEditorHotStateDto({
    required this.searchTerm,
    required this.replaceTerm,
    required this.isRegex,
    required this.isCaseSensitive,
    required this.autoOpenFiles,
    required this.mode,
    super.baseContentHash,
  });
}

class RefactorEditorHotStateAdapter
    implements TypeAdapter<RefactorEditorHotStateDto> {
  @override
  RefactorEditorHotStateDto fromJson(Map<String, dynamic> json) {
    return RefactorEditorHotStateDto(
      searchTerm: json['searchTerm'] as String? ?? '',
      replaceTerm: json['replaceTerm'] as String? ?? '',
      isRegex: json['isRegex'] as bool? ?? false,
      isCaseSensitive: json['isCaseSensitive'] as bool? ?? false,
      autoOpenFiles: json['autoOpenFiles'] as bool? ?? true,
      mode: RefactorMode.values.firstWhere(
        (e) => e.name == json['mode'],
        orElse: () => RefactorMode.text,
      ),
      baseContentHash: json['baseContentHash'] as String?,
    );
  }

  @override
  Map<String, dynamic> toJson(RefactorEditorHotStateDto object) {
    return {
      'searchTerm': object.searchTerm,
      'replaceTerm': object.replaceTerm,
      'isRegex': object.isRegex,
      'isCaseSensitive': object.isCaseSensitive,
      'autoOpenFiles': object.autoOpenFiles,
      'mode': object.mode.name,
      'baseContentHash': object.baseContentHash,
    };
  }
}

// FILE: lib/editor/plugins/refactor_editor/refactor_editor_models.dart


import 'package:flutter/material.dart';

import '../../models/editor_tab_models.dart';
import '../../models/editor_plugin_models.dart';
import 'refactor_editor_widget.dart';


class RefactorSettings extends PluginSettings {
  Set<String> supportedExtensions;
  Set<String> ignoredGlobPatterns;
  bool useProjectGitignore;
  bool updateInternalPathsAsDirty;

  RefactorSettings({
    Set<String>? supportedExtensions,
    Set<String>? ignoredGlobPatterns,
    this.useProjectGitignore = true,
    this.updateInternalPathsAsDirty = true,
  })  : supportedExtensions =
            supportedExtensions ?? {'.dart', '.yaml', '.md', '.txt', '.json'},
        ignoredGlobPatterns = ignoredGlobPatterns ??
            {'.git/**', '.idea/**', 'build/**', '.dart_tool/**'};

  RefactorSettings copyWith({
    Set<String>? supportedExtensions,
    Set<String>? ignoredGlobPatterns,
    bool? useProjectGitignore,
    bool? updateInternalPathsAsDirty,
  }) {
    return RefactorSettings(
      supportedExtensions: supportedExtensions ?? this.supportedExtensions,
      ignoredGlobPatterns: ignoredGlobPatterns ?? this.ignoredGlobPatterns,
      useProjectGitignore: useProjectGitignore ?? this.useProjectGitignore,
      updateInternalPathsAsDirty:
          updateInternalPathsAsDirty ?? this.updateInternalPathsAsDirty,
    );
  }

  @override
  MachineSettings clone() {
    return RefactorSettings(
      supportedExtensions: Set<String>.from(supportedExtensions),
      ignoredGlobPatterns: Set<String>.from(ignoredGlobPatterns),
      useProjectGitignore: useProjectGitignore,
      updateInternalPathsAsDirty: updateInternalPathsAsDirty,
    );
  }

  @override
  void fromJson(Map<String, dynamic> json) {
    final legacyIgnored = List<String>.from(json['ignoredFolders'] ?? []);
    final currentIgnored = List<String>.from(json['ignoredGlobPatterns'] ?? []);

    supportedExtensions = Set<String>.from(json['supportedExtensions'] ?? {});
    ignoredGlobPatterns = {...legacyIgnored, ...currentIgnored}.toSet();
    useProjectGitignore = json['useProjectGitignore'] as bool? ?? true;
    updateInternalPathsAsDirty =
        json['updateInternalPathsAsDirty'] as bool? ?? true;
  }

  @override
  Map<String, dynamic> toJson() => {
        'supportedExtensions': supportedExtensions.toList(),
        'ignoredGlobPatterns': ignoredGlobPatterns.toList(),
        'useProjectGitignore': useProjectGitignore,
        'updateInternalPathsAsDirty': updateInternalPathsAsDirty,
      };
}

/// Represents a single occurrence of a search term within a file.
@immutable
class RefactorOccurrence {
  final String fileUri;
  final String displayPath;
  final int lineNumber;
  final int startColumn;
  final String lineContent;
  final String matchedText;
  final String fileContentHash;

  const RefactorOccurrence({
    required this.fileUri,
    required this.displayPath,
    required this.lineNumber,
    required this.startColumn,
    required this.lineContent,
    required this.matchedText,
    required this.fileContentHash,
  });
}

enum ResultStatus { pending, applied, failed }

@immutable
class RefactorResultItem {
  final RefactorOccurrence occurrence;
  final ResultStatus status;
  final String? failureReason;

  const RefactorResultItem({
    required this.occurrence,
    this.status = ResultStatus.pending,
    this.failureReason,
  });

  RefactorResultItem copyWith({ResultStatus? status, String? failureReason}) {
    return RefactorResultItem(
      occurrence: occurrence,
      status: status ?? this.status,
      failureReason: failureReason ?? this.failureReason,
    );
  }
}

enum RefactorMode { text, path }

@immutable
class RefactorSessionState {
  final String searchTerm;
  final String replaceTerm;
  final bool isRegex;
  final bool isCaseSensitive;
  final bool autoOpenFiles;
  final RefactorMode mode;

  const RefactorSessionState({
    this.searchTerm = '',
    this.replaceTerm = '',
    this.isRegex = false,
    this.isCaseSensitive = false,
    this.autoOpenFiles = true,
    this.mode = RefactorMode.text,
  });
}

enum SearchStatus { idle, searching, complete, error }

class RefactorEditorTab extends EditorTab {
  @override
  final GlobalKey<RefactorEditorWidgetState> editorKey;
  final RefactorSessionState initialState;

  RefactorEditorTab({
    required super.plugin,
    required this.initialState,
    super.id,
    super.onReadyCompleter,
  }) : editorKey = GlobalKey<RefactorEditorWidgetState>();

  @override
  void dispose() {
  }
}

// FILE: lib/editor/plugins/refactor_editor/refactor_editor_plugin.dart

import 'dart:async';

import 'package:flutter/material.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../app/app_notifier.dart';
import '../../../command/command_models.dart';
import '../../../data/cache/type_adapters.dart';
import '../../../data/file_handler/file_handler.dart';
import '../../models/editor_tab_models.dart';
import '../../models/editor_plugin_models.dart';
import '../../../project/project_models.dart';
import 'refactor_editor_hot_state.dart';
import 'refactor_editor_models.dart';
import 'refactor_editor_widget.dart';

import 'refactor_editor_settings_widget.dart';

const String refactorSessionUri = 'internal:

class RefactorEditorPlugin extends EditorPlugin {
  @override
  String get id => 'com.machine.refactor_editor';
  @override
  String get name => 'Workspace Refactor';
  @override
  Widget get icon => const Icon(Icons.find_replace);
  @override
  int get priority => 100;

  @override
  PluginSettings? get settings => RefactorSettings();

  @override
  Widget buildSettingsUI(
    PluginSettings settings,
    void Function(PluginSettings) onChanged,
  ) => RefactorEditorSettingsUI(settings: settings as RefactorSettings, onChanged: onChanged);

  @override
  bool supportsFile(DocumentFile file) {
    return file is InternalAppFile && file.uri == refactorSessionUri;
  }

  @override
  List<Command> getAppCommands() {
    return [
      BaseCommand(
        id: 'workspace_refactor',
        label: 'Workspace Refactor',
        icon: const Icon(Icons.manage_search),
        defaultPositions: [AppCommandPositions.appBar],
        sourcePlugin: 'App',
        execute: (ref) async {
          final refactorSessionFile = InternalAppFile(
            uri: refactorSessionUri,
            name: 'Workspace Refactor',
            modifiedDate: DateTime.now(),
          );
          ref
              .read(appNotifierProvider.notifier)
              .openFileInEditor(refactorSessionFile);
        },
      ),
    ];
  }

  @override
  Future<EditorTab> createTab(
    DocumentFile file,
    EditorInitData initData, {
    String? id,
    Completer<EditorWidgetState>? onReadyCompleter,
  }) async {
    RefactorSessionState initialState;
    if (initData.hotState is RefactorEditorHotStateDto) {
      final hotState = initData.hotState as RefactorEditorHotStateDto;
      initialState = RefactorSessionState(
        searchTerm: hotState.searchTerm,
        replaceTerm: hotState.replaceTerm,
        isRegex: hotState.isRegex,
        isCaseSensitive: hotState.isCaseSensitive,
      );
    } else {
      initialState = const RefactorSessionState();
    }

    return RefactorEditorTab(
      plugin: this,
      initialState: initialState,
      id: id,
      onReadyCompleter: onReadyCompleter,
    );
  }

  @override
  EditorWidget buildEditor(EditorTab tab, WidgetRef ref) {
    return RefactorEditorWidget(
      key: tab.editorKey as GlobalKey<RefactorEditorWidgetState>,
      tab: tab as RefactorEditorTab,
    );
  }

  @override
  String? get hotStateDtoType => 'com.machine.refactor_editor_state';
  @override
  Type? get hotStateDtoRuntimeType => RefactorEditorHotStateDto;
  @override
  TypeAdapter<TabHotStateDto>? get hotStateAdapter =>
      RefactorEditorHotStateAdapter();
}

// FILE: lib/editor/plugins/refactor_editor/refactor_editor_settings_widget.dart

import 'package:flutter/material.dart';

import '../../../widgets/dialogs/file_explorer_dialogs.dart';
import 'refactor_editor_models.dart';

class RefactorEditorSettingsUI extends StatelessWidget {
  final RefactorSettings settings;
  final void Function(RefactorSettings) onChanged;

  const RefactorEditorSettingsUI({
    super.key,
    required this.settings,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('Configuration', style: Theme.of(context).textTheme.titleMedium),
        const SizedBox(height: 16),
        _buildEditableList(
          context,
          title: 'Supported File Extensions',
          items: settings.supportedExtensions,
          onListChanged: (newItems) {
            onChanged(
              settings.copyWith(supportedExtensions: newItems),
            );
          },
        ),
        const SizedBox(height: 24),
        _buildEditableList(
          context,
          title: 'Global Ignored Glob Patterns',
          items: settings.ignoredGlobPatterns,
          onListChanged: (newItems) {
            onChanged(
              settings.copyWith(ignoredGlobPatterns: newItems),
            );
          },
        ),
        const SizedBox(height: 16),
        SwitchListTile(
          title: const Text('Use Project .gitignore'),
          subtitle: const Text(
            'Automatically use patterns from the .gitignore file in the current project root, if it exists.',
          ),
          value: settings.useProjectGitignore,
          onChanged: (newValue) {
            onChanged(
              settings.copyWith(useProjectGitignore: newValue),
            );
          },
        ),
        const Divider(),
        SwitchListTile(
          title: const Text('Mark moved files as dirty instead of auto-saving'),
          subtitle: const Text(
            'When a file is moved, if this is on, its updated internal paths will be applied as unsaved changes. If off, the file will be saved directly to disk.',
          ),
          value: settings.updateInternalPathsAsDirty,
          onChanged: (newValue) {
            onChanged(
              settings.copyWith(updateInternalPathsAsDirty: newValue),
            );
          },
        ),
      ],
    );
  }

  Widget _buildEditableList(
    BuildContext context, {
    required String title,
    required Set<String> items,
    required ValueChanged<Set<String>> onListChanged,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Text(title, style: Theme.of(context).textTheme.titleSmall),
            const Spacer(),
            if (items.isNotEmpty)
              IconButton(
                icon: Icon(Icons.clear_all, color: Colors.red.shade300),
                tooltip: 'Clear all patterns',
                onPressed: () => onListChanged({}),
              ),
            IconButton(
              icon: const Icon(Icons.add),
              tooltip: 'Add new pattern',
              onPressed: () async {
                final newItem = await showTextInputDialog(
                  context,
                  title: 'Add New Pattern',
                );
                if (newItem != null && newItem.trim().isNotEmpty) {
                  onListChanged({...items, newItem.trim()});
                }
              },
            ),
          ],
        ),
        const Divider(),
        if (items.isEmpty)
          const Padding(
            padding: EdgeInsets.symmetric(vertical: 8.0),
            child: Text(
              'No patterns configured.',
              style: TextStyle(fontStyle: FontStyle.italic),
            ),
          ),
        Wrap(
          spacing: 8,
          runSpacing: 4,
          children: items.map((item) {
            return Chip(
              label: Text(item),
              onDeleted: () {
                final newItems = Set<String>.from(items)..remove(item);
                onListChanged(newItems);
              },
            );
          }).toList(),
        ),
      ],
    );
  }
}
// FILE: lib/editor/plugins/refactor_editor/refactor_editor_widget.dart


import 'dart:async';
import 'dart:convert';

import 'package:flutter/material.dart';

import 'package:collection/collection.dart';
import 'package:crypto/crypto.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:glob/glob.dart';
import 'package:path/path.dart' as p;

import '../../../app/app_notifier.dart';
import '../../../data/file_handler/file_handler.dart';
import '../../../data/repositories/project/project_repository.dart';
import '../../../logs/logs_provider.dart';
import '../../../project/services/project_hierarchy_service.dart';
import '../../../settings/settings_notifier.dart';
import '../../../utils/toast.dart';
import '../../models/editor_tab_models.dart';
import '../../services/editor_service.dart';
import '../../models/text_editing_capability.dart';
import '../../tab_metadata_notifier.dart';
import 'occurrence_list_item.dart';
import 'refactor_editor_controller.dart';
import 'refactor_editor_hot_state.dart';
import 'refactor_editor_models.dart';

import '../../../explorer/services/explorer_service.dart';
import '../../../widgets/dialogs/folder_picker_dialog.dart';

typedef _CompiledGlob = ({Glob glob, bool isDirectoryOnly});

class RefactorEditorWidget extends EditorWidget {
  @override
  final RefactorEditorTab tab;

  const RefactorEditorWidget({
    required GlobalKey<RefactorEditorWidgetState> key,
    required this.tab,
  }) : super(key: key, tab: tab);

  @override
  RefactorEditorWidgetState createState() => RefactorEditorWidgetState();
}

class RefactorEditorWidgetState extends EditorWidgetState<RefactorEditorWidget>
    with FileOperationEventListener {
  late final RefactorController _controller;
  late final TextEditingController _findController;
  late final TextEditingController _replaceController;

  static final _pathRegex = RegExp(r"""(['"])(.+?)\1""");

  @override
  void init() {
    _controller = RefactorController(initialState: widget.tab.initialState);
    _findController = TextEditingController(text: _controller.searchTerm);
    _replaceController = TextEditingController(text: _controller.replaceTerm);

    _controller.addListener(() {
      if (_findController.text != _controller.searchTerm) {
        _findController.text = _controller.searchTerm;
      }
      if (_replaceController.text != _controller.replaceTerm) {
        _replaceController.text = _controller.replaceTerm;
      }
    });

    _findController.addListener(
      () => _controller.updateSearchTerm(_findController.text),
    );
    _replaceController.addListener(
      () => _controller.updateReplaceTerm(_replaceController.text),
    );

    ref.read(explorerServiceProvider).addListener(this);
  }

  @override
  void dispose() {
    ref.read(explorerServiceProvider).removeListener(this);

    _findController.dispose();
    _replaceController.dispose();
    _controller.dispose();
    super.dispose();
  }

  @override
  Future<void> onFileOperation(FileOperationEvent event) async {
    if (!mounted) return;

    if (event is FileRenameEvent) {
      if (!event.newFile.isDirectory) {
        await _updateInternalPathsOnMove(event.oldFile, event.newFile);
      }
      await _promptForPathRefactor(event.oldFile, event.newFile);
    }
  }

  @override
  void onFirstFrameReady() {
    if (!widget.tab.onReady.isCompleted) {
      widget.tab.onReady.complete(this);
    }
  }

  Future<void> _updateInternalPathsOnMove(
    ProjectDocumentFile oldFile,
    ProjectDocumentFile newFile,
  ) async {
    if (!mounted) return;

    final project = ref.read(appNotifierProvider).value?.currentProject;
    final repo = ref.read(projectRepositoryProvider);
    final settings =
        ref.read(effectiveSettingsProvider).pluginSettings[RefactorSettings]
            as RefactorSettings?;
    final editorService = ref.read(editorServiceProvider);

    if (project == null || repo == null || settings == null) return;

    try {
      String content = await repo.readFile(newFile.uri);
      final oldPath = repo.fileHandler.getPathForDisplay(
        oldFile.uri,
        relativeTo: project.rootUri,
      );
      final newPath = repo.fileHandler.getPathForDisplay(
        newFile.uri,
        relativeTo: project.rootUri,
      );

      final oldDir = p.dirname(oldPath);
      final newDir = p.dirname(newPath);

      if (oldDir == newDir) return;

      final List<({String original, String replacement})> replacements = [];
      final List<ReplaceRangeEdit> edits =
          [];

      for (final match in _pathRegex.allMatches(content)) {
        final matchedPath = match.group(2);

        if (matchedPath == null ||
            matchedPath.isEmpty ||
            p.isAbsolute(matchedPath) ||
            matchedPath.contains(':')) {
          continue;
        }

        final absolutePath = p.normalize(p.join(oldDir, matchedPath));

        // NEW: VALIDATION STEP - Check if the resolved file actually exists.
        final targetFile = await repo.fileHandler.resolvePath(
          project.rootUri,
          absolutePath,
        );
        if (targetFile == null) {
          continue;
        }

        final newRelativePath = p
            .relative(absolutePath, from: newDir)
            .replaceAll(r'\', '/');

        if (matchedPath != newRelativePath) {
          replacements.add((
            original: matchedPath,
            replacement: newRelativePath,
          ));

          final lineInfo = _getLineAndColumn(
            content,
            match.start + 1,
          );
          edits.add(
            ReplaceRangeEdit(
              range: TextRange(
                start: TextPosition(
                  line: lineInfo.line,
                  column: lineInfo.column,
                ),
                end: TextPosition(
                  line: lineInfo.line,
                  column: lineInfo.column + matchedPath.length,
                ),
              ),
              replacement: newRelativePath,
            ),
          );
        }
      }

      if (replacements.isNotEmpty) {
        if (settings.updateInternalPathsAsDirty) {
          // STRATEGY 1: Open the file (or switch to it) and apply edits as dirty changes.
          await editorService.openAndApplyEdit(
            newPath, // Use the new path of the file
            BatchReplaceRangesEdit(edits: edits),
          );
          ref
              .read(talkerProvider)
              .info(
                'Applied internal path updates as dirty changes for: ${newFile.name}',
              );
        } else {
          replacements.sort(
            (a, b) => b.original.length.compareTo(a.original.length),
          );
          for (final change in replacements) {
            content = content.replaceAll(
              "'${change.original}'",
              "'${change.replacement}'",
            );
            content = content.replaceAll(
              '"${change.original}"',
              '"${change.replacement}"',
            );
          }
          await repo.writeFile(newFile, content);
          ref
              .read(talkerProvider)
              .info(
                'Auto-saved internal path updates for moved file: ${newFile.name}',
              );
        }
      }
    } catch (e, st) {
      ref
          .read(talkerProvider)
          .handle(
            e,
            st,
            'Failed to update internal paths for moved file: ${newFile.name}',
          );
    }
  }

  Future<void> _promptForPathRefactor(
    ProjectDocumentFile oldFile,
    ProjectDocumentFile newFile,
  ) async {
    if (!mounted) return;

    final repo = ref.read(projectRepositoryProvider);
    final project = ref.read(appNotifierProvider).value?.currentProject;
    if (repo == null || project == null || !mounted) return;

    final oldPath = repo.fileHandler.getPathForDisplay(
      oldFile.uri,
      relativeTo: project.rootUri,
    );
    final newPath = repo.fileHandler.getPathForDisplay(
      newFile.uri,
      relativeTo: project.rootUri,
    );

    final result = await showDialog<({String find, String replace})>(
      context: context,
      builder: (_) => _PathRefactorDialog(oldPath: oldPath, newPath: newPath),
    );

    if (!mounted) return;

    if (result != null) {
      _controller.setMode(RefactorMode.path);
      _controller.updateSearchTerm(result.find);
      _controller.updateReplaceTerm(result.replace);
    }
  }

  List<_CompiledGlob> _compileGlobs(Set<String> patterns) {
    return patterns.map((p) {
      final isDirOnly = p.endsWith('/');
      final cleanPattern = isDirOnly ? p.substring(0, p.length - 1) : p;
      return (glob: Glob(cleanPattern), isDirectoryOnly: isDirOnly);
    }).toList();
  }


  Future<void> _handleFindOccurrences() async {
    _controller.startSearch();
    try {
      if (_controller.mode == RefactorMode.path) {
        await _findPathOccurrences();
      } else {
        await _findTextOccurrences();
      }
    } catch (e, st) {
      ref.read(talkerProvider).handle(e, st, '[Refactor] Search failed');
      _controller.failSearch();
    }
  }

  Future<void> _handleApplyChanges() async {
    if (_controller.mode == RefactorMode.path) {
      await _applyPathChanges();
    } else {
      await _applyTextChanges();
    }
  }


  Future<void> _findTextOccurrences() async {
    final repo = ref.read(projectRepositoryProvider);
    final settings =
        ref.read(effectiveSettingsProvider).pluginSettings[RefactorSettings]
            as RefactorSettings?;
    final project = ref.read(appNotifierProvider).value?.currentProject;
    if (repo == null || settings == null || project == null) {
      throw Exception('Prerequisites not met');
    }

    final results = <RefactorOccurrence>[];
    await _traverseAndSearch(
      directoryUri: project.rootUri,
      onFileContent: (content, file, displayPath) {
        final fileContentHash = md5.convert(utf8.encode(content)).toString();
        results.addAll(
          _controller.searchInContent(
            content: content,
            fileUri: file.uri,
            displayPath: displayPath,
            fileContentHash: fileContentHash,
          ),
        );
      },
    );
    _controller.completeSearch(results);
  }

  String _getReplacementForMatch(Match match) {
    if (!_controller.replaceTerm.contains('\$')) {
      return _controller.replaceTerm;
    }
    return _controller.replaceTerm.replaceAllMapped(RegExp(r'\$(\d+)'), (
      placeholder,
    ) {
      final groupIndex = int.tryParse(placeholder.group(1) ?? '');
      if (groupIndex != null &&
          groupIndex > 0 &&
          groupIndex <= match.groupCount) {
        return match.group(groupIndex) ?? '';
      }
      return placeholder.group(
        0,
      )!;
    });
  }

  Future<void> _applyTextChanges() async {
    final List<RefactorResultItem> processedItems = [];
    final Map<RefactorResultItem, String> failedItems = {};
    final selected = _controller.selectedItems.toList();
    if (selected.isEmpty) return;

    final groupedByFile = selected.groupListsBy(
      (item) => item.occurrence.fileUri,
    );

    await _processFileGroups(
      groupedByFile: groupedByFile,
      generateEdits: (itemsInFile) {
        final List<ReplaceRangeEdit> lineEdits = [];

        // Group the selected items for this file by their line number.
        final groupedByLine = itemsInFile.groupListsBy(
          (item) => item.occurrence.lineNumber,
        );

        for (final lineEntry in groupedByLine.entries) {
          final lineNumber = lineEntry.key;
          final itemsOnLine = lineEntry.value;
          final originalLine = itemsOnLine.first.occurrence.lineContent;

          String newLineContent;

          if (_controller.isRegex) {
            final regex = RegExp(
              _controller.searchTerm,
              caseSensitive: _controller.isCaseSensitive,
            );
            final selectedColumns =
                itemsOnLine.map((item) => item.occurrence.startColumn).toSet();

            newLineContent = originalLine.replaceAllMapped(regex, (match) {
              if (selectedColumns.contains(match.start)) {
                return _getReplacementForMatch(match);
              }
              return match.group(0)!;
            });
          } else {
            newLineContent = originalLine;
            final sortedItems =
                itemsOnLine
                    .sortedBy<num>((item) => item.occurrence.startColumn)
                    .reversed;
            for (final item in sortedItems) {
              final occ = item.occurrence;
              newLineContent = newLineContent.replaceRange(
                occ.startColumn,
                occ.startColumn + occ.matchedText.length,
                _controller.replaceTerm,
              );
            }
          }

          lineEdits.add(
            ReplaceRangeEdit(
              range: TextRange(
                start: TextPosition(line: lineNumber, column: 0),
                end: TextPosition(
                  line: lineNumber,
                  column: originalLine.length,
                ),
              ),
              replacement: newLineContent,
            ),
          );
        }
        return lineEdits;
      },
      onSuccess: (items) => processedItems.addAll(items),
      onFailure:
          (items, reason) =>
              failedItems.addAll({for (var item in items) item: reason}),
    );

    _controller.updateItemsStatus(
      processed: processedItems,
      failed: failedItems,
    );
    final message =
        "Replaced ${processedItems.length} occurrences.${failedItems.isNotEmpty ? " ${failedItems.length} failed." : ""}";
    failedItems.isNotEmpty
        ? MachineToast.error(message)
        : MachineToast.info(message);
  }


  Future<void> _findPathOccurrences() async {
    final project = ref.read(appNotifierProvider).value?.currentProject;
    if (project == null) throw Exception('Project not available');

    final results = <RefactorOccurrence>[];
    final String searchTermAbsolute = p.normalize(_controller.searchTerm);

    await _traverseAndSearch(
      directoryUri: project.rootUri,
      onFileContent: (content, file, displayPath) {
        final fileContentHash = md5.convert(utf8.encode(content)).toString();
        final containingDir = p.dirname(displayPath);

        for (final match in _pathRegex.allMatches(content)) {
          final matchedPath = match.group(2);

          if (matchedPath == null ||
              matchedPath.isEmpty ||
              matchedPath.startsWith('dart:')) {
            continue;
          }
          if (Uri.tryParse(matchedPath)?.isAbsolute ?? false) continue;

          try {
            // The core logic: resolve the path relative to the file it was found in.
            final resolvedPath = p.normalize(
              p.join(containingDir, matchedPath),
            );

            if (resolvedPath == searchTermAbsolute) {
              final pathStartOffsetInContent =
                  match.start + match.group(0)!.indexOf(matchedPath);
              final lineInfo = _getLineAndColumn(
                content,
                pathStartOffsetInContent,
              );

              results.add(
                RefactorOccurrence(
                  fileUri: file.uri,
                  displayPath: displayPath,
                  lineNumber: lineInfo.line,
                  startColumn: lineInfo.column,
                  lineContent: content.split('\n')[lineInfo.line],
                  matchedText: matchedPath,
                  fileContentHash: fileContentHash,
                ),
              );
            }
          } catch (e) {
            /* Ignore path resolution errors for invalid paths */
          }
        }
      },
    );
    _controller.completeSearch(results);
  }

  ({int line, int column}) _getLineAndColumn(String content, int offset) {
    int line = 0;
    int lastLineStart = 0;
    for (int i = 0; i < offset; i++) {
      if (content[i] == '\n') {
        line++;
        lastLineStart = i + 1;
      }
    }
    return (line: line, column: offset - lastLineStart);
  }

  Future<void> _applyPathChanges() async {
    final List<RefactorResultItem> processedItems = [];
    final Map<RefactorResultItem, String> failedItems = {};
    final selected = _controller.selectedItems.toList();
    if (selected.isEmpty) return;

    final groupedByFile = selected.groupListsBy(
      (item) => item.occurrence.fileUri,
    );

    await _processFileGroups(
      groupedByFile: groupedByFile,
      generateEdits: (itemsInFile) {
        return itemsInFile.map((item) {
          final containingDir = p.dirname(item.occurrence.displayPath);
          final newRelativePath = p
              .relative(_controller.replaceTerm, from: containingDir)
              .replaceAll(r'\', '/');
          final occ = item.occurrence;

          return ReplaceRangeEdit(
            range: TextRange(
              start: TextPosition(
                line: occ.lineNumber,
                column: occ.startColumn,
              ),
              end: TextPosition(
                line: occ.lineNumber,
                column: occ.startColumn + occ.matchedText.length,
              ),
            ),
            replacement: newRelativePath,
          );
        }).toList();
      },
      onSuccess: (items) => processedItems.addAll(items),
      onFailure:
          (items, reason) =>
              failedItems.addAll({for (var item in items) item: reason}),
    );

    _controller.updateItemsStatus(
      processed: processedItems,
      failed: failedItems,
    );
    final message =
        "Updated ${processedItems.length} paths.${failedItems.isNotEmpty ? " ${failedItems.length} failed." : ""}";
    failedItems.isNotEmpty
        ? MachineToast.error(message)
        : MachineToast.info(message);
  }


  Future<void> _traverseAndSearch({
    required String directoryUri,
    required Function(
      String content,
      ProjectDocumentFile file,
      String displayPath,
    )
    onFileContent,
  }) async {
    final repo = ref.read(projectRepositoryProvider)!;
    final projectRootUri =
        ref.read(appNotifierProvider).value!.currentProject!.rootUri;
    final settings =
        ref.read(effectiveSettingsProvider).pluginSettings[RefactorSettings]
            as RefactorSettings;

    final hierarchyNotifier = ref.read(
      projectHierarchyServiceProvider.notifier,
    );
    var directoryState =
        ref.read(projectHierarchyServiceProvider)[directoryUri];
    if (directoryState == null || directoryState is! AsyncData) {
      await hierarchyNotifier.loadDirectory(directoryUri);
      directoryState = ref.read(projectHierarchyServiceProvider)[directoryUri];
    }
    final entries =
        directoryState?.valueOrNull?.map((node) => node.file).toList() ?? [];

    final globalIgnoreGlobs = _compileGlobs(settings.ignoredGlobPatterns);
    List<_CompiledGlob> currentIgnoreGlobs = [];
    final gitignoreFile = entries.firstWhereOrNull(
      (f) => f.name == '.gitignore',
    );
    if (gitignoreFile != null && settings.useProjectGitignore) {
      try {
        final content = await repo.readFile(gitignoreFile.uri);
        final patterns =
            content
                .split('\n')
                .map((l) => l.trim())
                .where((l) => l.isNotEmpty && !l.startsWith('#'))
                .toSet();
        currentIgnoreGlobs = _compileGlobs(patterns);
      } catch (_) {}
    }

    final List<Future<void>> subDirectoryFutures = [];

    for (final entry in entries) {
      final relativePath = repo.fileHandler
          .getPathForDisplay(entry.uri, relativeTo: projectRootUri)
          .replaceAll(r'\', '/');
      bool isIgnored = globalIgnoreGlobs.any(
        (g) =>
            !(g.isDirectoryOnly && !entry.isDirectory) &&
            g.glob.matches(relativePath),
      );
      if (isIgnored) continue;

      final pathFromCurrentDir = repo.fileHandler
          .getPathForDisplay(entry.uri, relativeTo: directoryUri)
          .replaceAll(r'\', '/');
      isIgnored = currentIgnoreGlobs.any(
        (g) =>
            !(g.isDirectoryOnly && !entry.isDirectory) &&
            g.glob.matches(pathFromCurrentDir),
      );
      if (isIgnored) continue;

      if (entry.isDirectory) {
        subDirectoryFutures.add(
          _traverseAndSearch(
            directoryUri: entry.uri,
            onFileContent: onFileContent,
          ),
        );
      } else {
        if (settings.supportedExtensions.any(
          (ext) => relativePath.endsWith(ext),
        )) {
          // File processing can happen immediately.
          try {
            final content = await repo.readFile(entry.uri);
            onFileContent(content, entry, relativePath);
          } catch (e) {
          }
        }
      }
    }

    await Future.wait(subDirectoryFutures);
  }

  Future<void> _processFileGroups({
    required Map<String, List<RefactorResultItem>> groupedByFile,
    required List<ReplaceRangeEdit> Function(
      List<RefactorResultItem> itemsInFile,
    )
    generateEdits,
    required void Function(List<RefactorResultItem> items) onSuccess,
    required void Function(List<RefactorResultItem> items, String reason)
    onFailure,
  }) async {
    final repo = ref.read(projectRepositoryProvider)!;
    final editorService = ref.read(editorServiceProvider);
    final project = ref.read(appNotifierProvider).value!.currentProject!;
    final metadataMap = ref.read(tabMetadataProvider);
    final openTabsByUri = {
      for (var tab in project.session.tabs) metadataMap[tab.id]!.file.uri: tab,
    };

    for (final entry in groupedByFile.entries) {
      final fileUri = entry.key;
      final itemsInFile = entry.value;
      final originalHash = itemsInFile.first.occurrence.fileContentHash;
      final openTab = openTabsByUri[fileUri];

      if (openTab != null) {
        final editorState = await openTab.onReady.future;
        final metadata = metadataMap[openTab.id];
        if (editorState is! TextEditable) {
          onFailure(itemsInFile, "Editor not text-editable.");
          continue;
        }
        if (metadata?.isDirty ?? true) {
          onFailure(itemsInFile, "File has unsaved changes.");
          continue;
        }
        final editableState = editorState as TextEditable;
        final currentContent = await editableState.getTextContent();
        if (md5.convert(utf8.encode(currentContent)).toString() !=
            originalHash) {
          onFailure(itemsInFile, "File content changed.");
          continue;
        }

        final edits = generateEdits(itemsInFile);
        if (edits.length != itemsInFile.length) {
          onFailure(itemsInFile, "Could not generate all edits.");
          continue;
        }

        editableState.batchReplaceRanges(edits);
        editorService.markCurrentTabDirty();
        onSuccess(itemsInFile);
      } else {
        try {
          final currentContent = await repo.readFile(fileUri);
          if (md5.convert(utf8.encode(currentContent)).toString() !=
              originalHash) {
            onFailure(itemsInFile, "File modified externally.");
            continue;
          }

          final edits = generateEdits(itemsInFile);
          if (edits.length != itemsInFile.length) {
            onFailure(itemsInFile, "Could not generate all edits.");
            continue;
          }

          if (_controller.autoOpenFiles) {
            final success = await editorService.openAndApplyEdit(
              itemsInFile.first.occurrence.displayPath,
              BatchReplaceRangesEdit(edits: edits),
            );
            if (success) {
              onSuccess(itemsInFile);
            } else {
              onFailure(itemsInFile, "Failed to open and apply edits.");
            }
          } else {
            final lines = currentContent.split('\n');
            edits.sort((a, b) {
              final lineCmp = b.range.start.line.compareTo(a.range.start.line);
              if (lineCmp != 0) return lineCmp;
              return b.range.start.column.compareTo(a.range.start.column);
            });
            for (final edit in edits) {
              lines[edit.range.start.line] = lines[edit.range.start.line]
                  .replaceRange(
                    edit.range.start.column,
                    edit.range.end.column,
                    edit.replacement,
                  );
            }
            final fileMeta = await repo.getFileMetadata(fileUri);
            if (fileMeta == null) throw Exception("File not found");
            await repo.writeFile(fileMeta, lines.join('\n'));
            onSuccess(itemsInFile);
          }
        } catch (e) {
          onFailure(itemsInFile, e.toString());
        }
      }
    }
  }


  @override
  Widget build(BuildContext context) {
    return ListenableBuilder(
      listenable: _controller,
      builder: (context, child) {
        return Column(
          children: [
            Expanded(
              child: CustomScrollView(
                slivers: [
                  SliverToBoxAdapter(child: _buildInputPanel()),
                  if (_controller.searchStatus == SearchStatus.searching)
                    const SliverToBoxAdapter(child: LinearProgressIndicator()),
                  _buildResultsSliver(),
                ],
              ),
            ),
            _buildActionPanel(),
          ],
        );
      },
    );
  }

  Widget _buildInputPanel() {
    final isPathMode = _controller.mode == RefactorMode.path;
    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: Column(
        children: [
          Row(
            children: [
              Expanded(
                child: TextField(
                  controller: _findController,
                  decoration: InputDecoration(
                    labelText: 'Find',
                    border: const OutlineInputBorder(),
                    suffixIcon:
                        isPathMode
                            ? IconButton(
                              icon: const Icon(Icons.folder_open_outlined),
                              tooltip: 'Select File or Folder',
                              onPressed: () async {
                                final selectedPath = await showDialog<String>(
                                  context: context,
                                  builder:
                                      (_) => const FileOrFolderPickerDialog(),
                                );
                                if (selectedPath != null) {
                                  _controller.updateSearchTerm(selectedPath);
                                }
                              },
                            )
                            : null,
                  ),
                  onSubmitted: (_) => _handleFindOccurrences(),
                ),
              ),
              const SizedBox(width: 8),
              ElevatedButton(
                onPressed:
                    _controller.searchStatus == SearchStatus.searching
                        ? null
                        : _handleFindOccurrences,
                child: const Text('Find All'),
              ),
            ],
          ),
          const SizedBox(height: 8),
          TextField(
            controller: _replaceController,
            decoration: const InputDecoration(
              labelText: 'Replace (use \$1, \$2 for groups)',
              border: OutlineInputBorder(),
            ),
          ),
          const SizedBox(height: 8),
          SegmentedButton<RefactorMode>(
            segments: const [
              ButtonSegment(
                value: RefactorMode.text,
                icon: Icon(Icons.text_fields),
                label: Text('Text'),
              ),
              ButtonSegment(
                value: RefactorMode.path,
                icon: Icon(Icons.drive_file_move_rtl_outlined),
                label: Text('Path'),
              ),
            ],
            selected: {_controller.mode},
            onSelectionChanged: (newSelection) {
              _controller.setMode(newSelection.first);
            },
          ),
          const SizedBox(height: 4),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              _OptionCheckbox(
                label: 'Use Regex',
                value: isPathMode ? false : _controller.isRegex,
                onChanged:
                    isPathMode
                        ? null
                        : (val) => _controller.toggleIsRegex(val ?? false),
              ),
              _OptionCheckbox(
                label: 'Case Sensitive',
                value: isPathMode ? true : _controller.isCaseSensitive,
                onChanged:
                    isPathMode
                        ? null
                        : (val) =>
                            _controller.toggleCaseSensitive(val ?? false),
              ),
            ],
          ),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              _OptionCheckbox(
                label: 'Auto-open files',
                value: _controller.autoOpenFiles,
                onChanged:
                    (val) => _controller.toggleAutoOpenFiles(val ?? false),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildResultsSliver() {
    if (_controller.searchStatus == SearchStatus.idle) {
      return SliverFillRemaining(
        child: Center(
          child: Text(
            _controller.mode == RefactorMode.path
                ? 'Enter a project-relative path to find all its references.'
                : 'Enter a search term and click "Find All"',
          ),
        ),
      );
    }
    if (_controller.searchStatus == SearchStatus.error) {
      return const SliverFillRemaining(
        child: Center(
          child: Text(
            'An error occurred during search.',
            style: TextStyle(color: Colors.red),
          ),
        ),
      );
    }
    if (_controller.searchStatus == SearchStatus.complete &&
        _controller.resultItems.isEmpty) {
      return SliverFillRemaining(
        child: Center(
          child: Text('No results found for "${_controller.searchTerm}"'),
        ),
      );
    }

    final groupedItems = _controller.resultItems.groupListsBy(
      (item) => item.occurrence.fileUri,
    );

    final pendingItems = _controller.resultItems.where(
      (i) => i.status == ResultStatus.pending,
    );
    final allSelected =
        pendingItems.isNotEmpty &&
        _controller.selectedItems.length == pendingItems.length;

    return SliverPadding(
      padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
      sliver: SliverList(
        delegate: SliverChildBuilderDelegate((context, index) {
          if (index == 0) {
            return Padding(
              padding: const EdgeInsets.fromLTRB(8.0, 8.0, 8.0, 12.0),
              child: Row(
                children: [
                  Text(
                    '${_controller.resultItems.length} results found in ${groupedItems.length} files.',
                  ),
                  const Spacer(),
                  const Text('Select All'),
                  Checkbox(
                    value: allSelected,
                    tristate:
                        !allSelected && _controller.selectedItems.isNotEmpty,
                    onChanged:
                        (val) => _controller.toggleSelectAll(val ?? false),
                  ),
                ],
              ),
            );
          }

          final groupIndex = index - 1;
          final fileUri = groupedItems.keys.elementAt(groupIndex);
          final itemsInFile = groupedItems[fileUri]!;

          return _FileResultCard(
            key: ValueKey(fileUri),
            itemsInFile: itemsInFile,
            controller: _controller,
          );
        }, childCount: groupedItems.length + 1),
      ),
    );
  }

  Widget _buildActionPanel() {
    final canApply = _controller.selectedItems.isNotEmpty;
    return Container(
      padding: const EdgeInsets.all(8.0),
      decoration: BoxDecoration(
        color: Theme.of(context).bottomAppBarTheme.color,
        border: Border(top: BorderSide(color: Theme.of(context).dividerColor)),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          ElevatedButton(
            onPressed: canApply ? _handleApplyChanges : null,
            child: Text('Replace ${_controller.selectedItems.length} selected'),
          ),
        ],
      ),
    );
  }

  @override
  Future<TabHotStateDto?> serializeHotState() async {
    return RefactorEditorHotStateDto(
      searchTerm: _controller.searchTerm,
      replaceTerm: _controller.replaceTerm,
      isRegex: _controller.isRegex,
      isCaseSensitive: _controller.isCaseSensitive,
      autoOpenFiles: _controller.autoOpenFiles,
      mode: _controller.mode,
    );
  }

  @override
  Future<EditorContent> getContent() async => EditorContentString('{}');
  @override
  void redo() {}
  @override
  void syncCommandContext() {}
  @override
  void undo() {}
  @override
  void onSaveSuccess(String newHash) {}
}

class _OptionCheckbox extends StatelessWidget {
  final String label;
  final bool value;
  final ValueChanged<bool?>? onChanged;
  const _OptionCheckbox({
    required this.label,
    required this.value,
    required this.onChanged,
  });
  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [Checkbox(value: value, onChanged: onChanged), Text(label)],
    );
  }
}

class _PathRefactorDialog extends StatelessWidget {
  final String oldPath;
  final String newPath;

  const _PathRefactorDialog({required this.oldPath, required this.newPath});

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Update Path References?'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'A file or folder was moved. Do you want to find and update all references to it?',
          ),
          const SizedBox(height: 16),
          Text('From:', style: Theme.of(context).textTheme.bodySmall),
          Text(oldPath, style: const TextStyle(fontFamily: 'monospace')),
          const SizedBox(height: 8),
          Text('To:', style: Theme.of(context).textTheme.bodySmall),
          Text(newPath, style: const TextStyle(fontFamily: 'monospace')),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        FilledButton(
          onPressed:
              () =>
                  Navigator.of(context).pop((find: oldPath, replace: newPath)),
          child: const Text('Update References'),
        ),
      ],
    );
  }
}

class _FileResultCard extends ConsumerStatefulWidget {
  final List<RefactorResultItem> itemsInFile;
  final RefactorController controller;

  const _FileResultCard({
    super.key,
    required this.itemsInFile,
    required this.controller,
  });

  @override
  ConsumerState<_FileResultCard> createState() => _FileResultCardState();
}

class _FileResultCardState extends ConsumerState<_FileResultCard> {
  bool _isFolded = false;

  List<Widget> _buildPathSegments(String path, BuildContext context) {
    final theme = Theme.of(context);
    final List<Widget> pathWidgets = [];
    final segments = path.split('/');

    final baseStyle = theme.textTheme.titleSmall;
    final normalColor = baseStyle?.color?.withValues(alpha: 0.9);
    final darkerColor =
        normalColor != null ? Color.lerp(normalColor, Colors.black, 0.1) : null;
    final separatorStyle = baseStyle?.copyWith(color: theme.dividerColor);

    for (int i = 0; i < segments.length; i++) {
      final segment = segments[i];
      final color = i % 2 == 0 ? normalColor : darkerColor;

      pathWidgets.add(
        Text(
          segment,
          style: baseStyle?.copyWith(color: color, fontWeight: FontWeight.bold),
        ),
      );

      if (i < segments.length - 1) {
        pathWidgets.add(Text(' / ', style: separatorStyle));
      }
    }
    return pathWidgets;
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final fileUri = widget.itemsInFile.first.occurrence.fileUri;
    final displayPath = widget.itemsInFile.first.occurrence.displayPath;

    final pendingInFile =
        widget.itemsInFile
            .where((i) => i.status == ResultStatus.pending)
            .toList();
    final selectedInFileCount =
        widget.controller.selectedItems
            .where((i) => i.occurrence.fileUri == fileUri)
            .length;
    final isFileChecked =
        pendingInFile.isNotEmpty && selectedInFileCount == pendingInFile.length;
    final isFileTristate =
        selectedInFileCount > 0 && selectedInFileCount < pendingInFile.length;

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 4.0),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: BorderRadius.circular(8.0),
        border: Border.all(color: theme.dividerColor.withValues(alpha: 0.5)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            padding: const EdgeInsets.only(
              left: 4.0,
              right: 8.0,
              top: 4.0,
              bottom: 4.0,
            ),
            decoration: BoxDecoration(
              color: theme.colorScheme.onSurface.withValues(alpha: 0.05),
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(8.0),
                topRight: Radius.circular(8.0),
              ),
            ),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                Checkbox(
                  visualDensity: VisualDensity.compact,
                  value: isFileChecked,
                  tristate: isFileTristate,
                  onChanged:
                      (val) => widget.controller.toggleSelectAllForFile(
                        fileUri,
                        val ?? false,
                      ),
                ),
                Flexible(
                  child: Wrap(
                    crossAxisAlignment: WrapCrossAlignment.center,
                    children: _buildPathSegments(displayPath, context),
                  ),
                ),
                const SizedBox(width: 8),
                Text(
                  '(${widget.itemsInFile.length})',
                  style: theme.textTheme.bodySmall,
                ),
                IconButton(
                  visualDensity: VisualDensity.compact,
                  icon: Icon(
                    _isFolded ? Icons.unfold_more : Icons.unfold_less,
                    size: 20,
                  ),
                  tooltip: _isFolded ? 'Unfold Results' : 'Fold Results',
                  onPressed: () => setState(() => _isFolded = !_isFolded),
                ),
              ],
            ),
          ),
          AnimatedSize(
            duration: const Duration(milliseconds: 200),
            curve: Curves.easeInOut,
            child:
                _isFolded
                    ? const SizedBox(width: double.infinity)
                    : Column(
                      children:
                          widget.itemsInFile.map((item) {
                            return OccurrenceListItem(
                              item: item,
                              isSelected: widget.controller.selectedItems
                                  .contains(item),
                              onSelected:
                                  (_) => widget.controller.toggleItemSelection(
                                    item,
                                  ),
                              onJumpTo: () async {
                                final occurrence = item.occurrence;
                                final edit = RevealRangeEdit(
                                  range: TextRange(
                                    start: TextPosition(
                                      line: occurrence.lineNumber,
                                      column: occurrence.startColumn,
                                    ),
                                    end: TextPosition(
                                      line: occurrence.lineNumber,
                                      column:
                                          occurrence.startColumn +
                                          occurrence.matchedText.length,
                                    ),
                                  ),
                                );
                                await ref
                                    .read(editorServiceProvider)
                                    .openAndApplyEdit(
                                      occurrence.displayPath,
                                      edit,
                                    );
                              },
                            );
                          }).toList(),
                    ),
          ),
        ],
      ),
    );
  }
}

// FILE: lib/editor/plugins/termux_terminal/termux_hot_state.dart

// FILE: lib/editor/plugins/termux_terminal/termux_hot_state.dart

import 'package:flutter/foundation.dart';
import '../../../../data/dto/tab_hot_state_dto.dart';

@immutable
class TermuxHotStateDto extends TabHotStateDto {
  final String workingDirectory;
  final String terminalHistory;

  const TermuxHotStateDto({
    required this.workingDirectory,
    this.terminalHistory = '',
    super.baseContentHash,
  });
}
// FILE: lib/editor/plugins/termux_terminal/termux_hot_state_adapter.dart

// FILE: lib/editor/plugins/termux_terminal/termux_hot_state_adapter.dart

import '../../../../data/cache/type_adapters.dart';
import 'termux_hot_state.dart';

class TermuxHotStateAdapter implements TypeAdapter<TermuxHotStateDto> {
  static const String _wdKey = 'workingDirectory';
  static const String _historyKey = 'terminalHistory';
  static const String _hashKey = 'baseContentHash';

  @override
  TermuxHotStateDto fromJson(Map<String, dynamic> json) {
    return TermuxHotStateDto(
      workingDirectory: json[_wdKey] as String? ?? '~',
      terminalHistory: json[_historyKey] as String? ?? '',
      baseContentHash: json[_hashKey] as String?,
    );
  }

  @override
  Map<String, dynamic> toJson(TermuxHotStateDto object) {
    return {
      _wdKey: object.workingDirectory,
      _historyKey: object.terminalHistory,
      _hashKey: object.baseContentHash,
    };
  }
}
// FILE: lib/editor/plugins/termux_terminal/termux_terminal_models.dart

// FILE: lib/editor/plugins/termux_terminal/termux_terminal_models.dart

import 'package:flutter/material.dart';
import '../../models/editor_tab_models.dart';
import '../../models/editor_plugin_models.dart';
import 'widgets/termux_terminal_widget.dart';

abstract class TermuxTerminalWidgetState extends EditorWidgetState<TermuxTerminalWidget> {
  void sendRawInput(String data);
}

@immutable
class TermuxTerminalTab extends EditorTab {
  @override
  final GlobalKey<TermuxTerminalWidgetState> editorKey;

  final String initialWorkingDirectory;
  final String? initialHistory;

  TermuxTerminalTab({
    required super.plugin,
    required this.initialWorkingDirectory,
    this.initialHistory,
    super.id,
    super.onReadyCompleter,
  }) : editorKey = GlobalKey<TermuxTerminalWidgetState>();

  @override
  void dispose() {}
}

class TermuxTerminalSettings extends PluginSettings {
  double fontSize;
  String fontFamily;
  String termuxWorkDir;
  String shellCommand;
  bool useDarkTheme;

  TermuxTerminalSettings({
    this.fontSize = 14.0,
    this.fontFamily = 'JetBrainsMono',
    this.termuxWorkDir = '/data/data/com.termux/files/home',
    this.shellCommand = 'bash',
    this.useDarkTheme = true,
  });

  @override
  Map<String, dynamic> toJson() => {
        'fontSize': fontSize,
        'fontFamily': fontFamily,
        'termuxWorkDir': termuxWorkDir,
        'shellCommand': shellCommand,
        'useDarkTheme': useDarkTheme,
      };

  @override
  void fromJson(Map<String, dynamic> json) {
    fontSize = (json['fontSize'] as num?)?.toDouble() ?? 14.0;
    fontFamily = json['fontFamily'] as String? ?? 'JetBrainsMono';
    termuxWorkDir = json['termuxWorkDir'] as String? ?? '/data/data/com.termux/files/home';
    shellCommand = json['shellCommand'] as String? ?? 'bash';
    useDarkTheme = json['useDarkTheme'] as bool? ?? true;
  }

  TermuxTerminalSettings copyWith({
    double? fontSize,
    String? fontFamily,
    String? termuxWorkDir,
    String? shellCommand,
    bool? useDarkTheme,
  }) {
    return TermuxTerminalSettings(
      fontSize: fontSize ?? this.fontSize,
      fontFamily: fontFamily ?? this.fontFamily,
      termuxWorkDir: termuxWorkDir ?? this.termuxWorkDir,
      shellCommand: shellCommand ?? this.shellCommand,
      useDarkTheme: useDarkTheme ?? this.useDarkTheme,
    );
  }

  @override
  MachineSettings clone() {
    return copyWith();
  }
}
// FILE: lib/editor/plugins/termux_terminal/termux_terminal_plugin.dart

// FILE: lib/editor/plugins/termux_terminal/termux_terminal_plugin.dart
// (Additions to the file from the previous phases)

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../app/app_notifier.dart';
import '../../../command/command_models.dart';
import '../../../project/project_models.dart';

import '../../models/editor_plugin_models.dart';
import '../../models/editor_tab_models.dart';
import '../../../data/file_handler/file_handler.dart';
import '../../../data/cache/type_adapters.dart';
import '../../../data/dto/tab_hot_state_dto.dart';

import 'termux_terminal_models.dart';
import 'termux_hot_state.dart';
import 'termux_hot_state_adapter.dart';
import 'widgets/termux_terminal_widget.dart';
import 'widgets/termux_toolbar.dart';
import 'widgets/termux_settings_widget.dart';


class TermuxTerminalPlugin extends EditorPlugin {
  static const String pluginId = 'com.machine.termux_terminal';
  static const String hotStateId = 'com.machine.termux_terminal_state';

  static const CommandPosition termuxToolbar = CommandPosition(
    id: 'com.machine.termux_terminal.toolbar',
    label: 'Termux Toolbar',
    icon: Icons.build_circle_outlined,
  );

  @override
  String get id => pluginId;

  @override
  String get name => 'Termux Console';

  @override
  Widget get icon => const Icon(Icons.terminal);

  @override
  int get priority => 50;

  @override
  final PluginSettings settings = TermuxTerminalSettings();

  @override
  PluginDataRequirement get dataRequirement => PluginDataRequirement.string;

  @override
  String? get hotStateDtoType => hotStateId;

  @override
  Type? get hotStateDtoRuntimeType => TermuxHotStateDto;

  @override
  TypeAdapter<TabHotStateDto>? get hotStateAdapter => TermuxHotStateAdapter();

  @override
  List<CommandPosition> getCommandPositions() {
    return [termuxToolbar];
  }

  @override
  List<Command> getAppCommands() {
    return [
      BaseCommand(
        id: 'open_termux_terminal',
        label: 'New Terminal',
        icon: const Icon(Icons.terminal),
          sourcePlugin: 'App',
        defaultPositions: [AppCommandPositions.appBar],
        canExecute: (ref) {
          final project = ref.watch(appNotifierProvider).value?.currentProject;
          return project != null;
        },
        execute: (ref) async {
          final notifier = ref.read(appNotifierProvider.notifier);
          
          // Create a virtual file to represent this terminal session.
          final terminalFile = VirtualDocumentFile(
            uri: 'termux-session:
            name: 'Termux Session',
          );

          // Open the virtual file, explicitly telling the editor service
          await notifier.openFileInEditor(
            terminalFile,
            explicitPlugin: this,
          );
        },
      ),
    ];
  }


  @override
  bool supportsFile(DocumentFile file) {
    return file.name.endsWith('.termux') || file.name == 'Termux Session';
  }

  @override
  Future<EditorTab> createTab(
    DocumentFile file,
    EditorInitData initData, {
    String? id,
    Completer<EditorWidgetState>? onReadyCompleter,
  }) async {
    String workingDir = '/data/data/com.termux/files/home';
    String? history;

    if (initData.hotState is TermuxHotStateDto) {
      final state = initData.hotState as TermuxHotStateDto;
      workingDir = state.workingDirectory;
      history = state.terminalHistory;
    }

    return TermuxTerminalTab(
      plugin: this,
      initialWorkingDirectory: workingDir,
      initialHistory: history,
      id: id,
      onReadyCompleter: onReadyCompleter,
    );
  }

  @override
  EditorWidget buildEditor(EditorTab tab, WidgetRef ref) {
    return TermuxTerminalWidget(
      key: (tab as TermuxTerminalTab).editorKey, 
      tab: tab
    );
  }

  @override
  Widget buildToolbar(WidgetRef ref) {
    return const TermuxTerminalToolbar();
  }
  
  @override
  Widget buildSettingsUI(
    PluginSettings settings,
    void Function(PluginSettings) onChanged,
  ) {
    return TermuxSettingsWidget(
      settings: settings as TermuxTerminalSettings,
      onChanged: (newSettings) => onChanged(newSettings as PluginSettings),
    );
  }
}
// FILE: lib/editor/plugins/termux_terminal/services/termux_bridge_service.dart

// FILE: lib/editor/plugins/termux_terminal/services/termux_bridge_service.dart

import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:android_intent_plus/android_intent.dart';
import 'package:android_intent_plus/flag.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final termuxBridgeServiceProvider = Provider.autoDispose<TermuxBridgeService>((ref) {
  final service = TermuxBridgeService();
  ref.onDispose(() => service.dispose());
  return service;
});

class TermuxBridgeService {
  ServerSocket? _serverSocket;
  final StreamController<String> _outputController = StreamController.broadcast();
  
  Stream<String> get outputStream => _outputController.stream;

  int? get port => _serverSocket?.port;

  bool get isListening => _serverSocket != null;

  Future<void> initialize() async {
    if (_serverSocket != null) return;

    try {
      _serverSocket = await ServerSocket.bind(InternetAddress.loopbackIPv4, 0);
      debugPrint('TermuxBridge: Bridge Server listening on port ${_serverSocket!.port}');

      _serverSocket!.listen(
        (Socket client) {
          _handleClientConnection(client);
        },
        onError: (e) {
          _addToOutput('Bridge Server Error: $e\r\n');
        },
      );
    } catch (e) {
      _addToOutput('Failed to start Bridge Server: $e\r\n');
    }
  }

  void _handleClientConnection(Socket client) {
    client.listen(
      (Uint8List data) {
        try {
          final result = utf8.decode(data, allowMalformed: true);
          _addToOutput(result);
        } catch (e) {
          _addToOutput('\r\n[Bridge Decode Error]\r\n');
        }
      },
      onError: (e) => _addToOutput('\r\n[Bridge Socket Error: $e]\r\n'),
      onDone: () {
        client.close();
      },
    );
  }

  Future<void> executeCommand({
    required String command,
    required String workingDirectory,
    String shell = 'bash',
  }) async {
    if (_serverSocket == null) {
      await initialize();
      if (_serverSocket == null) {
        _addToOutput('\r\n[Error: Could not initialize bridge socket]\r\n');
        return;
      }
    }

    final int targetPort = _serverSocket!.port;
    
    final String bridgeCommand = 
        '{ $command; } 2>&1 | nc 127.0.0.1 $targetPort';

    const String runCommandAction = 'com.termux.RUN_COMMAND';
    const String extraPath = 'com.termux.RUN_COMMAND_PATH';
    const String extraArguments = 'com.termux.RUN_COMMAND_ARGUMENTS';
    const String extraWorkDir = 'com.termux.RUN_COMMAND_WORKDIR';
    const String extraBackground = 'com.termux.RUN_COMMAND_BACKGROUND';
    const String extraSessionAction = 'com.termux.RUN_COMMAND_SESSION_ACTION';

    final intent = AndroidIntent(
      action: runCommandAction,
      package: 'com.termux',
      arguments: <String, dynamic>{
        extraPath: '/data/data/com.termux/files/usr/bin/$shell',
        extraArguments: <String>['-c', bridgeCommand],
        extraWorkDir: workingDirectory,
        extraBackground: true,
        extraSessionAction: '0',
      },
      flags: <int>[Flag.FLAG_INCLUDE_STOPPED_PACKAGES], 
    );

    try {
      debugPrint('TermuxBridge: Launching intent for: $command');
      await intent.launch();
    } catch (e) {
      _addToOutput('\r\n[Error launching Termux intent: $e]\r\n');
      _addToOutput('Ensure Termux is installed and the "Run Command" permission is granted.\r\n');
    }
  }

  void _addToOutput(String text) {
    if (!_outputController.isClosed) {
      _outputController.add(text);
    }
  }

  void clearBuffer() {
  }

  Future<void> dispose() async {
    await _serverSocket?.close();
    await _outputController.close();
    _serverSocket = null;
  }
}
// FILE: lib/editor/services/editor_service.dart

import 'dart:async';
import 'dart:convert';

import 'package:flutter/material.dart';

import 'package:collection/collection.dart';
import 'package:crypto/crypto.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../app/app_notifier.dart';
import '../../data/dto/project_dto.dart';
import '../../data/repositories/project/project_repository.dart';
import '../../widgets/dialogs/file_explorer_dialogs.dart';
import '../../widgets/dialogs/save_as_dialog.dart';
import '../../explorer/services/explorer_service.dart';
import '../../logs/logs_provider.dart';
import '../../project/project_models.dart';
import '../../utils/toast.dart';
import '../models/editor_tab_models.dart';
import '../plugins/editor_plugin_registry.dart';
import '../tab_metadata_notifier.dart';
import '../../data/content_provider/file_content_provider.dart';
import '../models/text_editing_capability.dart';
import '../../data/cache/hot_state_cache_service.dart';

import '../../data/file_handler/file_handler.dart'
    show DocumentFile, ProjectDocumentFile;

final editorServiceProvider = Provider<EditorService>((ref) {
  return EditorService(ref);
});

class EditorService {
  final Ref _ref;
  EditorService(this._ref);

  Project? get _currentProject =>
      _ref.read(appNotifierProvider).value?.currentProject;
  EditorTab? get _currentTab => _currentProject?.session.currentTab;

  ProjectRepository get _repo {
    final repo = _ref.read(projectRepositoryProvider);
    if (repo == null) {
      throw StateError('ProjectRepository is not available.');
    }
    return repo;
  }

  FileContentProviderRegistry get _contentProviderRegistry =>
      _ref.read(fileContentProviderRegistryProvider);

  Future<TabSessionState> rehydrateTabSession(
    ProjectDto dto,
    ProjectMetadata projectMetadata,
  ) async {
    final plugins = _ref.read(activePluginsProvider);
    final metadataNotifier = _ref.read(tabMetadataProvider.notifier);
    final hotStateCacheService = _ref.read(hotStateCacheServiceProvider);
    final talker = _ref.read(talkerProvider);

    final List<EditorTab> rehydratedTabs = [];
    talker.info("Rehydrating tabs");

    for (final tabDto in dto.session.tabs) {
      final tabId = tabDto.id;
      final pluginId = tabDto.pluginType;
      final persistedMetadata = dto.session.tabMetadata[tabId];

      if (persistedMetadata == null) continue;

      final plugin = plugins.firstWhereOrNull((p) => p.id == pluginId);
      if (plugin == null) continue;

      try {
        final file = await _contentProviderRegistry.rehydrateFileFromDto(
          persistedMetadata,
        );

        if (file == null) continue;

        final contentProvider = _contentProviderRegistry.getProviderFor(file);

        final currentContentResult = await contentProvider.getContent(
          file,
          plugin.dataRequirement,
        );
        final currentDiskHash = currentContentResult.baseContentHash;

        TabHotStateDto? cachedDto = await hotStateCacheService.getTabState(
          projectMetadata.id,
          tabId,
        );

        if (cachedDto != null && cachedDto.baseContentHash != currentDiskHash) {
          talker.warning(
            'Cache conflict detected for ${file.name}. '
            'Cached Hash: ${cachedDto.baseContentHash}, '
            'Disk Hash: $currentDiskHash',
          );
          final context = _ref.read(navigatorKeyProvider).currentContext;
          if (context != null) {
            final resolution = await showCacheConflictDialog(
              context,
              fileName: file.name,
            );
            if (resolution == CacheConflictResolution.loadDisk) {
              talker.info('User chose to discard cache for ${file.name}.');
              await hotStateCacheService.clearTabState(
                projectMetadata.id,
                tabId,
              );
              cachedDto = null;
            }
          }
        }

        final initData = EditorInitData(
          initialContent: currentContentResult.content,
          hotState: cachedDto,
          baseContentHash: currentDiskHash,
        );

        final newTab = await plugin.createTab(file, initData, id: tabId);

        metadataNotifier.initTab(newTab.id, file);
        rehydratedTabs.add(newTab);
      } catch (e, st) {
        _ref
            .read(talkerProvider)
            .handle(
              e,
              st,
              'Could not restore tab for ${persistedMetadata.fileUri}',
            );
      }
    }

    return TabSessionState(
      tabs: rehydratedTabs,
      currentTabIndex: dto.session.currentTabIndex,
    );
  }

  Future<void> updateAndCacheDirtyTab(Project project, EditorTab tab) async {
    final hotStateCacheService = _ref.read(hotStateCacheServiceProvider);
    final metadata = _ref.read(tabMetadataProvider)[tab.id];

    if (metadata != null && metadata.isDirty) {
      final hotStateDto = await tab.editorKey.currentState?.serializeHotState();
      if (hotStateDto != null) {
        hotStateCacheService.updateTabState(project.id, tab.id, hotStateDto);
      }
    }
  }

  Future<void> flushAllHotTabs() async {
    final hotStateCacheService = _ref.read(hotStateCacheServiceProvider);
    await hotStateCacheService.flush();
  }

  void markCurrentTabDirty() {
    final tabId = _currentTab?.id;
    if (tabId != null) {
      _ref.read(tabMetadataProvider.notifier).markDirty(tabId);
    }
  }

  void markCurrentTabClean() {
    final tabId = _currentTab?.id;
    if (tabId != null) {
      _ref.read(tabMetadataProvider.notifier).markClean(tabId);
    }
  }

  void updateCurrentTabModel(EditorTab newTabModel) {
    final project = _currentProject;
    if (project == null) return;
    final newTabs = List<EditorTab>.from(project.session.tabs);
    newTabs[project.session.currentTabIndex] = newTabModel;
    final newProject = project.copyWith(
      session: project.session.copyWith(tabs: newTabs),
    );
    _ref.read(appNotifierProvider.notifier).updateCurrentProject(newProject);
  }

  void setBottomToolbarOverride(Widget? widget) {
    _ref.read(appNotifierProvider.notifier).setBottomToolbarOverride(widget);
  }

  void clearBottomToolbarOverride() {
    _ref.read(appNotifierProvider.notifier).clearBottomToolbarOverride();
  }

  Future<void> saveCurrentTabAs() async {
    final project = _currentProject;
    final tab = _currentTab;
    if (project == null || tab == null) return;

    final editorState = tab.editorKey.currentState;
    final metadata = _ref.read(tabMetadataProvider)[tab.id];
    if (editorState == null || metadata == null) return;

    final context = _ref.read(navigatorKeyProvider).currentContext;
    if (context == null || !context.mounted) return;

    try {
      final editorContent = await editorState.getContent();
      final result = await showDialog<SaveAsDialogResult>(
        context: context,
        builder: (_) => SaveAsDialog(initialFileName: metadata.file.name),
      );
      if (result == null) return;

      final ProjectDocumentFile newFile =
          (editorContent is EditorContentString)
              ? await _repo.createDocumentFile(
                result.parentUri,
                result.fileName,
                initialContent: editorContent.content,
                overwrite: true,
              )
              : await _repo.createDocumentFile(
                result.parentUri,
                result.fileName,
                initialBytes: (editorContent as EditorContentBytes).bytes,
                overwrite: true,
              );

      final newHash =
          (editorContent is EditorContentString)
              ? md5.convert(utf8.encode(editorContent.content)).toString()
              : md5
                  .convert((editorContent as EditorContentBytes).bytes)
                  .toString();

      _ref.read(tabMetadataProvider.notifier).updateFile(tab.id, newFile);
      _ref.read(tabMetadataProvider.notifier).markClean(tab.id);

      await _ref
          .read(hotStateCacheServiceProvider)
          .clearTabState(project.id, tab.id);
      editorState.onSaveSuccess(newHash);

      MachineToast.info("Saved as ${newFile.name}");
    } catch (e, st) {
      _ref.read(talkerProvider).handle(e, st, 'Save As operation failed');
      MachineToast.error("Save As operation failed.");
    }
  }

  void _handlePluginLifecycle(EditorTab? oldTab, EditorTab? newTab) {
    if (oldTab != null) oldTab.plugin.deactivateTab(oldTab, _ref);
    if (newTab != null) newTab.plugin.activateTab(newTab, _ref);
  }

  /// Opens a file from a relative path within the current project.
  /// If the file does not exist, it prompts the user to create it.
  Future<bool> openOrCreate(String relativePath) async {
    final project = _currentProject;
    if (project == null) {
      MachineToast.error("No project is open.");
      return false;
    }

    final repo = _ref.read(projectRepositoryProvider);
    final appNotifier = _ref.read(appNotifierProvider.notifier);
    final explorerService = _ref.read(explorerServiceProvider);
    final context = _ref.read(navigatorKeyProvider).currentContext;

    if (repo == null || context == null || !context.mounted) {
      return false;
    }

    final sanitizedPath = relativePath.replaceAll(r'\', '/');
    DocumentFile? file = await repo.fileHandler.resolvePath(
      project.rootUri,
      sanitizedPath,
    );

    if (file != null) {
      // File exists, open it directly.
      return await appNotifier.openFileInEditor(file);
    } else {
      // File does not exist, ask to create it.
      final shouldCreate = await showCreateFileConfirmationDialog(
        context,
        relativePath: sanitizedPath,
      );

      if (shouldCreate) {
        try {
          final newFile = await explorerService.createFileWithHierarchy(
            project.rootUri,
            sanitizedPath,
          );
          return await appNotifier.openFileInEditor(newFile);
        } catch (e, st) {
          _ref
              .read(talkerProvider)
              .handle(e, st, 'Failed to create file at path: $sanitizedPath');
          MachineToast.error("Could not create file: $e");
        }
      }
    }
    return false;
  }

  /// Opens a file if not already open, switches to its tab, and applies a generic [TextEdit].
  Future<bool> openAndApplyEdit(String relativePath, TextEdit edit) async {
    final project = _currentProject;
    if (project == null) {
      MachineToast.error("No project is open.");
      return false;
    }

    final sanitizedPath = relativePath.replaceAll(r'\', '/');
    final file = await _repo.fileHandler.resolvePath(
      project.rootUri,
      sanitizedPath,
    );

    if (file == null) {
      MachineToast.error("File not found: $sanitizedPath");
      return false;
    }

    final appNotifier = _ref.read(appNotifierProvider.notifier);
    final metadataMap = _ref.read(tabMetadataProvider);
    final existingTabId =
        metadataMap.entries
            .firstWhereOrNull((entry) => entry.value.file.uri == file.uri)
            ?.key;
    EditorTab? tabToEdit = (project.session.tabs).firstWhereOrNull(
      (t) => t.id == existingTabId,
    );

    try {
      final EditorWidgetState editorState;
      if (tabToEdit == null) {
        final onReadyCompleter = Completer<EditorWidgetState>();
        if (!await appNotifier.openFileInEditor(
          file,
          onReadyCompleter: onReadyCompleter,
        )) {
          return false;
        }
        editorState = await onReadyCompleter.future;
      } else {
        final index = project.session.tabs.indexOf(tabToEdit);
        appNotifier.switchTab(index);
        editorState = await tabToEdit.onReady.future;
      }

      if (editorState is TextEditable) {
        (editorState as TextEditable).applyEdit(edit);
        return true;
      } else {
        throw TypeError();
      }
    } catch (e, st) {
      final errorMessage =
          e is TypeError
              ? "The editor for this file does not support programmatic edits."
              : "Failed to apply edit: $e";
      _ref.read(talkerProvider).handle(e, st, 'Error in openAndApplyEdit');
      MachineToast.error(errorMessage);
      return false;
    }
  }

  Future<OpenFileResult> openFile(
    Project project,
    DocumentFile file, {
    EditorPlugin? explicitPlugin,
    Completer<EditorWidgetState>? onReadyCompleter,
  }) async {
    final metadataMap = _ref.read(tabMetadataProvider);
    final existingTabId =
        metadataMap.entries
            .firstWhereOrNull((entry) => entry.value.file.uri == file.uri)
            ?.key;
    if (existingTabId != null) {
      final existingIndex = project.session.tabs.indexWhere(
        (t) => t.id == existingTabId,
      );
      if (existingIndex != -1) {
        return OpenFileSuccess(
          project: switchTab(project, existingIndex),
          wasAlreadyOpen: true,
        );
      }
    }

    try {
      final EditorPlugin chosenPlugin;
      if (explicitPlugin != null) {
        chosenPlugin = explicitPlugin;
      } else {
        final allPlugins = _ref.read(activePluginsProvider);
        final compatiblePlugins =
            allPlugins.where((p) => p.supportsFile(file)).toList();
        if (compatiblePlugins.isEmpty) {
          return OpenFileError("No plugin available to open '${file.name}'.");
        }

        if (compatiblePlugins.length == 1) {
          chosenPlugin = compatiblePlugins.first;
        } else {
          final contentProvider = _contentProviderRegistry.getProviderFor(file);
          final contentResult = await contentProvider.getContent(
            file,
            PluginDataRequirement.string,
          );
          final fileContent =
              (contentResult.content as EditorContentString).content;

          final contentMatchingPlugins =
              compatiblePlugins
                  .where(
                    (p) =>
                        p.dataRequirement == PluginDataRequirement.string &&
                        p.canOpenFileContent(fileContent, file),
                  )
                  .toList();

          if (contentMatchingPlugins.isEmpty) {
            chosenPlugin = compatiblePlugins.first;
          } else if (contentMatchingPlugins.length == 1) {
            chosenPlugin = contentMatchingPlugins.first;
          } else {
            return OpenFileShowChooser(contentMatchingPlugins);
          }
        }
      }

      final contentProvider = _contentProviderRegistry.getProviderFor(file);
      final contentResult = await contentProvider.getContent(
        file,
        chosenPlugin.dataRequirement,
      );

      if (chosenPlugin.dataRequirement == PluginDataRequirement.string) {
        final fileContent =
            (contentResult.content as EditorContentString).content;
        if (!chosenPlugin.canOpenFileContent(fileContent, file)) {
          return OpenFileError(
            "${chosenPlugin.name} cannot open this file's content.",
          );
        }
      }

      final initData = EditorInitData(
        initialContent: contentResult.content,
        baseContentHash: contentResult.baseContentHash,
      );
      final newTab = await chosenPlugin.createTab(
        file,
        initData,
        onReadyCompleter: onReadyCompleter,
      );
      return _constructOpenFileSuccess(project, newTab, file);
    } catch (e, st) {
      _ref
          .read(talkerProvider)
          .handle(e, st, "Could not create tab for: ${file.uri}");
      return OpenFileError("Error opening file '${file.name}'.");
    }
  }

  OpenFileSuccess _constructOpenFileSuccess(
    Project project,
    EditorTab newTab,
    DocumentFile file,
  ) {
    _ref.read(tabMetadataProvider.notifier).initTab(newTab.id, file);
    final oldTab = project.session.currentTab;
    final newSession = project.session.copyWith(
      tabs: [...project.session.tabs, newTab],
      currentTabIndex: project.session.tabs.length,
    );
    _handlePluginLifecycle(oldTab, newTab);
    return OpenFileSuccess(
      project: project.copyWith(session: newSession),
      wasAlreadyOpen: false,
    );
  }

  Future<void> saveTab(Project project, EditorTab tabToSave) async {
    final editorState = tabToSave.editorKey.currentState;
    final metadata = _ref.read(tabMetadataProvider)[tabToSave.id];
    if (editorState == null || metadata == null) return;

    final file = metadata.file;
    final contentProvider = _contentProviderRegistry.getProviderFor(file);

    try {
      final editorContent = await editorState.getContent();
      final saveResult = await contentProvider.saveContent(file, editorContent);
      _ref.read(tabMetadataProvider.notifier).markClean(tabToSave.id);
      await _ref
          .read(hotStateCacheServiceProvider)
          .clearTabState(project.id, tabToSave.id);
      editorState.onSaveSuccess(saveResult.newContentHash);
      if (saveResult.savedFile.uri != file.uri) {
        _ref
            .read(tabMetadataProvider.notifier)
            .updateFile(tabToSave.id, saveResult.savedFile);
      }
    } on RequiresSaveAsException {
      await saveCurrentTabAs();
    } catch (e, st) {
      _ref
          .read(talkerProvider)
          .handle(e, st, "Failed to save tab: ${metadata.file.name}");
      MachineToast.error("Failed to save ${metadata.file.name}");
    }
  }

  Future<void> saveTabs(Project project, List<EditorTab> tabsToSave) async {
    final futures = tabsToSave.map((tab) => saveTab(project, tab));
    await Future.wait(futures);
  }

  Future<void> saveCurrentTab() async {
    final project = _currentProject;
    final tab = _currentTab;
    if (project != null && tab != null) {
      await saveTab(project, tab);
    }
  }

  Project switchTab(Project project, int index) {
    final oldTab = project.session.currentTab;
    final newSession = project.session.copyWith(currentTabIndex: index);
    final newProject = project.copyWith(session: newSession);
    final newTab = newProject.session.currentTab;

    _handlePluginLifecycle(oldTab, newTab);
    return newProject;
  }

  Project closeTab(Project project, int index) {
    final closedTab = project.session.tabs[index];
    final oldTab = project.session.currentTab;
    final newTabs = List<EditorTab>.from(project.session.tabs)..removeAt(index);

    int newCurrentIndex;
    if (newTabs.isEmpty) {
      newCurrentIndex = 0;
    } else {
      final oldIndex = project.session.currentTabIndex;
      if (oldIndex > index) {
        newCurrentIndex = oldIndex - 1;
      } else if (oldIndex == index) {
        newCurrentIndex = (oldIndex - 1).clamp(0, newTabs.length - 1);
      } else {
        newCurrentIndex = oldIndex;
      }
    }

    final newProject = project.copyWith(
      session: project.session.copyWith(
        tabs: newTabs,
        currentTabIndex: newCurrentIndex,
      ),
    );

    _ref.read(tabMetadataProvider.notifier).removeTab(closedTab.id);

    _ref
        .read(hotStateCacheServiceProvider)
        .clearTabState(project.id, closedTab.id);

    closedTab.plugin.deactivateTab(closedTab, _ref);
    closedTab.plugin.disposeTab(closedTab);
    closedTab.dispose();

    final newTab = newProject.session.currentTab;
    if (oldTab != newTab) {
      newTab?.plugin.activateTab(newTab, _ref);
    }
    return newProject;
  }

  Project reorderTabs(Project project, int oldIndex, int newIndex) {
    final currentOpenTab = project.session.currentTab;
    final newTabs = List<EditorTab>.from(project.session.tabs);
    final movedTab = newTabs.removeAt(oldIndex);
    if (oldIndex < newIndex) newIndex--;
    newTabs.insert(newIndex, movedTab);
    final newCurrentIndex =
        currentOpenTab != null ? newTabs.indexOf(currentOpenTab) : 0;
    return project.copyWith(
      session: project.session.copyWith(
        tabs: newTabs,
        currentTabIndex: newCurrentIndex,
      ),
    );
  }

  void updateTabForRenamedFile(String oldUri, DocumentFile newFile) {
    final metadataMap = _ref.read(tabMetadataProvider);
    final tabId =
        metadataMap.entries
            .firstWhereOrNull((entry) => entry.value.file.uri == oldUri)
            ?.key;
    if (tabId != null) {
      _ref.read(tabMetadataProvider.notifier).updateFile(tabId, newFile);
    }
  }
}

@immutable
sealed class OpenFileResult {}

class OpenFileSuccess extends OpenFileResult {
  final Project project;
  final bool wasAlreadyOpen;
  OpenFileSuccess({required this.project, required this.wasAlreadyOpen});
}

class OpenFileShowChooser extends OpenFileResult {
  final List<EditorPlugin> plugins;
  OpenFileShowChooser(this.plugins);
}

class OpenFileError extends OpenFileResult {
  final String message;
  OpenFileError(this.message);
}

// FILE: lib/editor/tab_context_commands.dart

// NEW FILE: lib/editor/tab_context_commands.dart

import 'package:flutter/material.dart';

import '../app/app_notifier.dart';
import '../command/command_models.dart';

class AppTabContextCommands {
  static List<TabContextCommand> getCommands() {
    return [
      BaseTabContextCommand(
        id: 'close_other_tabs',
        label: 'Close Other Tabs',
        icon: const Icon(Icons.close_rounded, size: 20),
        sourcePlugin: 'App',
        canExecuteFor: (ref, activeTab, targetTab) {
          final project = ref.read(appNotifierProvider).value?.currentProject;
          return (project?.session.tabs.length ?? 0) > 1;
        },
        executeFor: (ref, activeTab, targetTab) async {
          final notifier = ref.read(appNotifierProvider.notifier);
          final tabs =
              ref.read(appNotifierProvider).value!.currentProject!.session.tabs;
          final targetIndex = tabs.indexOf(targetTab);

          final indicesToClose = <int>[];
          for (int i = 0; i < tabs.length; i++) {
            if (i != targetIndex) {
              indicesToClose.add(i);
            }
          }
          notifier.closeMultipleTabs(indicesToClose);
        },
      ),
      // e.g., "Close Tabs to the Right", "Copy File Path", etc.
    ];
  }
}

// FILE: lib/editor/tab_metadata_notifier.dart

// FILE: lib/editor/tab_state_manager.dart


import 'package:flutter/material.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../data/file_handler/file_handler.dart';

import '../project/project_models.dart';

@immutable
class TabMetadata {
  final DocumentFile file;
  final bool isDirty;

  const TabMetadata({required this.file, this.isDirty = false});

  String get title => file.name;

  TabMetadata copyWith({DocumentFile? file, bool? isDirty}) {
    return TabMetadata(
      file: file ?? this.file,
      isDirty: isDirty ?? this.isDirty,
    );
  }

  Map<String, dynamic> toJson() => {
    'fileUri': file.uri,
    'isDirty': isDirty,
  };

  factory TabMetadata.fromJson(Map<String, dynamic> json) {
    return TabMetadata(
      file: IncompleteDocumentFile(uri: json['fileUri']),
      isDirty: json['isDirty'] ?? false,
    );
  }
}

final tabMetadataProvider =
    StateNotifierProvider<TabMetadataNotifier, Map<String, TabMetadata>>((ref) {
      return TabMetadataNotifier();
    });

class TabMetadataNotifier extends StateNotifier<Map<String, TabMetadata>> {
  TabMetadataNotifier() : super({});

  void initTab(String tabId, DocumentFile file) {
    if (state.containsKey(tabId)) return;
    state = {...state, tabId: TabMetadata(file: file)};
  }

  void removeTab(String tabId) {
    final newState = Map<String, TabMetadata>.from(state)..remove(tabId);
    state = newState;
  }

  void markDirty(String tabId) {
    if (state.containsKey(tabId) && state[tabId]?.isDirty == false) {
      state = {...state, tabId: state[tabId]!.copyWith(isDirty: true)};
    }
  }

  void markClean(String tabId) {
    if (state.containsKey(tabId) && state[tabId]?.isDirty == true) {
      state = {...state, tabId: state[tabId]!.copyWith(isDirty: false)};
    }
  }

  void updateFile(String tabId, DocumentFile newFile) {
    if (state.containsKey(tabId)) {
      state = {...state, tabId: state[tabId]!.copyWith(file: newFile)};
    }
  }

  void clear() {
    state = {};
  }
}

// FILE: lib/command/command_models.dart

import 'dart:async';

import 'package:flutter/material.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../data/file_handler/file_handler.dart';
import '../editor/models/editor_tab_models.dart';

import '../editor/plugins/editor_plugin_registry.dart'; 
import '../editor/tab_context_commands.dart'; 

final allTabContextCommandsProvider = Provider<List<TabContextCommand>>((ref) {
  final allPlugins = ref.watch(activePluginsProvider);

    final genericCommands = AppTabContextCommands.getCommands();

    final pluginCommands =
      allPlugins.expand((p) => p.getTabContextMenuCommands()).toList();

    return [...genericCommands, ...pluginCommands];
});

class CommandIcon {
  static const Map<String, IconData> availableIcons = {
    'folder': Icons.folder_outlined,
    'edit': Icons.edit_note_outlined,
    'build': Icons.build_outlined,
    'play': Icons.play_arrow_outlined,
    'debug': Icons.bug_report_outlined,
    'star': Icons.star_border,
    'code': Icons.code,
    'settings': Icons.settings_outlined,
    'web': Icons.public,
  };

  static Widget getIcon(String? name) {
    if (name == null || !availableIcons.containsKey(name)) {
      return const Icon(Icons.label_important_outline);
    }
    return Icon(availableIcons[name]);
  }
}

@immutable
class CommandPosition {
  final String id;
  final String label;
  final IconData icon;
  final List<String> mandatoryCommands;


  const CommandPosition({
    required this.id,
    required this.label,
    required this.icon,
    this.mandatoryCommands = const [],
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CommandPosition &&
          runtimeType == other.runtimeType &&
          id == other.id;

  @override
  int get hashCode => id.hashCode;
}

class AppCommandPositions {
  static const appBar = CommandPosition(
    id: 'app_bar',
    label: 'App Bar',
    icon: Icons.web_asset_outlined,
  );
  static const pluginToolbar = CommandPosition(
    id: 'plugin_toolbar',
    label: 'Plugin Toolbar',
    icon: Icons.build_circle_outlined,
  );
  static const contextMenu = CommandPosition(
    id: 'context_menu',
    label: 'Context Menu',
    icon: Icons.touch_app_outlined,
  );
  static const hidden = CommandPosition(
    id: 'hidden',
    label: 'Hidden',
    icon: Icons.visibility_off_outlined,
  );

  static List<CommandPosition> get all => [appBar, pluginToolbar];
}

abstract class Command {
  final String id;
  final String label;
  final Widget icon;
    final List<CommandPosition> defaultPositions;
  final String sourcePlugin;

  const Command({
    required this.id,
    required this.label,
    required this.icon,
    required this.defaultPositions,
    required this.sourcePlugin,
  });

  Future<void> execute(WidgetRef ref);
  bool canExecute(WidgetRef ref);
}

class BaseCommand extends Command {
  final Future<void> Function(WidgetRef) _execute;
  final bool Function(WidgetRef) _canExecute;

  const BaseCommand({
    required super.id,
    required super.label,
    required super.icon,
    required super.defaultPositions,
    required super.sourcePlugin,
    required Future<void> Function(WidgetRef) execute,
    bool Function(WidgetRef)? canExecute,
  }) : _execute = execute,
       _canExecute = canExecute ?? _defaultCanExecute;

  static bool _defaultCanExecute(WidgetRef ref) => true;

  @override
  Future<void> execute(WidgetRef ref) => _execute(ref);

  @override
  bool canExecute(WidgetRef ref) => _canExecute(ref);
}

@immutable
class CommandGroup {
  final String id;
  final String label;
  final String iconName;
  final Widget? icon;
  final List<String> commandIds;
  final bool showLabels;
  final String sourcePlugin;
  final bool isDeletable;
  final List<CommandPosition> defaultPositions;

  const CommandGroup({
    required this.id,
    required this.label,
    this.iconName = 'folder',
    this.icon,
    this.commandIds = const [],
    this.showLabels = true,
    this.sourcePlugin = 'User',
    this.isDeletable = true,
    this.defaultPositions = const [],
  });

  Widget get finalIcon => icon ?? CommandIcon.getIcon(iconName);

  CommandGroup copyWith({
    String? label,
    String? iconName,
    Widget? icon,
    List<String>? commandIds,
    bool? showLabels,
    String? sourcePlugin,
    bool? isDeletable,
    List<CommandPosition>? defaultPositions,
  }) {
    return CommandGroup(
      id: id,
      label: label ?? this.label,
      iconName: iconName ?? this.iconName,
      icon: icon ?? this.icon,
      commandIds: commandIds ?? this.commandIds,
      showLabels: showLabels ?? this.showLabels,
      sourcePlugin: sourcePlugin ?? this.sourcePlugin,
      isDeletable: isDeletable ?? this.isDeletable,
      defaultPositions: defaultPositions ?? this.defaultPositions,
    );
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'label': label,
    'iconName': iconName,
    'commandIds': commandIds,
    'showLabels': showLabels,
  };

  factory CommandGroup.fromJson(Map<String, dynamic> json) => CommandGroup(
    id: json['id'],
    label: json['label'],
    iconName: json['iconName'] ?? 'folder',
    commandIds: List<String>.from(json['commandIds']),
    showLabels: json['showLabels'] ?? true,
    sourcePlugin: 'User',
    isDeletable: true,
  );
}

abstract class FileContextCommand {
  final String id;
  final String label;
  final Widget icon;
  final String sourcePlugin;

  const FileContextCommand({
    required this.id,
    required this.label,
    required this.icon,
    required this.sourcePlugin,
  });

  bool canExecuteFor(WidgetRef ref, ProjectDocumentFile item);
  Future<void> executeFor(WidgetRef ref, ProjectDocumentFile item);
}

class BaseFileContextCommand extends FileContextCommand {
  final bool Function(WidgetRef, ProjectDocumentFile) _canExecuteFor;
  final Future<void> Function(WidgetRef, ProjectDocumentFile) _executeFor;

  const BaseFileContextCommand({
    required super.id,
    required super.label,
    required super.icon,
    required super.sourcePlugin,
    required bool Function(WidgetRef, ProjectDocumentFile) canExecuteFor,
    required Future<void> Function(WidgetRef, ProjectDocumentFile) executeFor,
  }) : _canExecuteFor = canExecuteFor,
       _executeFor = executeFor;

  @override
  bool canExecuteFor(WidgetRef ref, ProjectDocumentFile item) =>
      _canExecuteFor(ref, item);

  @override
  Future<void> executeFor(WidgetRef ref, ProjectDocumentFile item) =>
      _executeFor(ref, item);
}

abstract class TabContextCommand {
  final String id;
  final String label;
  final Widget icon;
  final String sourcePlugin;

  const TabContextCommand({
    required this.id,
    required this.label,
    required this.icon,
    required this.sourcePlugin,
  });

  bool canExecuteFor(WidgetRef ref, EditorTab activeTab, EditorTab targetTab);
  Future<void> executeFor(
    WidgetRef ref,
    EditorTab activeTab,
    EditorTab targetTab,
  );
}

class BaseTabContextCommand extends TabContextCommand {
  final bool Function(WidgetRef, EditorTab, EditorTab) _canExecuteFor;
  final Future<void> Function(WidgetRef, EditorTab, EditorTab) _executeFor;

  const BaseTabContextCommand({
    required super.id,
    required super.label,
    required super.icon,
    required super.sourcePlugin,
    required bool Function(WidgetRef, EditorTab, EditorTab) canExecuteFor,
    required Future<void> Function(WidgetRef, EditorTab, EditorTab) executeFor,
  }) : _canExecuteFor = canExecuteFor,
       _executeFor = executeFor;

  @override
  bool canExecuteFor(WidgetRef ref, EditorTab activeTab, EditorTab targetTab) =>
      _canExecuteFor(ref, activeTab, targetTab);

  @override
  Future<void> executeFor(
    WidgetRef ref,
    EditorTab activeTab,
    EditorTab targetTab,
  ) => _executeFor(ref, activeTab, targetTab);
}

class CommandState {
  final Map<String, List<String>> orderedCommandsByPosition;

  final List<String> hiddenOrder;
  final Map<String, Set<String>> commandSources;
  final Map<String, CommandGroup> commandGroups;

  final List<CommandPosition> availablePositions;

  const CommandState({
    this.orderedCommandsByPosition = const {},
    this.hiddenOrder = const [],
    this.commandSources = const {},
    this.commandGroups = const {},
    this.availablePositions = const [],
  });

  CommandState copyWith({
    Map<String, List<String>>? orderedCommandsByPosition,
    List<String>? hiddenOrder,
    Map<String, Set<String>>? commandSources,
    Map<String, CommandGroup>? commandGroups,
    List<CommandPosition>? availablePositions,
  }) {
    return CommandState(
      orderedCommandsByPosition:
          orderedCommandsByPosition ?? this.orderedCommandsByPosition,
      hiddenOrder: hiddenOrder ?? this.hiddenOrder,
      commandSources: commandSources ?? this.commandSources,
      commandGroups: commandGroups ?? this.commandGroups,
      availablePositions: availablePositions ?? this.availablePositions,
    );
  }
}

// FILE: lib/command/command_notifier.dart

import 'dart:convert';

import 'package:collection/collection.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:uuid/uuid.dart';

import '../app/app_commands.dart';
import '../editor/plugins/editor_plugin_registry.dart';
import 'command_models.dart';

export 'command_models.dart';

final commandProvider = StateNotifierProvider<CommandNotifier, CommandState>((
  ref,
) {
  final plugins = ref.watch(activePluginsProvider);
  return CommandNotifier(ref: ref, plugins: plugins);
});

class CommandNotifier extends StateNotifier<CommandState> {
  final Ref ref;
  final List<Command> _allRegisteredCommands = [];
  final Map<String, CommandGroup> _pluginDefinedGroups = {};

  List<Command> get allRegisteredCommands => _allRegisteredCommands;
  Map<String, CommandGroup> get pluginDefinedGroups => _pluginDefinedGroups;

  Command? getCommand(String id, String sourcePlugin) {
    for (final command in _allRegisteredCommands) {
      if (command.id == id && command.sourcePlugin == sourcePlugin) {
        return command;
      }
    }
    for (final command in _allRegisteredCommands) {
      if (command.id == id) {
        return command;
      }
    }
    return null;
  }

  CommandNotifier({required this.ref, required List<EditorPlugin> plugins})
    : super(const CommandState()) {
    _initializeCommands(plugins);
  }

  void _initializeCommands(List<EditorPlugin> plugins) async {
    _allRegisteredCommands.clear();
    _pluginDefinedGroups.clear();
    
    final commandSources = <String, Set<String>>{};
    final allAppCommands = AppCommands.getCommands();
    final allPluginEditorCommands = plugins.expand((p) => p.getCommands());
    final allPluginAppCommands = plugins.expand((p) => p.getAppCommands());
    for (final plugin in plugins) {
      for (final group in plugin.getCommandGroups()) {
        _pluginDefinedGroups[group.id] = group.copyWith(
          sourcePlugin: plugin.id,
          isDeletable: false,
        );
      }
    }
    
    final combinedCommands = [
      ...allAppCommands,
      ...allPluginEditorCommands,
      ...allPluginAppCommands,
    ];
    for (final cmd in combinedCommands) {
      _allRegisteredCommands.add(cmd);
      (commandSources[cmd.id] ??= {}).add(cmd.sourcePlugin);
    }

    final allPositions = <CommandPosition>[
      ...AppCommandPositions.all,
      ...plugins.expand((p) => p.getCommandPositions()),
    ];

    state = state.copyWith(
      commandSources: commandSources,
      availablePositions: allPositions,
    );
    await _loadFromPrefs();
  }

  void createGroup({
    required String name,
    required String iconName,
    required bool showLabels,
  }) {
    final newGroup = CommandGroup(
      id: 'group_${const Uuid().v4()}',
      label: name,
      iconName: iconName,
      showLabels: showLabels,
    );
    final newGroups = {...state.commandGroups, newGroup.id: newGroup};
    final newPositions = Map.of(state.orderedCommandsByPosition);
    for (final list in newPositions.values) {
      list.remove(newGroup.id);
    }
    state = state.copyWith(
      commandGroups: newGroups,
      orderedCommandsByPosition: newPositions,
    );
    _saveToPrefs();
  }

  void updateGroup(
    String groupId, {
    String? newName,
    String? newIconName,
    bool? newShowLabels,
  }) {
    final oldGroup = state.commandGroups[groupId];
    if (oldGroup == null) return;
    final newGroup = oldGroup.copyWith(
      label: newName,
      iconName: newIconName,
      showLabels: newShowLabels, 
    );
    final newGroups = {...state.commandGroups, groupId: newGroup};
    state = state.copyWith(commandGroups: newGroups);
    _saveToPrefs();
  }

  void deleteGroup(String groupId) {
    final group = state.commandGroups[groupId];
    if (group == null) return;
    final newGroups = Map.of(state.commandGroups)..remove(groupId);
    final newHiddenOrder = [...state.hiddenOrder, ...group.commandIds];

    final newPositions = Map<String, List<String>>.from(
      state.orderedCommandsByPosition,
    );
    newPositions.forEach((key, value) {
      newPositions[key] = value.where((id) => id != groupId).toList();
    });

    state = state.copyWith(
      commandGroups: newGroups,
      hiddenOrder: newHiddenOrder,
      orderedCommandsByPosition: newPositions,
    );
    _saveToPrefs();
  }

  Map<String, List<String>> _getMutableLists() {
    return {
      'hidden': List<String>.from(state.hiddenOrder),
      ...Map.from(
        state.orderedCommandsByPosition,
      ).map((key, value) => MapEntry(key, List<String>.from(value))),
      ...state.commandGroups.map(
        (id, group) => MapEntry(id, List<String>.from(group.commandIds)),
      ),
    };
  }

  void _updateStateWithLists(Map<String, List<String>> lists) {
    final newGroups = Map.of(state.commandGroups);
    final newPositions = Map.of(state.orderedCommandsByPosition);

    lists.forEach((listId, commands) {
      if (newGroups.containsKey(listId)) {
        newGroups[listId] = newGroups[listId]!.copyWith(commandIds: commands);
      } else if (newPositions.containsKey(listId)) {
        newPositions[listId] = commands;
      }
    });

    state = state.copyWith(
      orderedCommandsByPosition: newPositions,
      hiddenOrder: lists['hidden'],
      commandGroups: newGroups,
    );
    _saveToPrefs();
  }

  void reorderItemInList({
    required String positionId,
    required int oldIndex,
    required int newIndex,
  }) {
    final lists = _getMutableLists();
    final list = lists[positionId];
    if (list == null) return;
    if (oldIndex < newIndex) newIndex--;
    final item = list.removeAt(oldIndex);
    list.insert(newIndex, item);
    _updateStateWithLists(lists);
  }

  void removeItemFromList({
    required String itemId,
    required String fromPositionId,
  }) {
    final position = state.availablePositions.firstWhereOrNull(
      (p) => p.id == fromPositionId,
    );
    if (position?.mandatoryCommands.contains(itemId) ?? false) {
      return;
    }

    final parentGroup = state.commandGroups[fromPositionId];
    if (parentGroup != null && !parentGroup.isDeletable) {
      final originalPluginGroup = _pluginDefinedGroups[fromPositionId];
      
      if (originalPluginGroup?.commandIds.contains(itemId) ?? false) {
        return;
      }
    }

    final lists = _getMutableLists();
    lists[fromPositionId]?.remove(itemId);
    if (!state.commandGroups.containsKey(itemId)) {
      final isPlacedElsewhere = lists.entries
          .where(
            (entry) => entry.key != 'hidden' && entry.key != fromPositionId,
          )
          .any((entry) => entry.value.contains(itemId));
      if (!isPlacedElsewhere) {
        lists['hidden']?.add(itemId);
      }
    }
    _updateStateWithLists(lists);
  }

  void addItemToList({required String itemId, required String toPositionId}) {
    final lists = _getMutableLists();
    final targetList = lists[toPositionId];
    if (targetList == null) return;

    if (!targetList.contains(itemId)) {
      targetList.add(itemId);
    }

    lists['hidden']?.remove(itemId);

    _updateStateWithLists(lists);
  }

  Future<void> _saveToPrefs() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(
      'command_positions',
      jsonEncode(state.orderedCommandsByPosition),
    );
    await prefs.setStringList('command_hidden', state.hiddenOrder);
    final encodedGroups = state.commandGroups.map(
      (key, value) => MapEntry(key, jsonEncode(value.toJson())),
    );
    await prefs.setString('command_groups', jsonEncode(encodedGroups));
  }

  Future<void> _loadFromPrefs() async {
    final prefs = await SharedPreferences.getInstance();
    final allKnownCommandIds = _allRegisteredCommands.map((c) => c.id).toSet();

    final Map<String, CommandGroup> loadedGroups =
        Map.from(_pluginDefinedGroups);
    final groupsJsonString = prefs.getString('command_groups');
    if (groupsJsonString != null) {
      final Map<String, dynamic> decoded = jsonDecode(groupsJsonString);
      decoded.forEach((key, value) {
        final savedGroupData =
            CommandGroup.fromJson(
                jsonDecode(value as String) as Map<String, dynamic>);

        if (loadedGroups.containsKey(key)) {
          final pluginGroup = loadedGroups[key]!;
          final cleanCommandIds =
              savedGroupData.commandIds.where(allKnownCommandIds.contains).toList();
          loadedGroups[key] = pluginGroup.copyWith(
            commandIds: cleanCommandIds,
            showLabels: savedGroupData.showLabels,
          );
        } else {
          final cleanCommandIds =
              savedGroupData.commandIds.where(allKnownCommandIds.contains).toList();
          loadedGroups[key] = savedGroupData.copyWith(commandIds: cleanCommandIds);
        }
      });
    }

    final allValidGroupIds = loadedGroups.keys.toSet();
    final allValidItemIds = {...allKnownCommandIds, ...allValidGroupIds};

    final Map<String, List<String>> loadedPositions = {};
    final positionsJsonString = prefs.getString('command_positions');
    if (positionsJsonString != null) {
      final Map<String, dynamic> decoded = jsonDecode(positionsJsonString);
      decoded.forEach((key, value) {
        if (state.availablePositions.any((p) => p.id == key)) {
          loadedPositions[key] =
              (value as List)
                  .cast<String>()
                  .where(allValidItemIds.contains)
                  .toList();
        }
      });
    }

    final loadedHidden = prefs.getStringList('command_hidden') ?? [];
    final cleanHidden =
        loadedHidden.where(allKnownCommandIds.contains).toList();

    final newPositions = {
      for (var pos in state.availablePositions) pos.id: <String>[],
    };
    newPositions.addAll(loadedPositions);

    final allPlacedItemIds = {
      ...newPositions.values.expand((ids) => ids),
      ...cleanHidden,
      ...loadedGroups.values.expand((g) => g.commandIds),
    };

    final orphanedCommandIds = allKnownCommandIds.where(
      (id) => !allPlacedItemIds.contains(id),
    );
    
    final orphanedGroupIds = _pluginDefinedGroups.keys.where(
      (id) => !allPlacedItemIds.contains(id),
    );

    for (final commandId in orphanedCommandIds) {
      final command = _allRegisteredCommands.firstWhereOrNull(
        (c) => c.id == commandId,
      );
      if (command != null) {
        for (final position in command.defaultPositions) {
          final positionId = position.id;
          if (newPositions.containsKey(positionId)) {
            newPositions[positionId]!.add(commandId);
          } else {
            if (!cleanHidden.contains(commandId)) {
              cleanHidden.add(commandId);
            }
          }
        }
      }
    }
    
    for (final groupId in orphanedGroupIds) {
      final group = _pluginDefinedGroups[groupId];
      if (group != null) {
        if (group.defaultPositions.isNotEmpty) {
          for (final position in group.defaultPositions) {
            final positionId = position.id;
            if (newPositions.containsKey(positionId)) {
              newPositions[positionId]!.add(groupId);
            }
          }
        }
      }
    }
    
    for (final position in state.availablePositions) {
      if (position.mandatoryCommands.isNotEmpty) {
        final positionList = newPositions[position.id]!;
        for (final mandatoryId in position.mandatoryCommands) {
          
          if (!positionList.contains(mandatoryId)) {
            
            
            newPositions.forEach((key, value) {
              value.remove(mandatoryId);
            });
            
            cleanHidden.remove(mandatoryId);
            
            positionList.insert(0, mandatoryId);
          }
        }
      }
    }

    state = state.copyWith(
      orderedCommandsByPosition: newPositions,
      hiddenOrder: cleanHidden,
      commandGroups: loadedGroups,
    );
  }
}

// FILE: lib/command/command_widgets.dart

import 'package:flutter/material.dart';

import 'package:collection/collection.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../app/app_notifier.dart';
import '../editor/models/text_editing_capability.dart';
import 'command_notifier.dart';

final commandsForPositionProvider = Provider.family<List<dynamic>, String>((
  ref,
  positionId,
) {
  final commandState = ref.watch(commandProvider);
  final notifier = ref.read(commandProvider.notifier);
  final currentPlugin = ref.watch(
    appNotifierProvider.select(
      (s) => s.value?.currentProject?.session.currentTab?.plugin,
    ),
  );

  final visibleItems = <dynamic>[];
  final order = commandState.orderedCommandsByPosition[positionId] ?? [];

  for (final id in order) {
    if (commandState.commandGroups.containsKey(id)) {
      visibleItems.add(commandState.commandGroups[id]!);
      continue;
    }

    final command = notifier.allRegisteredCommands.firstWhereOrNull((c) {
      if (c.id != id) {
        return false;
      }

      if (c.sourcePlugin == 'App') return true;

      if (c is BaseTextEditableCommand) {
        return currentPlugin is TextEditablePlugin;
      } else {
        return c.sourcePlugin == currentPlugin?.id;
      }
    });

    if (command != null) {
      visibleItems.add(command);
    }
  }
  return visibleItems;
});

class CommandToolbar extends ConsumerWidget {
  final CommandPosition position;
  final bool showLabels;
  final Axis direction;

  const CommandToolbar({
    super.key,
    required this.position,
    this.showLabels = false,
    this.direction = Axis.horizontal,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final items = ref.watch(commandsForPositionProvider(position.id));
    final currentPlugin = ref.watch(
      appNotifierProvider.select(
        (s) => s.value?.currentProject?.session.currentTab?.plugin,
      ),
    );

    final List<Widget> children =
        items.map((item) {
          if (item is Command) {
            return CommandButton(command: item, showLabel: showLabels);
          }
          if (item is CommandGroup) {
            return CommandGroupButton(commandGroup: item);
          }
          return const SizedBox.shrink();
        }).toList();

    Widget toolbar;
    if (direction == Axis.horizontal) {
      toolbar = Row(mainAxisSize: MainAxisSize.min, children: children);
    } else {
      toolbar = Column(mainAxisSize: MainAxisSize.min, children: children);
    }

    if (currentPlugin != null) {
      return currentPlugin.wrapCommandToolbar(toolbar);
    }
    return toolbar;
  }
}

class AppBarCommands extends ConsumerWidget {
  const AppBarCommands({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return const CommandToolbar(position: AppCommandPositions.appBar);
  }
}

class BottomToolbar extends ConsumerWidget {
  const BottomToolbar({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final override = ref.watch(
      appNotifierProvider.select((s) => s.value?.bottomToolbarOverride),
    );
    if (override != null) {
      return override;
    }

    return Container(
      height: 48,
      color: Theme.of(context).bottomAppBarTheme.color,
      child: ListView(
        scrollDirection: Axis.horizontal,
        children: const [
          CommandToolbar(position: AppCommandPositions.pluginToolbar),
        ],
      ),
    );
  }
}

class CommandButton extends ConsumerWidget {
  final Command command;
  final bool showLabel;

  const CommandButton({
    super.key,
    required this.command,
    this.showLabel = false,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isEnabled = command.canExecute(ref);

    if (showLabel) {
      return TextButton.icon(
        icon: command.icon,
        label: Text(command.label),
        onPressed: isEnabled ? () => command.execute(ref) : null,
      );
    }

    return IconButton(
      icon: command.icon,
      onPressed: isEnabled ? () => command.execute(ref) : null,
      tooltip: command.label,
    );
  }
}

class CommandGroupButton extends ConsumerStatefulWidget {
  final CommandGroup commandGroup;

  const CommandGroupButton({super.key, required this.commandGroup});

  @override
  ConsumerState<CommandGroupButton> createState() => _CommandGroupButtonState();
}

class _CommandGroupButtonState extends ConsumerState<CommandGroupButton> {
  final LayerLink _layerLink = LayerLink();
  OverlayEntry? _overlayEntry;

  @override
  void dispose() {
    _hideMenu();
    super.dispose();
  }

  void _toggleMenu() {
    if (_overlayEntry != null) {
      _hideMenu();
    } else {
      _showMenu();
    }
  }

  void _hideMenu() {
    _overlayEntry?.remove();
    _overlayEntry = null;
  }

  void _handleCommandExecution(Command command) {
    _hideMenu();
    if (command.canExecute(ref)) {
      command.execute(ref);
    }
  }

  void _showMenu() {
    final overlay = Overlay.of(context);
    final renderBox = context.findRenderObject()! as RenderBox;
    final size = renderBox.size;
    final offset = renderBox.localToGlobal(Offset.zero);
    final screenSize = MediaQuery.of(context).size;

    final alignRight = (offset.dx + size.width / 2) > screenSize.width / 2;
    final openUpwards = (offset.dy + size.height / 2) > screenSize.height / 2;

    final Alignment followerAnchor =
        openUpwards
            ? (alignRight ? Alignment.bottomRight : Alignment.bottomLeft)
            : (alignRight ? Alignment.topRight : Alignment.topLeft);

    final Alignment targetAnchor =
        openUpwards
            ? (alignRight ? Alignment.topRight : Alignment.topLeft)
            : (alignRight ? Alignment.bottomRight : Alignment.bottomLeft);

    _overlayEntry = OverlayEntry(
      builder: (context) {
        final commandsInGroup = _getCommandsInGroup(ref);
        if (commandsInGroup.isEmpty) {
          WidgetsBinding.instance.addPostFrameCallback((_) => _hideMenu());
          return const SizedBox.shrink();
        }

        Widget menuBody;

        if (widget.commandGroup.showLabels) {
          menuBody = IntrinsicWidth(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children:
                  commandsInGroup.map((command) {
                    final isEnabled = command.canExecute(ref);
                    return ListTile(
                      dense: true,
                      enabled: isEnabled,
                      leading: command.icon,
                      title: Text(command.label),
                      onTap: () => _handleCommandExecution(command),
                    );
                  }).toList(),
            ),
          );
        } else {
          menuBody = Column(
            mainAxisSize: MainAxisSize.min,
            children:
                commandsInGroup.map((command) {
                  final isEnabled = command.canExecute(ref);
                  return IconButton(
                    icon: command.icon,
                    tooltip: command.label,
                    onPressed:
                        isEnabled
                            ? () => _handleCommandExecution(command)
                            : null,
                  );
                }).toList(),
          );
        }

        return Stack(
          children: [
            Positioned.fill(
              child: GestureDetector(
                onTap: _hideMenu,
                behavior: HitTestBehavior.opaque,
                child: Container(color: Colors.transparent),
              ),
            ),
            CompositedTransformFollower(
              link: _layerLink,
              showWhenUnlinked: false,
              followerAnchor: followerAnchor,
              targetAnchor: targetAnchor,
              offset: Offset(0, openUpwards ? -4.0 : 4.0),
              child: Material(
                elevation: 4.0,
                borderRadius: BorderRadius.circular(4.0),
                child: ConstrainedBox(
                  constraints: const BoxConstraints(maxWidth: 250),
                  child: Padding(
                    padding: EdgeInsets.symmetric(
                      vertical: 4.0,
                      horizontal: widget.commandGroup.showLabels ? 0.0 : 4.0,
                    ),
                    child: menuBody,
                  ),
                ),
              ),
            ),
          ],
        );
      },
    );

    overlay.insert(_overlayEntry!);
  }

  List<Command> _getCommandsInGroup(WidgetRef ref) {
    final notifier = ref.read(commandProvider.notifier);
    final currentPluginId = ref.watch(
      appNotifierProvider.select(
        (s) => s.value?.currentProject?.session.currentTab?.plugin.id,
      ),
    );

    return widget.commandGroup.commandIds
        .map(
          (id) => notifier.allRegisteredCommands.firstWhereOrNull(
            (c) =>
                c.id == id &&
                (c.sourcePlugin == currentPluginId || c.sourcePlugin == 'App'),
          ),
        )
        .whereType<Command>()
        .toList();
  }

  @override
  Widget build(BuildContext context) {
    final commandsInGroup = _getCommandsInGroup(ref);
    if (commandsInGroup.isEmpty) {
      return const SizedBox.shrink();
    }

    final button = CompositedTransformTarget(
      link: _layerLink,
      child: IconButton(
        icon: widget.commandGroup.finalIcon,
        tooltip: widget.commandGroup.label,
        onPressed: _toggleMenu,
      ),
    );

    final currentPlugin = ref.watch(
      appNotifierProvider.select(
        (s) => s.value?.currentProject?.session.currentTab?.plugin,
      ),
    );

    if (currentPlugin != null) {
      return currentPlugin.wrapCommandToolbar(button);
    }
    return button;
  }
}

// FILE: lib/logs/logs_models.dart

import 'package:talker_flutter/talker_flutter.dart';

/*class FileOperationEvent extends TalkerLog {
  final String operation;
  final String path;

  FileOperationEvent(this.operation, this.path) : super('[$operation] $path');

  @override
  AnsiPen get pen => AnsiPen()..xterm(75);
}
*/

class HierarchyLog extends TalkerLog {
  HierarchyLog(String super.message);

  static String get getTitle => 'Hierarchy';

  static String get getKey => 'hierarchy';

  static AnsiPen get getPen => AnsiPen()..xterm(75);

  @override
  String get title => getTitle;

  @override
  String get key => getKey;

  @override
  AnsiPen get pen => getPen;
}

class FileOperationLog extends TalkerLog {
  FileOperationLog(String super.message);

  static String get getTitle => 'File Operation';

  static String get getKey => 'file_operation';

  static AnsiPen get getPen => AnsiPen()..yellow();

  @override
  String get title => getTitle;

  @override
  String get key => getKey;

  @override
  AnsiPen get pen => getPen;
}

// FILE: lib/logs/logs_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:talker_flutter/talker_flutter.dart';

import 'logs_models.dart';

export 'package:talker_riverpod_logger/talker_riverpod_logger_observer.dart';
export 'package:talker_riverpod_logger/talker_riverpod_logger.dart';
export 'package:talker_flutter/talker_flutter.dart';
export 'logs_models.dart';

final talkerProvider = Provider<Talker>((ref) {
  return TalkerFlutter.init(
    logger: TalkerLogger(settings: TalkerLoggerSettings()),
    settings: TalkerSettings(
      enabled: true,
      useConsoleLogs: true,
      colors: {FileOperationLog.getKey: FileOperationLog.getPen},
    ),
  );
});

// FILE: lib/main.dart

import 'dart:async';

import 'package:flutter/material.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'app/app_notifier.dart';
import 'app/app_screen.dart';
import 'app/lifecycle.dart';
import 'data/shared_preferences.dart';
import 'logs/logs_provider.dart';
import 'settings/settings_screen.dart';

import 'dart:io';

import 'package:flutter/services.dart';

import 'command/command_notifier.dart'; 
import 'data/cache/background_task/background_cache_service.dart'; 
import 'data/cache/hot_state_cache_service.dart'; 
import 'settings/settings_notifier.dart'; 
import 'project/project_settings_notifier.dart'; 


final appStartupProvider = FutureProvider<void>((ref) async {
  final talker = ref.read(talkerProvider);
  talker.info('appStartupProvider: Starting async initialization...');


  await ref.read(cacheRepositoryProvider).init();
  await ref.read(hotStateCacheServiceProvider).initializeAndStart();
  await ref.read(sharedPreferencesProvider.future);

  ref.read(settingsProvider);
  ref.read(commandProvider);
  await ref.read(appNotifierProvider.future);

  talker.info('appStartupProvider: Async initialization complete.');
});

ThemeData _createThemeData(Color seedColor, Brightness brightness) {
  return ThemeData(
    useMaterial3: true,
    colorScheme: ColorScheme.fromSeed(
      seedColor: seedColor,
      brightness: brightness,
    ).copyWith(
      surface: brightness == Brightness.dark ? const Color(0xFF2B2B29) : null,
    ),
    appBarTheme: AppBarTheme(
      backgroundColor:
          brightness == Brightness.dark ? const Color(0xFF2B2B29) : null,
      elevation: 1,
      scrolledUnderElevation: 1,
      centerTitle: true,
      titleTextStyle: const TextStyle(fontSize: 14),
      toolbarHeight: 48,
    ),
    tabBarTheme: TabBarThemeData(
      indicator: UnderlineTabIndicator(
        borderSide: BorderSide(color: seedColor, width: 2.0),
      ),
      unselectedLabelColor: Colors.grey[400],
      indicatorSize: TabBarIndicatorSize.tab,
      labelPadding: const EdgeInsets.symmetric(horizontal: 8.0),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor:
            brightness == Brightness.dark ? const Color(0xFF3A3A3A) : null,
      ),
    ),
    drawerTheme: DrawerThemeData(
      backgroundColor:
          brightness == Brightness.dark ? const Color(0xFF212121) : null,
    ),
  );
}

final themeConfigProvider = Provider((ref) {
  final settings = ref.watch(effectiveSettingsProvider);
  final generalSettings =
      settings.pluginSettings[GeneralSettings] as GeneralSettings;

  final seedColor = Color(generalSettings.accentColorValue);
  final themeMode = generalSettings.themeMode;

  final lightTheme = _createThemeData(seedColor, Brightness.light);
  final darkTheme = _createThemeData(seedColor, Brightness.dark);

  return (light: lightTheme, dark: darkTheme, mode: themeMode);
});

void main() {
  final talker = TalkerFlutter.init(
    logger: TalkerLogger(settings: TalkerLoggerSettings()),
    settings: TalkerSettings(
      enabled: true,
      useConsoleLogs: true,
      colors: {FileOperationLog.getKey: FileOperationLog.getPen},
    ),
  );

  final riverpodObserver = TalkerRiverpodObserver(
    talker: talker,
    settings: TalkerRiverpodLoggerSettings(
      enabled: true,
      printProviderDisposed: true,
      printStateFullData: false,
    ),
  );
  WidgetsFlutterBinding.ensureInitialized();
  SystemChrome.setSystemUIOverlayStyle(
    const SystemUiOverlayStyle(
      systemNavigationBarColor: Color(0xFF2B2B29),

      systemNavigationBarIconBrightness: Brightness.light,
    ),
  );

  runZonedGuarded(
    () {
      FlutterError.onError = (details) {
        talker.handle(
          details.exception,
          details.stack,
          'Flutter framework error',
        );
      };

      runApp(
        ProviderScope(
          overrides: [talkerProvider.overrideWithValue(talker)],
          observers: [riverpodObserver],
          child: LifecycleHandler(
            talker: talker,
            child: Consumer(
              builder: (context, ref, child) {
                final themeConfig = ref.watch(themeConfigProvider);

                return MaterialApp(
                  navigatorKey: ref.watch(navigatorKeyProvider),
                  scaffoldMessengerKey: ref.watch(
                    rootScaffoldMessengerKeyProvider,
                  ),
                  theme: themeConfig.light,
                  darkTheme: themeConfig.dark,
                  themeMode: ThemeMode.dark,
                  home: AppStartupWidget(
                    onLoaded: (context) => const AppScreen(),
                  ),
                  routes: {
                    '/settings': (_) => const SettingsScreen(),
                    '/command-settings': (_) => const CommandSettingsScreen(),
                    '/logs':
                        (_) => TalkerScreen(talker: ref.read(talkerProvider)),
                  },
                );
              },
            ),
          ),
        ),
      );
    },
    (error, stack) {
      talker.handle(error, stack, 'Unhandled error');
    },
  );
}


class AppStartupWidget extends ConsumerWidget {
  final WidgetBuilder onLoaded;

  const AppStartupWidget({super.key, required this.onLoaded});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final startupState = ref.watch(appStartupProvider);

    return startupState.when(
      loading: () => const AppStartupLoadingWidget(),
      error: (error, stack) {
        ref.read(talkerProvider).handle(error, stack, 'Startup error');
        return AppStartupErrorWidget(
          error: error,
          onRetry: () => ref.invalidate(appStartupProvider),
        );
      },
      data: (_) => onLoaded(context),
    );
  }
}

class AppStartupLoadingWidget extends StatelessWidget {
  const AppStartupLoadingWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return const Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            CircularProgressIndicator(),
            SizedBox(height: 20),
            Text('Initializing application...'),
          ],
        ),
      ),
    );
  }
}

class AppStartupErrorWidget extends StatelessWidget {
  final Object error;
  final VoidCallback onRetry;

  const AppStartupErrorWidget({
    super.key,
    required this.error,
    required this.onRetry,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, color: Colors.red, size: 50),
            const SizedBox(height: 20),
            Text('Initialization failed: $error', textAlign: TextAlign.center),
            const SizedBox(height: 20),
            ElevatedButton(onPressed: onRetry, child: const Text('Retry')),
          ],
        ),
      ),
    );
  }
}

// FILE: lib/project/project_models.dart

// FILE: lib/project/project_models.dart

import 'package:flutter/foundation.dart';

import '../data/file_handler/file_handler.dart';
import '../editor/models/editor_tab_models.dart';
import '../data/content_provider/file_content_provider.dart';
import '../editor/tab_metadata_notifier.dart';
import '../explorer/explorer_workspace_state.dart';

import '../data/dto/project_dto.dart';
import 'project_settings_models.dart';

//TODO: Move this into documentFile definition file
class IncompleteDocumentFile implements DocumentFile {
  @override
  final String uri;
  IncompleteDocumentFile({required this.uri});

  @override
  String get name => '';
  @override
  bool get isDirectory => false;
  @override
  int get size => 0;
  @override
  DateTime get modifiedDate => DateTime.fromMillisecondsSinceEpoch(0);
  @override
  String get mimeType => 'application/octet-stream';
}

@immutable
class InternalAppFile implements DocumentFile {
  @override
  final String uri;

  @override
  final String name;

  @override
  final bool isDirectory = false;
  @override
  final int size;
  @override
  final DateTime modifiedDate;
  @override
  final String mimeType;

  const InternalAppFile({
    required this.uri,
    required this.name,
    this.size = 0,
    required this.modifiedDate,
    this.mimeType = 'text/plain',
  });
}

@immutable
class ProjectMetadata {
  final String id;
  final String name;
  final String rootUri;
  final String projectTypeId;
  final String persistenceTypeId;
  final DateTime lastOpenedDateTime;

  const ProjectMetadata({
    required this.id,
    required this.name,
    required this.rootUri,
    required this.projectTypeId,
    required this.persistenceTypeId,
    required this.lastOpenedDateTime,
  });

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'rootUri': rootUri,
        'projectTypeId': projectTypeId,
        'persistenceTypeId': persistenceTypeId,
        'lastOpenedDateTime': lastOpenedDateTime.toIso8601String(),
      };

  factory ProjectMetadata.fromJson(Map<String, dynamic> json) {

    String projectTypeId = json['projectTypeId'];
    String? persistenceTypeId = json['persistenceTypeId'];

    if (persistenceTypeId == null) {
      switch (projectTypeId) {
        case 'local_persistent':
          projectTypeId = 'local';
          persistenceTypeId = 'local_folder';
          break;
        case 'simple_local':
          projectTypeId = 'local';
          persistenceTypeId = 'simple_state';
          break;
        default:
          projectTypeId = 'local';
          persistenceTypeId = 'simple_state';
          break;
      }
    }

    return ProjectMetadata(
      id: json['id'],
      name: json['name'],
      rootUri: json['rootUri'],
      projectTypeId: projectTypeId,
      persistenceTypeId: persistenceTypeId,
      lastOpenedDateTime: DateTime.parse(json['lastOpenedDateTime']),
    );
  }
}

@immutable
class Project {
  final ProjectMetadata metadata;
  final TabSessionState session;
  final ExplorerWorkspaceState workspace;
  final ProjectSettingsState? settings;

  const Project({
    required this.metadata,
    required this.session,
    required this.workspace,
    this.settings,
  });

  String get id => metadata.id;
  String get name => metadata.name;
  String get rootUri => metadata.rootUri;
  String get projectTypeId => metadata.projectTypeId;

  factory Project.fresh(ProjectMetadata metadata) {
    return Project(
      metadata: metadata,
      session: const TabSessionState(),
      workspace: const ExplorerWorkspaceState(
        activeExplorerPluginId: 'com.machine.file_explorer',
      ),
      settings: const ProjectSettingsState(),
    );
  }

  Project copyWith({
    ProjectMetadata? metadata,
    TabSessionState? session,
    ExplorerWorkspaceState? workspace,
    ProjectSettingsState? settings,
  }) {
    return Project(
      metadata: metadata ?? this.metadata,
      session: session ?? this.session,
      workspace: workspace ?? this.workspace,
      settings: settings ?? this.settings,
    );
  }

  /// type of each open file for persistence.
  ProjectDto toDto(
    Map<String, TabMetadata> liveMetadata,
    FileContentProviderRegistry registry,
  ) {
    return ProjectDto(
      session: session.toDto(liveMetadata, registry),
      workspace: workspace.toDto(),
      settings: settings?.toDto(),
    );
  }
}

@immutable
class VirtualDocumentFile implements DocumentFile {
  @override
  final String uri;

  @override
  final String name;

  @override
  final bool isDirectory;

  @override
  final int size;

  @override
  final DateTime modifiedDate;

  @override
  final String mimeType;

  VirtualDocumentFile({
    required this.uri,
    required this.name,
    this.isDirectory = false,
    this.size = 0,
    this.mimeType = 'text/plain',
  }) : modifiedDate = DateTime.now();
}

// FILE: lib/project/project_settings_models.dart

import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

import '../data/dto/project_dto.dart';
import '../editor/plugins/editor_plugin_registry.dart';
import '../explorer/explorer_plugin_models.dart';
import '../settings/settings_models.dart';

abstract class ProjectSettings extends MachineSettings {}

@immutable
class ProjectSettingsState {
  final Map<Type, MachineSettings> pluginSettingsOverrides;

  final Map<String, ExplorerPluginSettings> explorerPluginSettingsOverrides;

  final ProjectSettings? typeSpecificSettings;

  const ProjectSettingsState({
    this.pluginSettingsOverrides = const {},
    this.explorerPluginSettingsOverrides = const {},
    this.typeSpecificSettings,
  });

  ProjectSettingsDto toDto() {
    return ProjectSettingsDto(
      pluginSettingsOverrides: pluginSettingsOverrides.map(
        (type, settings) => MapEntry(type.toString(), settings.toJson()),
      ),
      explorerPluginSettingsOverrides: explorerPluginSettingsOverrides.map(
        (id, settings) => MapEntry(id, settings.toJson()),
      ),
      typeSpecificSettings: typeSpecificSettings?.toJson(),
    );
  }

  ProjectSettingsState copyWith({
    Map<Type, MachineSettings>? pluginSettingsOverrides,
    Map<String, ExplorerPluginSettings>? explorerPluginSettingsOverrides,
    ProjectSettings? typeSpecificSettings,
    bool clearTypeSpecificSettings = false,
  }) {
    return ProjectSettingsState(
      pluginSettingsOverrides:
          pluginSettingsOverrides ?? this.pluginSettingsOverrides,
      explorerPluginSettingsOverrides: explorerPluginSettingsOverrides ??
          this.explorerPluginSettingsOverrides,
      typeSpecificSettings: clearTypeSpecificSettings
          ? null
          : typeSpecificSettings ?? this.typeSpecificSettings,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    final mapEquals = const DeepCollectionEquality().equals;

    return other is ProjectSettingsState &&
        mapEquals(
          other.pluginSettingsOverrides,
          pluginSettingsOverrides,
        ) &&
        mapEquals(
          other.explorerPluginSettingsOverrides,
          explorerPluginSettingsOverrides,
        ) &&
        other.typeSpecificSettings == typeSpecificSettings;
  }

  @override
  int get hashCode => Object.hash(
        const DeepCollectionEquality().hash(pluginSettingsOverrides),
        const DeepCollectionEquality().hash(explorerPluginSettingsOverrides),
        typeSpecificSettings,
      );
}
// FILE: lib/project/project_settings_notifier.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../app/app_notifier.dart';
import '../editor/plugins/editor_plugin_registry.dart';
import '../explorer/explorer_plugin_registry.dart';
import '../settings/settings_notifier.dart';
import 'project_models.dart';
import 'project_settings_models.dart';

final projectSettingsProvider =
    StateNotifierProvider<ProjectSettingsNotifier, ProjectSettingsState?>((ref) {
  return ProjectSettingsNotifier(ref);
});

class ProjectSettingsNotifier extends StateNotifier<ProjectSettingsState?> {
  final Ref _ref;

  ProjectSettingsNotifier(this._ref)
      : super(
          _ref.watch(
            currentProjectProvider.select((p) => p?.settings),
          ),
        ) {
    _ref.listen(currentProjectProvider.select((p) => p?.settings),
        (previous, next) {
      if (mounted) {
        state = next;
      }
    });
  }

  Project? get _currentProject => _ref.read(currentProjectProvider);


  void updateOverride(MachineSettings newSettings) {
    final project = _currentProject;
    if (project == null || state == null) return;

    final clonedSettings = newSettings.clone();

    final Map<Type, MachineSettings> newPluginOverrides =
        Map.from(state!.pluginSettingsOverrides);
    final Map<String, MachineSettings> newExplorerOverrides =
        Map.from(state!.explorerPluginSettingsOverrides);

    if (clonedSettings is ExplorerPluginSettings) {
      final pluginId = _ref
          .read(settingsProvider)
          .explorerPluginSettings
          .entries
          .firstWhere((e) => e.value.runtimeType == clonedSettings.runtimeType)
          .key;
      newExplorerOverrides[pluginId] = clonedSettings;
    } else {
      newPluginOverrides[clonedSettings.runtimeType] = clonedSettings;
    }

    _updateProjectState(state!.copyWith(
      pluginSettingsOverrides: newPluginOverrides,
      explorerPluginSettingsOverrides:
          newExplorerOverrides.cast<String, ExplorerPluginSettings>(),
    ));
  }

  void removeOverride(MachineSettings settingToRemove) {
    final project = _currentProject;
    if (project == null || state == null) return;

    final Map<Type, MachineSettings> newPluginOverrides =
        Map.from(state!.pluginSettingsOverrides);
    final Map<String, MachineSettings> newExplorerOverrides =
        Map.from(state!.explorerPluginSettingsOverrides);

    if (settingToRemove is ExplorerPluginSettings) {
      final pluginId = _ref
          .read(settingsProvider)
          .explorerPluginSettings
          .entries
          .firstWhere((e) => e.value.runtimeType == settingToRemove.runtimeType)
          .key;
      newExplorerOverrides.remove(pluginId);
    } else {
      newPluginOverrides.remove(settingToRemove.runtimeType);
    }

    _updateProjectState(state!.copyWith(
      pluginSettingsOverrides: newPluginOverrides,
      explorerPluginSettingsOverrides:
          newExplorerOverrides.cast<String, ExplorerPluginSettings>(),
    ));
  }

  void updateProjectTypeSettings(ProjectSettings newSettings) {
    final project = _currentProject;
    if (project == null || state == null) return;

    _updateProjectState(
        state!.copyWith(typeSpecificSettings: newSettings));
  }

  void _updateProjectState(ProjectSettingsState newSettingsState) {
    final project = _currentProject;
    if (project == null) return;

    final newProject = project.copyWith(settings: newSettingsState);
    _ref.read(appNotifierProvider.notifier).updateCurrentProject(newProject);
    _ref.read(appNotifierProvider.notifier).saveAppState();
  }
}

final currentProjectProvider = Provider<Project?>((ref) {
  return ref.watch(appNotifierProvider).value?.currentProject;
});

final effectiveSettingsProvider = Provider<AppSettings>((ref) {
  final globalSettings = ref.watch(settingsProvider);
  final projectOverrides = ref.watch(projectSettingsProvider);

  if (projectOverrides == null) {
    return globalSettings;
  }

  final mergedPluginSettings =
      Map<Type, MachineSettings>.from(globalSettings.pluginSettings);
  final mergedExplorerSettings =
      Map<String, MachineSettings>.from(globalSettings.explorerPluginSettings);

  projectOverrides.pluginSettingsOverrides.forEach((type, setting) {
    mergedPluginSettings[type] = setting;
  });

  projectOverrides.explorerPluginSettingsOverrides.forEach((id, setting) {
    mergedExplorerSettings[id] = setting;
  });

  return AppSettings(
    pluginSettings: mergedPluginSettings,
    explorerPluginSettings: mergedExplorerSettings,
  );
});
// FILE: lib/project/project_type_handler.dart

import 'package:flutter/material.dart';

import '../data/repositories/project/project_repository.dart';
import 'project_models.dart';
import 'project_settings_models.dart';

abstract class ProjectTypeHandler {
  String get id;

  String get name;

  String get description;

  IconData get icon;
  
  Future<bool> hasPersistedPermission(ProjectMetadata metadata);
  
  List<String> get supportedPersistenceTypeIds;

  ProjectSettings? get projectTypeSettings;

  Widget buildProjectTypeSettingsUI(
    ProjectSettings settings,
    void Function(ProjectSettings) onChanged,
  );

  Future<ProjectMetadata?> initiateNewProject(
    BuildContext context,
    String persistenceTypeId,
  );

  ProjectRepository createRepository(
    ProjectMetadata metadata, {
    Map<String, dynamic>? projectStateJson,
  });

  Future<bool> recoverPermission(
    ProjectMetadata metadata,
    BuildContext context,
  );
}
// FILE: lib/project/project_type_handler_registry.dart

// NEW FILE: lib/project/project_type_handler_registry.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'handlers/local_project_type_handler.dart';
import 'project_type_handler.dart';

final projectTypeHandlerRegistryProvider = Provider<Map<String, ProjectTypeHandler>>((ref) {
  final handlers = <ProjectTypeHandler>[
    LocalProjectTypeHandler(ref),
  ];

  return {for (var handler in handlers) handler.id: handler};
});
// FILE: lib/settings/setting_override_widget.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/explorer/explorer_plugin_models.dart';
import 'package:machine/project/project_settings_notifier.dart';
import 'package:machine/settings/settings_models.dart';
import 'package:machine/settings/settings_notifier.dart';

class SettingOverrideWidget extends ConsumerWidget {
  final MachineSettings globalSetting;
  final Widget Function(
    BuildContext context,
    MachineSettings effectiveSetting,
    void Function(MachineSettings) onChanged,
  ) childBuilder;

  const SettingOverrideWidget({
    super.key,
    required this.globalSetting,
    required this.childBuilder,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final projectSettingsState = ref.watch(projectSettingsProvider);
    final globalAppSettings = ref.watch(settingsProvider);

    if (projectSettingsState == null) {
      return childBuilder(
        context,
        globalSetting,
        (newSettings) {
          if (newSettings is ExplorerPluginSettings) {
            final pluginId = globalAppSettings.explorerPluginSettings.entries
                .firstWhere(
                    (e) => e.value.runtimeType == newSettings.runtimeType)
                .key;
            ref
                .read(settingsProvider.notifier)
                .updateExplorerPluginSettings(pluginId, newSettings);
          } else {
            ref
                .read(settingsProvider.notifier)
                .updatePluginSettings(newSettings);
          }
        },
      );
    }

    final projectSettingsNotifier = ref.read(projectSettingsProvider.notifier);
    
    bool isOverridden = false;
    MachineSettings? projectOverrideSetting;

    if (globalSetting is ExplorerPluginSettings) {
      final pluginId = globalAppSettings.explorerPluginSettings.entries
          .firstWhere((e) => e.value.runtimeType == globalSetting.runtimeType)
          .key;
      projectOverrideSetting =
          projectSettingsState.explorerPluginSettingsOverrides[pluginId];
      isOverridden = projectOverrideSetting != null;
    } else {
      projectOverrideSetting =
          projectSettingsState.pluginSettingsOverrides[globalSetting.runtimeType];
      isOverridden = projectOverrideSetting != null;
    }

    final MachineSettings effectiveSetting =
        isOverridden ? projectOverrideSetting! : globalSetting;

    final void Function(MachineSettings) onChanged = isOverridden
        ? projectSettingsNotifier.updateOverride
        : (newSettings) {
            if (newSettings is ExplorerPluginSettings) {
              final pluginId = globalAppSettings.explorerPluginSettings.entries
                  .firstWhere(
                      (e) => e.value.runtimeType == newSettings.runtimeType)
                  .key;
              ref
                  .read(settingsProvider.notifier)
                  .updateExplorerPluginSettings(pluginId, newSettings);
            } else {
              ref
                  .read(settingsProvider.notifier)
                  .updatePluginSettings(newSettings);
            }
          };

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            if (isOverridden)
              Icon(
                Icons.push_pin,
                size: 14,
                color: Theme.of(context).colorScheme.primary,
              ),
            const SizedBox(width: 4),
            Text(
              'Override for this project',
              style: Theme.of(context).textTheme.bodySmall,
            ),
            Checkbox(
              value: isOverridden,
              onChanged: (value) {
                if (value == true) {
                  projectSettingsNotifier.updateOverride(globalSetting);
                } else {
                  projectSettingsNotifier.removeOverride(globalSetting);
                }
              },
            ),
          ],
        ),
        childBuilder(context, effectiveSetting, onChanged),
      ],
    );
  }
}
// FILE: lib/settings/settings_models.dart

// FILE: lib/settings/settings_models.dart

import 'package:flutter/material.dart';

abstract class MachineSettings {
  Map<String, dynamic> toJson();
  void fromJson(Map<String, dynamic> json);
  MachineSettings clone();
}

class AppSettings {
  final Map<Type, MachineSettings> pluginSettings;
  final Map<String, MachineSettings> explorerPluginSettings;

  AppSettings({
    required this.pluginSettings,
    required this.explorerPluginSettings,
  });

  AppSettings copyWith({
    Map<Type, MachineSettings>? pluginSettings,
    Map<String, MachineSettings>? explorerPluginSettings,
  }) {
    return AppSettings(
      pluginSettings: pluginSettings ?? this.pluginSettings,
      explorerPluginSettings:
          explorerPluginSettings ?? this.explorerPluginSettings,
    );
  }
}


class GeneralSettings extends MachineSettings {
  bool hideAppBarInFullScreen;
  bool hideTabBarInFullScreen;
  bool hideBottomToolbarInFullScreen;
  ThemeMode themeMode;
  int accentColorValue;
  bool showHiddenFiles;

  GeneralSettings({
    this.hideAppBarInFullScreen = true,
    this.hideTabBarInFullScreen = true,
    this.hideBottomToolbarInFullScreen = true,
    this.themeMode = ThemeMode.dark,
    this.accentColorValue = 0xFFF44336,
    this.showHiddenFiles = false,
  });

  @override
  void fromJson(Map<String, dynamic> json) {
    hideAppBarInFullScreen = json['hideAppBarInFullScreen'] ?? true;
    hideTabBarInFullScreen = json['hideTabBarInFullScreen'] ?? true;
    hideBottomToolbarInFullScreen =
        json['hideBottomToolbarInFullScreen'] ?? true;
    accentColorValue = json['accentColorValue'] ?? 0xFFF44336;
    themeMode = ThemeMode.values.firstWhere(
      (e) => e.name == json['themeMode'],
      orElse: () => ThemeMode.dark,
    );
    showHiddenFiles = json['showHiddenFiles'] ?? false;
  }

  @override
  Map<String, dynamic> toJson() => {
    'hideAppBarInFullScreen': hideAppBarInFullScreen,
    'hideTabBarInFullScreen': hideTabBarInFullScreen,
    'hideBottomToolbarInFullScreen': hideBottomToolbarInFullScreen,
    'accentColorValue': accentColorValue,
    'themeMode': themeMode.name,
    'showHiddenFiles': showHiddenFiles,
  };

  GeneralSettings copyWith({
    bool? hideAppBarInFullScreen,
    bool? hideTabBarInFullScreen,
    bool? hideBottomToolbarInFullScreen,
    ThemeMode? themeMode,
    int? accentColorValue,
    bool? showHiddenFiles,
  }) {
    return GeneralSettings(
      hideAppBarInFullScreen:
          hideAppBarInFullScreen ?? this.hideAppBarInFullScreen,
      hideTabBarInFullScreen:
          hideTabBarInFullScreen ?? this.hideTabBarInFullScreen,
      hideBottomToolbarInFullScreen:
          hideBottomToolbarInFullScreen ?? this.hideBottomToolbarInFullScreen,
      themeMode: themeMode ?? this.themeMode,
      accentColorValue: accentColorValue ?? this.accentColorValue,
      showHiddenFiles: showHiddenFiles ?? this.showHiddenFiles,
    );
  }

  @override
  GeneralSettings clone() {
    return GeneralSettings(
      hideAppBarInFullScreen: this.hideAppBarInFullScreen,
      hideTabBarInFullScreen: this.hideTabBarInFullScreen,
      hideBottomToolbarInFullScreen: this.hideBottomToolbarInFullScreen,
      themeMode: this.themeMode,
      accentColorValue: this.accentColorValue,
      showHiddenFiles: this.showHiddenFiles,
    );
  }
}
// FILE: lib/settings/settings_notifier.dart

// FILE: lib/settings/settings_notifier.dart

import 'dart:async';
import 'dart:convert';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:collection/collection.dart';

import '../editor/plugins/editor_plugin_registry.dart';
import '../explorer/explorer_plugin_registry.dart';
import 'settings_models.dart';

export 'settings_models.dart';
export '../project/project_settings_notifier.dart';

final settingsProvider = StateNotifierProvider<SettingsNotifier, AppSettings>((
  ref,
) {
  final plugins = ref.watch(activePluginsProvider);
  final explorerPlugins = ref.watch(explorerRegistryProvider);
  return SettingsNotifier(plugins: plugins, explorerPlugins: explorerPlugins);
});

class SettingsNotifier extends StateNotifier<AppSettings> {
  SettingsNotifier({
    required List<EditorPlugin> plugins,
    required List<ExplorerPlugin> explorerPlugins,
  }) : super(
          AppSettings(
            pluginSettings: _getDefaultSettings(plugins),
            explorerPluginSettings:
                _getDefaultExplorerSettings(explorerPlugins),
          ),
        ) {
    loadSettings();
  }

  static Map<Type, MachineSettings> _getDefaultSettings(
    List<EditorPlugin> plugins,
  ) {
    final Map<Type, MachineSettings> defaultSettings = {
      GeneralSettings: GeneralSettings(),
    };
    for (final plugin in plugins) {
      if (plugin.settings != null) {
        defaultSettings[plugin.settings.runtimeType] = plugin.settings!;
      }
    }
    return defaultSettings;
  }

  static Map<String, MachineSettings> _getDefaultExplorerSettings(
    List<ExplorerPlugin> explorerPlugins,
  ) {
    final Map<String, MachineSettings> defaultSettings = {};
    for (final plugin in explorerPlugins) {
      if (plugin.settings != null) {
        defaultSettings[plugin.id] = plugin.settings as MachineSettings; 
      }
    }
    return defaultSettings;
  }

  void updatePluginSettings(MachineSettings newSettings) {
    final updatedSettings = Map<Type, MachineSettings>.from(
      state.pluginSettings,
    )..[newSettings.runtimeType] = newSettings;
    state = state.copyWith(pluginSettings: updatedSettings);
    _saveSettings();
  }

  void updateExplorerPluginSettings(
      String pluginId, MachineSettings newSettings) {
    final updatedSettings = Map<String, MachineSettings>.from(
      state.explorerPluginSettings,
    )..[pluginId] = newSettings;
    state = state.copyWith(explorerPluginSettings: updatedSettings);
    _saveSettings();
  }

  Future<void> _saveSettings() async {
    final prefs = await SharedPreferences.getInstance();
    final settingsMap = state.pluginSettings.map(
      (type, settings) => MapEntry(type.toString(), settings.toJson()),
    );
    await prefs.setString('app_settings', jsonEncode(settingsMap));

    final explorerSettingsMap = state.explorerPluginSettings.map(
      (id, settings) => MapEntry(id, settings.toJson()),
    );
    await prefs.setString('explorer_settings', jsonEncode(explorerSettingsMap));
  }

  Future<void> loadSettings() async {
    final prefs = await SharedPreferences.getInstance();
    final settingsJson = prefs.getString('app_settings');

    if (settingsJson != null) {
      final decoded = jsonDecode(settingsJson) as Map<String, dynamic>;
      final newSettings = Map<Type, MachineSettings>.from(state.pluginSettings);

      for (final entry in decoded.entries) {
        final typeString = entry.key;
        final settingsInstance = newSettings.values.firstWhereOrNull(
          (s) => s.runtimeType.toString() == typeString,
        );

        if (settingsInstance != null) {
          settingsInstance.fromJson(entry.value);
          newSettings[settingsInstance.runtimeType] = settingsInstance;
        }
      }
      state = state.copyWith(pluginSettings: newSettings);
    }

    final explorerSettingsJson = prefs.getString('explorer_settings');
    if (explorerSettingsJson != null) {
      final decoded = jsonDecode(explorerSettingsJson) as Map<String, dynamic>;
      final newExplorerSettings = Map<String, MachineSettings>.from(
          state.explorerPluginSettings);

      for (final entry in decoded.entries) {
        final pluginId = entry.key;
        if (newExplorerSettings.containsKey(pluginId)) {
          newExplorerSettings[pluginId]!.fromJson(entry.value);
        }
      }
      state = state.copyWith(explorerPluginSettings: newExplorerSettings);
    }
  }
}
// FILE: lib/settings/settings_screen.dart

import 'package:flutter/material.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:collection/collection.dart';

import '../app/app_notifier.dart';
import '../command/command_notifier.dart';
import '../editor/plugins/editor_plugin_registry.dart';
import '../explorer/explorer_plugin_registry.dart';
import '../project/project_type_handler_registry.dart';
import 'setting_override_widget.dart';
import 'settings_notifier.dart';
import '../project/project_settings_notifier.dart';
import '../project/project_type_handler.dart';
import '../project/project_settings_models.dart';

const Map<String, Color> kAccentColors = {
  'Orange': Colors.orange,
  'Red': Colors.red,
  'Blue': Colors.blue,
  'Green': Colors.green,
  'Purple': Colors.purple,
  'Teal': Colors.teal,
};

class SettingsScreen extends ConsumerWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      appBar: AppBar(title: const Text('Settings')),
      body: _buildPluginSettingsList(context, ref),
    );
  } 

  Widget _buildPluginSettingsList(BuildContext context, WidgetRef ref) {
    final allPlugins = ref.watch(activePluginsProvider);
    final explorerPlugins = ref.watch(explorerRegistryProvider);
    final settings = ref.watch(settingsProvider);
    final generalSettings =
        settings.pluginSettings[GeneralSettings] as GeneralSettings?;
    final activePlugin = ref.watch(
      appNotifierProvider.select(
        (s) => s.value?.currentProject?.session.currentTab?.plugin,
      ),
    );
    
    final currentProject = ref.watch(appNotifierProvider).value?.currentProject;
    final projectTypeHandler = currentProject != null
        ? ref.watch(projectTypeHandlerRegistryProvider)[
            currentProject.metadata.projectTypeId]
        : null;

    final pluginsWithSettings =
        allPlugins.where((p) => p.settings != null).toList();
    if (activePlugin != null && pluginsWithSettings.contains(activePlugin)) {
      pluginsWithSettings.remove(activePlugin);
    }
    final explorerPluginsWithSettings =
      explorerPlugins.where((p) => p.settings != null).toList();


return ListView(
      children: [
        ListTile(
          leading: const Icon(Icons.keyboard),
          title: const Text('Command Customization'),
          trailing: const Icon(Icons.chevron_right),
          onTap: () => Navigator.pushNamed(context, '/command-settings'),
        ),
        if (generalSettings != null) 
        _ExpandableSettingsList(
          title: 'General Settings',
          items: [_GeneralSettingsCard(settings: generalSettings)],
        ),
        if (projectTypeHandler?.projectTypeSettings != null && currentProject?.settings?.typeSpecificSettings != null)
          _ProjectSpecificSettingsCard(
            handler: projectTypeHandler!,
            settings: currentProject!.settings!.typeSpecificSettings!,
          ),
        _ExpandableSettingsList(
          title: 'Explorer Plugins',
          items: explorerPluginsWithSettings
              .where((plugin) => settings.explorerPluginSettings[plugin.id] != null)
              .map(
                (plugin) => _ExplorerPluginSettingsCard(
                  plugin: plugin,
                  settings: settings.explorerPluginSettings[plugin.id]!
                      as ExplorerPluginSettings,
                ),
              )
              .toList(),
        ),
        _ExpandableSettingsList(
          title: 'Editor Plugins',
          items: pluginsWithSettings
              .map(
                (plugin) => _PluginSettingsCard(
                  plugin: plugin,
                  settings: settings.pluginSettings[plugin.settings.runtimeType]!
                      as PluginSettings,
                ),
              )
              .toList(),
        ),
        if (activePlugin != null)
          _PluginSettingsCard(
            expanded: true,
            plugin: activePlugin,
            settings: settings.pluginSettings[activePlugin.settings.runtimeType]!
                as PluginSettings,
          ),
      ],
    );
  }
}

class _ExpandableSettingsList extends StatelessWidget {
  final String title;
  final List<Widget> items;

  const _ExpandableSettingsList({
    Key? key,
    required this.title,
    required this.items,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ExpansionTile(
      title: Text(title),
      children: items,
    );
  }
}

class _GeneralSettingsCard extends ConsumerWidget {
  final GeneralSettings settings;
  const _GeneralSettingsCard({required this.settings});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card(
      margin: const EdgeInsets.all(8),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: SettingOverrideWidget(
          globalSetting: settings,
          childBuilder: (context, effectiveSetting, onChanged) {
            final currentSettings = effectiveSetting as GeneralSettings;

            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('Theme', style: Theme.of(context).textTheme.titleLarge),
                const SizedBox(height: 8),
                _buildAccentColorPicker(
                  context,
                  currentSettings,
                  (newSettings) => onChanged(newSettings),
                ),
                const Divider(height: 32),
                Text('File Explorer', style: Theme.of(context).textTheme.titleLarge),
                const SizedBox(height: 8),
                _buildHiddenFilesSwitch(
                  context,
                  currentSettings,
                  (newSettings) => onChanged(newSettings),
                ),
                const Divider(height: 32),
                Text('Fullscreen Mode', style: Theme.of(context).textTheme.titleLarge),
                const SizedBox(height: 8),
                _buildFullscreenToggles(
                  context,
                  currentSettings,
                  (newSettings) => onChanged(newSettings),
                ),
              ],
            );
          },
        ),
      ),
    );
  }

  Widget _buildAccentColorPicker(
    BuildContext context,
    GeneralSettings effectiveSettings,
    void Function(GeneralSettings) onChanged,
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('Accent Color', style: Theme.of(context).textTheme.titleMedium),
        const SizedBox(height: 8),
        Wrap(
          spacing: 12,
          runSpacing: 12,
          children: kAccentColors.entries.map((entry) {
            final color = entry.value;
            final isSelected = effectiveSettings.accentColorValue == color.value;
            return GestureDetector(
              onTap: () =>
                  onChanged(effectiveSettings.copyWith(accentColorValue: color.value)),
              child: Container(
                width: 40,
                height: 40,
                decoration: BoxDecoration(
                  color: color,
                  shape: BoxShape.circle,
                  border: isSelected
                      ? Border.all(
                          color: Theme.of(context).colorScheme.onSurface,
                          width: 3,
                        )
                      : null,
                ),
              ),
            );
          }).toList(),
        ),
      ],
    );
  }

  Widget _buildHiddenFilesSwitch(
    BuildContext context,
    GeneralSettings effectiveSettings,
    void Function(GeneralSettings) onChanged,
  ) {
    return SwitchListTile(
      title: const Text('Show Hidden Files'),
      subtitle: const Text(
        'Displays files and folders starting with a dot (e.g., .git)',
      ),
      value: effectiveSettings.showHiddenFiles,
      onChanged: (value) =>
          onChanged(effectiveSettings.copyWith(showHiddenFiles: value)),
    );
  }

  Widget _buildFullscreenToggles(
    BuildContext context,
    GeneralSettings effectiveSettings,
    void Function(GeneralSettings) onChanged,
  ) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        SwitchListTile(
          title: const Text('Hide App Bar'),
          value: effectiveSettings.hideAppBarInFullScreen,
          onChanged: (value) =>
              onChanged(effectiveSettings.copyWith(hideAppBarInFullScreen: value)),
        ),
        SwitchListTile(
          title: const Text('Hide Tab Bar'),
          value: effectiveSettings.hideTabBarInFullScreen,
          onChanged: (value) =>
              onChanged(effectiveSettings.copyWith(hideTabBarInFullScreen: value)),
        ),
        SwitchListTile(
          title: const Text('Hide Bottom Toolbar'),
          value: effectiveSettings.hideBottomToolbarInFullScreen,
          onChanged: (value) =>
              onChanged(effectiveSettings.copyWith(hideBottomToolbarInFullScreen: value)),
        ),
      ],
    );
  }
}

class _ProjectSpecificSettingsCard extends ConsumerWidget {
  final ProjectTypeHandler handler;
  final ProjectSettings settings;

  const _ProjectSpecificSettingsCard({
    required this.handler,
    required this.settings,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notifier = ref.read(projectSettingsProvider.notifier);
    return Card(
      margin: const EdgeInsets.all(8),
      child: ExpansionTile(
        initiallyExpanded: true,
        title: Row(
          children: [
            Icon(handler.icon),
            const SizedBox(width: 12),
            Text(
              '${handler.name} Settings',
              style: Theme.of(context).textTheme.titleLarge,
            ),
          ],
        ),
        subtitle: const Text('These settings are specific to this project'),
        children: [
          Padding(
            padding: const EdgeInsets.all(16),
            child: handler.buildProjectTypeSettingsUI(
              settings,
              (newSettings) => notifier.updateProjectTypeSettings(newSettings),
            ),
          ),
        ],
      ),
    );
  }
}

class _PluginSettingsCard extends ConsumerWidget {
  final EditorPlugin plugin;
  final PluginSettings settings;
  final bool expanded;

  const _PluginSettingsCard({required this.plugin, required this.settings, this.expanded = false});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card(
      margin: const EdgeInsets.all(8),
      child: ExpansionTile(
        initiallyExpanded: expanded,
        title: Row(
          children: [
            plugin.icon,
            const SizedBox(width: 12),
            Text(
              plugin.name,
              style: Theme.of(context).textTheme.titleLarge,
            ),
          ],
        ),
        children: [
          Padding(
            padding: const EdgeInsets.all(16),
            child: SettingOverrideWidget(
              globalSetting: settings,
              childBuilder: (context, effectiveSetting, onChanged) {
                return plugin.buildSettingsUI(
                  effectiveSetting as PluginSettings,
                  (newSettings) => onChanged(newSettings),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

class _ExplorerPluginSettingsCard extends ConsumerWidget {
  final ExplorerPlugin plugin;
  final ExplorerPluginSettings settings;

  const _ExplorerPluginSettingsCard({required this.plugin, required this.settings});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card(
      margin: const EdgeInsets.all(8),
      child: ExpansionTile(
        title: Row(
          children: [
            Icon(plugin.icon),
            const SizedBox(width: 12),
            Text(
              plugin.name,
              style: Theme.of(context).textTheme.titleLarge,
            ),
          ],
        ),
        children: [
          Padding(
            padding: const EdgeInsets.all(16),
            child: SettingOverrideWidget(
              globalSetting: settings,
              childBuilder: (context, effectiveSetting, onChanged) {
                return plugin.buildSettingsUI(
                  effectiveSetting as ExplorerPluginSettings,
                  (newSettings) => onChanged(newSettings),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

class CommandSettingsScreen extends ConsumerWidget {
  const CommandSettingsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(commandProvider);

    return Scaffold(
      appBar: AppBar(title: const Text('Command Customization')),
      floatingActionButton: FloatingActionButton.extended(
        icon: const Icon(Icons.add),
        label: const Text('New Group'),
        onPressed:
            () => showDialog(
              context: context,
              builder: (_) => GroupEditorDialog(ref: ref),
            ),
      ),
      body: ListView(
        padding: const EdgeInsets.only(bottom: 80),
        children: [
          ...state.availablePositions.map((position) {
            return _buildSection(
              context,
              ref,
              position,
              state.orderedCommandsByPosition[position.id] ?? [],
            );
          }),
          ...state.commandGroups.values.map(
            (group) => _buildGroupSection(context, ref, group),
          ),
          _buildSection(
            context,
            ref,
            AppCommandPositions.hidden,
            state.hiddenOrder,
          ),
        ],
      ),
    );
  }

  Widget _buildGroupSection(
    BuildContext context,
    WidgetRef ref,
    CommandGroup group,
  ) {
    return ExpansionTile(
      leading: group.finalIcon,
      title: Text(group.label),
      initiallyExpanded: true,
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          IconButton(
            icon: const Icon(Icons.edit),
            tooltip: group.isDeletable ? 'Edit Group' : 'Customize Group',
            onPressed: () => showDialog(
              context: context,
              builder: (_) => GroupEditorDialog(ref: ref, group: group),
            ),
          ),
          if (group.isDeletable)
            IconButton(
              icon: const Icon(Icons.delete, color: Colors.redAccent),
              onPressed: () =>
                  ref.read(commandProvider.notifier).deleteGroup(group.id),
            ),
        ],
      ),
      children: [
        _buildReorderableList(
          context,
          ref,
          group.commandIds,
          positionId: group.id,
        ),
      ],
    );
  }

  Widget _buildSection(
    BuildContext context,
    WidgetRef ref,
    CommandPosition position,
    List<String> itemIds,
  ) {
    return ExpansionTile(
      leading: Icon(position.icon),
      title: Text(position.label),
      initiallyExpanded: true,
      children: [
        _buildReorderableList(context, ref, itemIds, positionId: position.id),
      ],
    );
  }

  Widget _buildReorderableList(
    BuildContext context,
    WidgetRef ref,
    List<String> itemIds, {
    required String positionId,
  }) {
    final state = ref.watch(commandProvider);
    final notifier = ref.read(commandProvider.notifier);
    
    final originalPluginGroups = notifier.pluginDefinedGroups;

    final currentPosition = state.availablePositions.firstWhereOrNull(
      (p) => p.id == positionId,
    );
    final currentGroup = state.commandGroups[positionId];
    
    return Column(
      children: [
        ReorderableListView.builder(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          itemCount: itemIds.length,
          itemBuilder: (ctx, index) {
            final itemId = itemIds[index];
            final Widget itemWidget;
            
            bool canBeRemoved = true;
            if (positionId == AppCommandPositions.hidden.id) {
              canBeRemoved = false;
            } else if (currentPosition?.mandatoryCommands.contains(itemId) ?? false) {
              canBeRemoved = false;
            } else if (currentGroup != null && !currentGroup.isDeletable) {
              final originalGroupDef = originalPluginGroups[currentGroup.id];
              if (originalGroupDef?.commandIds.contains(itemId) ?? false) {
                canBeRemoved = false;
              }
            }

            if (state.commandGroups.containsKey(itemId)) {
              final group = state.commandGroups[itemId]!;
              itemWidget = ListTile(
                key: ValueKey(group.id),
                leading: const Icon(Icons.drag_handle),
                title: Row(
                  children: [
                    group.finalIcon,
                    const SizedBox(width: 12),
                    Text(
                      group.label,
                      style: const TextStyle(fontWeight: FontWeight.bold),
                    ),
                  ],
                ),
                trailing: !canBeRemoved
                    ? null
                        : IconButton(
                          icon: const Icon(
                            Icons.remove_circle_outline,
                            color: Colors.redAccent,
                          ),
                          tooltip: 'Remove from this list',
                          onPressed:
                              () => notifier.removeItemFromList(
                                itemId: itemId,
                                fromPositionId: positionId,
                              ),
                        ),
              );
            } else {
              final sources = state.commandSources[itemId];
              if (sources == null || sources.isEmpty) {
                return ListTile(
                  key: ValueKey(itemId),
                  title: Text('Error: Stale command ID "$itemId"'),
                );
              }
              final command = notifier.getCommand(itemId, sources.first);
              if (command == null) {
                return ListTile(
                  key: ValueKey(itemId),
                  title: Text('Error: Command "$itemId" not found'),
                );
              }
              itemWidget = ListTile(
                key: ValueKey(command!.id + positionId),
                leading: const Icon(Icons.drag_handle),
                title: Row(
                  children: [
                    command.icon,
                    const SizedBox(width: 12),
                    Expanded(
                      child: Text(
                        command.label,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
                subtitle:
                    sources.length > 1
                        ? Text('From: ${sources.join(', ')}')
                        : null,
                trailing: !canBeRemoved
                    ? null
                    : IconButton(
                        icon: const Icon(
                          Icons.remove_circle_outline,
                          color: Colors.redAccent,
                        ),
                        tooltip: 'Remove from this list',
                        onPressed: () => notifier.removeItemFromList(
                          itemId: command.id,
                          fromPositionId: positionId,
                        ),
                      ),
              );
            }
            return itemWidget;
          },
          onReorder: (oldIndex, newIndex) {
            notifier.reorderItemInList(
              positionId: positionId,
              oldIndex: oldIndex,
              newIndex: newIndex,
            );
          },
        ),
        if (positionId != AppCommandPositions.hidden.id)
          Padding(
            padding: const EdgeInsets.only(right: 16.0, bottom: 8.0),
            child: Align(
              alignment: Alignment.centerRight,
              child: IconButton(
                icon: const Icon(Icons.add_circle_outline),
                tooltip: 'Add item to this section',
                onPressed:
                    () => showDialog(
                      context: context,
                      builder:
                          (_) =>
                              AddItemDialog(ref: ref, toPositionId: positionId),
                    ),
              ),
            ),
          ),
      ],
    );
  }
}
class AddItemDialog extends ConsumerStatefulWidget {
  final WidgetRef ref;
  final String toPositionId;
  const AddItemDialog({
    super.key,
    required this.ref,
    required this.toPositionId,
  });

  @override
  ConsumerState<AddItemDialog> createState() => _AddItemDialogState();
}

class _AddItemDialogState extends ConsumerState<AddItemDialog> {
  final _searchController = TextEditingController();
  String _query = '';

  @override
  void initState() {
    super.initState();
    _searchController.addListener(
      () => setState(() => _query = _searchController.text.toLowerCase()),
    );
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final notifier = widget.ref.read(commandProvider.notifier);
    final state = widget.ref.watch(commandProvider);
    final bool isAddingToGroup = widget.toPositionId.startsWith('group_');
    final allCommands =
        {
          for (var cmd in notifier.allRegisteredCommands) cmd.id: cmd,
        }.values.toList();
    final allGroups = state.commandGroups.values.toList();
    final query = _query;
    final filteredCommands =
        allCommands
            .where((cmd) => cmd.label.toLowerCase().contains(query))
            .toList();
    final filteredGroups =
        allGroups
            .where((group) => group.label.toLowerCase().contains(query))
            .toList();

    return AlertDialog(
      title: const Text('Add Item'),
      content: SizedBox(
        width: double.maxFinite,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: _searchController,
              decoration: const InputDecoration(labelText: 'Search items...'),
              autofocus: true,
            ),
            const SizedBox(height: 10),
            Expanded(
              child: ListView(
                shrinkWrap: true,
                children: [
                  if (!isAddingToGroup && filteredGroups.isNotEmpty) ...[
                    const Text(
                      'Groups',
                      style: TextStyle(fontWeight: FontWeight.bold),
                    ),
                    ...filteredGroups.map(
                      (group) => ListTile(
                        leading: group.icon,
                        title: Text(group.label),
                        onTap: () {
                          notifier.addItemToList(
                            itemId: group.id,
                            toPositionId: widget.toPositionId,
                          );
                          Navigator.of(context).pop();
                        },
                      ),
                    ),
                    const Divider(),
                  ],
                  const Text(
                    'Commands',
                    style: TextStyle(fontWeight: FontWeight.bold),
                  ),
                  ...filteredCommands.map(
                    (command) => ListTile(
                      leading: command.icon,
                      title: Text(command.label),
                      subtitle: Text(command.sourcePlugin),
                      onTap: () {
                        notifier.addItemToList(
                          itemId: command.id,
                          toPositionId: widget.toPositionId,
                        );
                        Navigator.of(context).pop();
                      },
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}
class GroupEditorDialog extends StatefulWidget {
  final WidgetRef ref;
  final CommandGroup? group;
  const GroupEditorDialog({super.key, required this.ref, this.group});

  @override
  State<GroupEditorDialog> createState() => _GroupEditorDialogState();
}

class _GroupEditorDialogState extends State<GroupEditorDialog> {
  late final TextEditingController _nameController;
  late String _selectedIconName;
  late bool _showLabels; 
  late bool _isPluginGroup;

  @override
  void initState() {
    super.initState();
    _isPluginGroup = !(widget.group?.isDeletable ?? true);
    _nameController = TextEditingController(text: widget.group?.label ?? '');
    _selectedIconName =
        widget.group?.iconName ?? CommandIcon.availableIcons.keys.first;
    _showLabels = widget.group?.showLabels ?? true;
  }

  @override
  void dispose() {
    _nameController.dispose();
    super.dispose();
  }

  void _onConfirm() {
    final notifier = widget.ref.read(commandProvider.notifier);
    final name = _nameController.text.trim();
    if (name.isEmpty) return;

    if (widget.group == null) {
      notifier.createGroup(
        name: name,
        iconName: _selectedIconName,
        showLabels: _showLabels, 
      );
    } else {
      notifier.updateGroup(
        widget.group!.id,
        newName: name,
        newIconName: _selectedIconName,
        newShowLabels: _showLabels, 
      );
    }
    Navigator.of(context).pop();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(widget.group == null ? 'New Command Group' : 'Edit Group'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          TextField(
            controller: _nameController,
            decoration: const InputDecoration(labelText: 'Group Name'),
            autofocus: !_isPluginGroup,
            readOnly: _isPluginGroup,
          ),
          const SizedBox(height: 20),
          ListTile(
            contentPadding: EdgeInsets.zero,
            leading: widget.group?.finalIcon ?? CommandIcon.getIcon(_selectedIconName),
            title: const Text('Group Icon'),
            trailing: _isPluginGroup ? null : const Icon(Icons.arrow_drop_down),
            onTap: _isPluginGroup
                ? null
                : () async {
              final String? newIcon = await showDialog(
                context: context,
                builder: (_) => const IconPickerDialog(),
              );
              if (newIcon != null) {
                setState(() => _selectedIconName = newIcon);
              }
            },
          ),
          SwitchListTile(
            title: const Text('Show Command Labels'),
            value: _showLabels,
            onChanged: (value) {
              setState(() {
                _showLabels = value;
              });
            },
            contentPadding: EdgeInsets.zero,
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        FilledButton(onPressed: _onConfirm, child: const Text('Confirm')),
      ],
    );
  }
}

class IconPickerDialog extends StatelessWidget {
  const IconPickerDialog({super.key});

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Select an Icon'),
      content: SizedBox(
        width: double.maxFinite,
        child: GridView.builder(
          shrinkWrap: true,
          gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: 5,
          ),
          itemCount: CommandIcon.availableIcons.length,
          itemBuilder: (context, index) {
            final iconName = CommandIcon.availableIcons.keys.elementAt(index);
            return IconButton(
              icon: CommandIcon.getIcon(iconName),
              onPressed: () => Navigator.of(context).pop(iconName),
              tooltip: iconName,
            );
          },
        ),
      ),
    );
  }
}

// FILE: lib/utils/clipboard.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';

final clipboardProvider = StateProvider<ClipboardItem?>((ref) => null);

enum ClipboardOperation { cut, copy }

class ClipboardItem {
  final String uri;
  final bool isFolder;
  final ClipboardOperation operation;
  ClipboardItem({
    required this.uri,
    required this.isFolder,
    required this.operation,
  });
}

// FILE: lib/utils/code_themes.dart


import 'package:flutter/material.dart';
import 'package:re_editor/re_editor.dart';


import 'package:re_highlight/languages/bash.dart';
import 'package:re_highlight/languages/cpp.dart';
import 'package:re_highlight/languages/css.dart';
import 'package:re_highlight/languages/dart.dart';
import 'package:re_highlight/languages/java.dart';
import 'package:re_highlight/languages/javascript.dart';
import 'package:re_highlight/languages/json.dart';
import 'package:re_highlight/languages/kotlin.dart';
import 'package:re_highlight/languages/latex.dart';
import 'package:re_highlight/languages/markdown.dart';
import 'package:re_highlight/languages/plaintext.dart';
import 'package:re_highlight/languages/properties.dart';
import 'package:re_highlight/languages/python.dart';
import 'package:re_highlight/languages/typescript.dart';
import 'package:re_highlight/languages/xml.dart';
import 'package:re_highlight/languages/yaml.dart';
import 'package:re_highlight/styles/agate.dart';
import 'package:re_highlight/styles/an-old-hope.dart';
import 'package:re_highlight/styles/androidstudio.dart';
import 'package:re_highlight/styles/arduino-light.dart';
import 'package:re_highlight/styles/arta.dart';
import 'package:re_highlight/styles/ascetic.dart';
import 'package:re_highlight/styles/atom-one-dark-reasonable.dart';
import 'package:re_highlight/styles/atom-one-dark.dart';
import 'package:re_highlight/styles/atom-one-light.dart';
import 'package:re_highlight/styles/brown-paper.dart';
import 'package:re_highlight/styles/codepen-embed.dart';
import 'package:re_highlight/styles/color-brewer.dart';
import 'package:re_highlight/styles/dark.dart';
import 'package:re_highlight/styles/default.dart';
import 'package:re_highlight/styles/devibeans.dart';
import 'package:re_highlight/styles/docco.dart';
import 'package:re_highlight/styles/far.dart';
import 'package:re_highlight/styles/felipec.dart';
import 'package:re_highlight/styles/foundation.dart';
import 'package:re_highlight/styles/github-dark-dimmed.dart';
import 'package:re_highlight/styles/github-dark.dart';
import 'package:re_highlight/styles/github.dart';
import 'package:re_highlight/styles/gml.dart';
import 'package:re_highlight/styles/googlecode.dart';
import 'package:re_highlight/styles/gradient-dark.dart';
import 'package:re_highlight/styles/gradient-light.dart';
import 'package:re_highlight/styles/grayscale.dart';
import 'package:re_highlight/styles/hybrid.dart';
import 'package:re_highlight/styles/idea.dart';
import 'package:re_highlight/styles/intellij-light.dart';
import 'package:re_highlight/styles/ir-black.dart';
import 'package:re_highlight/styles/isbl-editor-dark.dart';
import 'package:re_highlight/styles/isbl-editor-light.dart';
import 'package:re_highlight/styles/kimbie-dark.dart';
import 'package:re_highlight/styles/kimbie-light.dart';
import 'package:re_highlight/styles/lightfair.dart';
import 'package:re_highlight/styles/lioshi.dart';
import 'package:re_highlight/styles/magula.dart';
import 'package:re_highlight/styles/mono-blue.dart';
import 'package:re_highlight/styles/monokai-sublime.dart';
import 'package:re_highlight/styles/monokai.dart';
import 'package:re_highlight/styles/night-owl.dart';
import 'package:re_highlight/styles/nnfx-dark.dart';
import 'package:re_highlight/styles/nnfx-light.dart';
import 'package:re_highlight/styles/nord.dart';
import 'package:re_highlight/styles/obsidian.dart';
import 'package:re_highlight/styles/panda-syntax-dark.dart';
import 'package:re_highlight/styles/panda-syntax-light.dart';
import 'package:re_highlight/styles/paraiso-dark.dart';
import 'package:re_highlight/styles/paraiso-light.dart';
import 'package:re_highlight/styles/pojoaque.dart';
import 'package:re_highlight/styles/purebasic.dart';
import 'package:re_highlight/styles/qtcreator-dark.dart';
import 'package:re_highlight/styles/qtcreator-light.dart';
import 'package:re_highlight/styles/rainbow.dart';
import 'package:re_highlight/styles/routeros.dart';
import 'package:re_highlight/styles/school-book.dart';
import 'package:re_highlight/styles/shades-of-purple.dart';
import 'package:re_highlight/styles/srcery.dart';
import 'package:re_highlight/styles/stackoverflow-dark.dart';
import 'package:re_highlight/styles/stackoverflow-light.dart';
import 'package:re_highlight/styles/sunburst.dart';
import 'package:re_highlight/styles/tokyo-night-dark.dart';
import 'package:re_highlight/styles/tokyo-night-light.dart';
import 'package:re_highlight/styles/tomorrow-night-blue.dart';
import 'package:re_highlight/styles/tomorrow-night-bright.dart';
import 'package:re_highlight/styles/vs.dart';
import 'package:re_highlight/styles/vs2015.dart';
import 'package:re_highlight/styles/xcode.dart';
import 'package:re_highlight/styles/xt256.dart';


class CodeThemes {
  static final Map<String, Map<String, TextStyle>> availableCodeThemes = {
    'Atom One Dark': atomOneDarkTheme,

    'Agate': agateTheme,
    'An Old Hope': anOldHopeTheme,
    'Android Studio': androidstudioTheme,
    'Arduino Light': arduinoLightTheme,
    'Arta': artaTheme,
    'Ascetic': asceticTheme,
    'Atom One Dark Reasonable': atomOneDarkReasonableTheme,
    'Atom One Light': atomOneLightTheme,
    'Brown Paper': brownPaperTheme,
    'CodePen Embed': codepenEmbedTheme,
    'Color Brewer': colorBrewerTheme,
    'Dark': darkTheme,
    'Default': defaultTheme,
    'Devibeans': devibeansTheme,
    'Docco': doccoTheme,
    'Far': farTheme,
    'Felipec': felipecTheme,
    'Foundation': foundationTheme,
    'GitHub Dark Dimmed': githubDarkDimmedTheme,
    'GitHub Dark': githubDarkTheme,
    'GitHub': githubTheme,
    'GML': gmlTheme,
    'Google Code': googlecodeTheme,
    'Gradient Dark': gradientDarkTheme,
    'Gradient Light': gradientLightTheme,
    'Grayscale': grayscaleTheme,
    'Hybrid': hybridTheme,
    'Idea': ideaTheme,
    'IntelliJ Light': intellijLightTheme,
    'IR Black': irBlackTheme,
    'ISBL Editor Dark': isblEditorDarkTheme,
    'ISBL Editor Light': isblEditorLightTheme,
    'Kimbie Dark': kimbieDarkTheme,
    'Kimbie Light': kimbieLightTheme,
    'Lightfair': lightfairTheme,
    'Lioshi': lioshiTheme,
    'Magula': magulaTheme,
    'Mono Blue': monoBlueTheme,
    'Monokai Sublime': monokaiSublimeTheme,
    'Monokai': monokaiTheme,
    'Night Owl': nightOwlTheme,
    'NNFX Dark': nnfxDarkTheme,
    'NNFX Light': nnfxLightTheme,
    'Nord': nordTheme,
    'Obsidian': obsidianTheme,
    'Panda Syntax Dark': pandaSyntaxDarkTheme,
    'Panda Syntax Light': pandaSyntaxLightTheme,
    'Paraiso Dark': paraisoDarkTheme,
    'Paraiso Light': paraisoLightTheme,
    'Pojoaque': pojoaqueTheme,
    'PureBasic': purebasicTheme,
    'QtCreator Dark': qtcreatorDarkTheme,
    'QtCreator Light': qtcreatorLightTheme,
    'Rainbow': rainbowTheme,
    'RouterOS': routerosTheme,
    'School Book': schoolBookTheme,
    'Shades of Purple': shadesOfPurpleTheme,
    'Srcery': srceryTheme,
    'StackOverflow Dark': stackoverflowDarkTheme,
    'StackOverflow Light': stackoverflowLightTheme,
    'Sunburst': sunburstTheme,
    'Tokyo Night Dark': tokyoNightDarkTheme,
    'Tokyo Night Light': tokyoNightLightTheme,
    'Tomorrow Night Blue': tomorrowNightBlueTheme,
    'Tomorrow Night Bright': tomorrowNightBrightTheme,
    'VS': vsTheme,
    'VS2015': vs2015Theme,
    'Xcode': xcodeTheme,
    'XT256': xt256Theme,
  };


  // TODO: sort and remove rest of file as legacy code
  static final Map<String, dynamic> languageNameToModeMap = {
    'dart': langDart,
    'python': langPython,
    'javascript': langJavascript,
    'typescript': langTypescript,
    'java': langJava,
    'cpp': langCpp,
    'latex': langLatex,
    'css': langCss,
    'json': langJson,
    'yaml': langYaml,
    'markdown': langMarkdown,
    'kotlin': langKotlin,
    'bash': langBash,
    'xml': langXml,
    'plaintext': langPlaintext,
    'properties': langProperties,
  };

  // Map of file extensions to their corresponding language names (as before)
  static const Map<String, String> languageExtToNameMap = {
    'dart': 'dart',
    'js': 'javascript',
    'jsx': 'javascript',
    'mjs': 'javascript',
    'npmrc': 'javascript',
    'ts': 'typescript',
    'py': 'python',
    'java': 'java',
    'cpp': 'cpp',
    'cc': 'cpp',
    'h': 'cpp',
    'css': 'css',
    'kt': 'kotlin',
    'kts': 'kotlin',
    'json': 'json',
    'htm': 'xml',
    'html': 'xml',
    'xml': 'xml',
    'yaml': 'yaml',
    'yml': 'yaml',
    'md': 'markdown',
    'sh': 'bash',
    'tex': 'latex',
    'gitignore': 'plaintext',
    'txt': 'plaintext',
    'properties': 'properties',
  };

  static String inferLanguageKey(String uri) {
    final ext = uri.split('.').last.toLowerCase();
    return languageExtToNameMap[ext] ?? 'plaintext';
  }

  static Map<String, CodeHighlightThemeMode> getHighlightThemeMode(
    String? langKey,
  ) {
    final effectiveLangKey = langKey ?? 'plaintext';
    final mode = languageNameToModeMap[effectiveLangKey];
    if (mode != null) {
      return {effectiveLangKey: CodeHighlightThemeMode(mode: mode)};
    }
    return {'plaintext': CodeHighlightThemeMode(mode: langPlaintext)};
  }

  static String formatLanguageName(String key) {
    if (key == 'cpp') return 'C++';
    if (key == 'javascript') return 'JavaScript';
    if (key == 'typescript') return 'TypeScript';
    if (key == 'markdown') return 'Markdown';
    if (key == 'kotlin') return 'Kotlin';
    return key[0].toUpperCase() + key.substring(1);
  }
}

// FILE: lib/utils/file_traversal_util.dart

import 'dart:async';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:glob/glob.dart';
import 'package:collection/collection.dart';
import '../app/app_notifier.dart';
import '../data/file_handler/file_handler.dart';
import '../data/repositories/project/project_repository.dart';
import '../project/services/project_hierarchy_service.dart';
import '../settings/settings_notifier.dart';

typedef _CompiledGlob = ({Glob glob, bool isDirectoryOnly});

class FileTraversalUtil {
  static Future<void> traverseProject({
    required Ref ref,
    required String startDirectoryUri,
    required Set<String> supportedExtensions,
    required Set<String> ignoredGlobPatterns,
    required bool useProjectGitignore,
    required Future<void> Function(
      ProjectDocumentFile file,
      String displayPath,
    ) onFileFound,
  }) async {
    final repo = ref.read(projectRepositoryProvider);
    final projectRootUri =
        ref.read(appNotifierProvider).value?.currentProject?.rootUri;
    final showHidden = ref.read(
      effectiveSettingsProvider.select((s) {
        final generalSettings =
            s.pluginSettings[GeneralSettings] as GeneralSettings?;
        return generalSettings?.showHiddenFiles ?? false;
      }),
    );

    if (repo == null || projectRootUri == null) return;

    final hierarchyNotifier = ref.read(
      projectHierarchyServiceProvider.notifier,
    );

    await _recursiveTraverse(
      repo: repo,
      hierarchyNotifier: hierarchyNotifier,
      directoryUri: startDirectoryUri,
      projectRootUri: projectRootUri,
      showHidden: showHidden,
      supportedExtensions: supportedExtensions,
      accumulatedIgnoreGlobs: _compileGlobs(ignoredGlobPatterns),
      useProjectGitignore: useProjectGitignore,
      onFileFound: onFileFound,
    );
  }

  static Future<void> _recursiveTraverse({
    required ProjectRepository repo,
    required ProjectHierarchyService hierarchyNotifier,
    required String directoryUri,
    required String projectRootUri,
    required bool showHidden,
    required Set<String> supportedExtensions,
    required List<_CompiledGlob> accumulatedIgnoreGlobs,
    required bool useProjectGitignore,
    required Future<void> Function(
      ProjectDocumentFile file,
      String displayPath,
    ) onFileFound,
  }) async {
    var directoryState = hierarchyNotifier.state[directoryUri];
    if (directoryState == null || directoryState is! AsyncData) {
      await hierarchyNotifier.loadDirectory(directoryUri);
      directoryState = hierarchyNotifier.state[directoryUri];
    }
    final entries =
        directoryState?.valueOrNull?.map((node) => node.file).toList() ?? [];

    List<_CompiledGlob> currentScopeGlobs = [...accumulatedIgnoreGlobs];

    final gitignoreFile = entries.firstWhereOrNull(
      (f) => f.name == '.gitignore',
    );

    if (gitignoreFile != null && useProjectGitignore) {
      try {
        final content = await repo.readFile(gitignoreFile.uri);
        final patterns = content
            .split('\n')
            .map((l) => l.trim())
            .where((l) => l.isNotEmpty && !l.startsWith('#'))
            .toSet();
        currentScopeGlobs.addAll(_compileGlobs(patterns));
      } catch (_) {}
    }

    final List<Future<void>> subDirectoryFutures = [];

    for (final entry in entries) {
      final relativePath = repo.fileHandler
          .getPathForDisplay(entry.uri, relativeTo: projectRootUri)
          .replaceAll(r'\', '/');

      bool isIgnored = currentScopeGlobs.any(
        (g) =>
            !(g.isDirectoryOnly && !entry.isDirectory) &&
            g.glob.matches(relativePath),
      );
      if (isIgnored) continue;

      if (entry.isDirectory) {
        subDirectoryFutures.add(
          _recursiveTraverse(
            repo: repo,
            hierarchyNotifier: hierarchyNotifier,
            directoryUri: entry.uri,
            projectRootUri: projectRootUri,
            showHidden: showHidden,
            supportedExtensions: supportedExtensions,
            accumulatedIgnoreGlobs: currentScopeGlobs, 
            useProjectGitignore: useProjectGitignore,
            onFileFound: onFileFound,
          ),
        );
      } else {
        if (supportedExtensions.isEmpty ||
            supportedExtensions.any(
              (ext) => relativePath.endsWith(ext),
            )) {
          await onFileFound(entry, relativePath);
        }
      }
    }
    await Future.wait(subDirectoryFutures);
  }

  static List<_CompiledGlob> _compileGlobs(Set<String> patterns) {
    return patterns.map((p) {
      final isDirOnly = p.endsWith('/');
      final cleanPattern = isDirOnly ? p.substring(0, p.length - 1) : p;
      return (glob: Glob(cleanPattern), isDirectoryOnly: isDirOnly);
    }).toList();
  }
}
// FILE: lib/utils/llm_highlight_util.dart

// FILE: lib/editor/plugins/llm_editor/llm_highlight_util.dart

import 'package:re_highlight/languages/all.dart';
import 'package:re_highlight/re_highlight.dart';

class LlmHighlightUtil {
  static final Highlight _highlightInstance = Highlight();
  static bool _languagesRegistered = false;

  static Highlight get highlight {
    ensureLanguagesRegistered();
    return _highlightInstance;
  }

  static void ensureLanguagesRegistered() {
    if (!_languagesRegistered) {
      _highlightInstance.registerLanguages(builtinAllLanguages);
      _languagesRegistered = true;
    }
  }
}

// FILE: lib/utils/texture_packer_algo.dart

import 'dart:math';

class PackerInputItem<T> {
  final double width;
  final double height;
  final T data;

  PackerInputItem({
    required this.width,
    required this.height,
    required this.data,
  });
}

class PackerOutputItem<T> {
  final double x;
  final double y;
  final double width;
  final double height;
  final T data;

  PackerOutputItem({
    required this.x,
    required this.y,
    required this.width,
    required this.height,
    required this.data,
  });
}

class TexturePackerResult<T> {
  final double width;
  final double height;
  final List<PackerOutputItem<T>> items;

  TexturePackerResult({
    required this.width,
    required this.height,
    required this.items,
  });
}

class MaxRectsPacker {
  final int maxWidth;
  final int maxHeight;
  final bool allowRotation;
  final int padding;

  final List<Rectangle<int>> _freeRects = [];
  
  MaxRectsPacker({
    this.maxWidth = 2048,
    this.maxHeight = 2048,
    this.allowRotation = false,
    this.padding = 0,
  });

  TexturePackerResult<T> pack<T>(List<PackerInputItem<T>> items) {
    items.sort((a, b) => max(b.width, b.height).compareTo(max(a.width, a.height)));

    _freeRects.clear();
    _freeRects.add(Rectangle(0, 0, maxWidth, maxHeight));

    final List<PackerOutputItem<T>> packedItems = [];
    
    double usedWidth = 0;
    double usedHeight = 0;

    for (final item in items) {
      final w = item.width.ceil() + padding;
      final h = item.height.ceil() + padding;
      
      final node = _findBestNode(w, h);
      
      if (node != null) {
        final int placedX = node.left;
        final int placedY = node.top;
        
        _splitFreeNode(Rectangle(placedX, placedY, w, h));
        
        packedItems.add(PackerOutputItem(
          x: placedX.toDouble(),
          y: placedY.toDouble(),
          width: item.width,
          height: item.height,
          data: item.data,
        ));

        usedWidth = max(usedWidth, placedX + w.toDouble());
        usedHeight = max(usedHeight, placedY + h.toDouble());
      } else {
        print('Warning: Could not fit item of size ${item.width}x${item.height} in atlas.');
      }
    }

    return TexturePackerResult(
      width: _nextPowerOfTwo(usedWidth),
      height: _nextPowerOfTwo(usedHeight),
      items: packedItems,
    );
  }

  Rectangle<int>? _findBestNode(int w, int h) {
    Rectangle<int>? bestNode;
    int bestShortSideFit = 0x7FFFFFFF;
    int bestLongSideFit = 0x7FFFFFFF;

    for (final freeRect in _freeRects) {
      if (freeRect.width >= w && freeRect.height >= h) {
        final leftoverX = (freeRect.width - w).abs();
        final leftoverY = (freeRect.height - h).abs();
        final shortSideFit = min(leftoverX, leftoverY);
        final longSideFit = max(leftoverX, leftoverY);

        if (shortSideFit < bestShortSideFit || (shortSideFit == bestShortSideFit && longSideFit < bestLongSideFit)) {
          bestNode = Rectangle(freeRect.left, freeRect.top, w, h);
          bestShortSideFit = shortSideFit;
          bestLongSideFit = longSideFit;
        }
      }
    }
    return bestNode;
  }

  void _splitFreeNode(Rectangle<int> usedNode) {
    final List<Rectangle<int>> newFreeRects = [];
    
    for (final freeRect in _freeRects) {
      if (!_intersects(freeRect, usedNode)) {
        newFreeRects.add(freeRect);
        continue;
      }

      if (usedNode.top < freeRect.top + freeRect.height && usedNode.top + usedNode.height > freeRect.top) {
        if (usedNode.left > freeRect.left && usedNode.left < freeRect.left + freeRect.width) {
          newFreeRects.add(Rectangle(
            freeRect.left, 
            freeRect.top, 
            usedNode.left - freeRect.left, 
            freeRect.height
          ));
        }
        if (usedNode.left + usedNode.width < freeRect.left + freeRect.width) {
          newFreeRects.add(Rectangle(
            usedNode.left + usedNode.width,
            freeRect.top,
            freeRect.left + freeRect.width - (usedNode.left + usedNode.width),
            freeRect.height
          ));
        }
      }

      if (usedNode.left < freeRect.left + freeRect.width && usedNode.left + usedNode.width > freeRect.left) {
        if (usedNode.top > freeRect.top && usedNode.top < freeRect.top + freeRect.height) {
          newFreeRects.add(Rectangle(
            freeRect.left,
            freeRect.top,
            freeRect.width,
            usedNode.top - freeRect.top
          ));
        }
        if (usedNode.top + usedNode.height < freeRect.top + freeRect.height) {
          newFreeRects.add(Rectangle(
            freeRect.left,
            usedNode.top + usedNode.height,
            freeRect.width,
            freeRect.top + freeRect.height - (usedNode.top + usedNode.height)
          ));
        }
      }
    }
    
    _freeRects.clear();
    for(final rect in newFreeRects) {
      _freeRects.add(rect);
    }
  }

  bool _intersects(Rectangle<int> a, Rectangle<int> b) {
    return a.left < b.left + b.width &&
           a.left + a.width > b.left &&
           a.top < b.top + b.height &&
           a.top + a.height > b.top;
  }

  double _nextPowerOfTwo(double v) {
    int val = v.ceil();
    int power = 1;
    while (power < val) power *= 2;
    return power.toDouble();
  }
}
// FILE: lib/utils/toast.dart

import 'package:flutter/material.dart';

import 'package:fluttertoast/fluttertoast.dart';

class MachineToast {
  static void info(String message) {
    Fluttertoast.showToast(
      msg: message,
      toastLength: Toast.LENGTH_SHORT,
      gravity: ToastGravity.BOTTOM,
      timeInSecForIosWeb: 1,
      backgroundColor: Colors.black,
      textColor: Colors.white,
      fontSize: 16.0,
    );
  }

  static void error(String message) {
    Fluttertoast.showToast(
      msg: message,
      toastLength: Toast.LENGTH_LONG,
      gravity: ToastGravity.BOTTOM,
      timeInSecForIosWeb: 1,
      backgroundColor: Colors.red,
      textColor: Colors.white,
      fontSize: 16.0,
    );
  }
}

// FILE: pubspec.yaml

name: machine
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https:
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https:
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.7.0

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8
  flutter_launcher_icons: ^0.14.3
  re_editor:
    path: ../re-editor
  dart_git:
    path: ../dart-git
    # git: https:
  file_picker: ^10.1.9
  path_provider: ^2.1.5
  re_highlight: ^0.0.3
  external_path: ^2.2.0
  permission_handler: ^12.0.0+1
  crypto: ^3.0.6
  diff_match_patch: ^0.4.1
  riverpod: ^2.6.1
  flutter_riverpod: ^2.6.1
  riverpod_annotation: ^2.6.1
  shared_preferences: ^2.5.2
  saf_stream: ^0.12.3
  saf_util: ^0.11.0
  async: any
  collection: any
  uuid: any
  talker: ^5.0.1
  talker_flutter: ^5.0.1
  talker_riverpod_logger: ^5.0.1
  fluttertoast: ^8.2.12
  back_button_interceptor: ^8.0.4
  flutter_foreground_task: ^9.1.0
  hive_ce: ^2.14.0
  hive_ce_flutter: ^2.3.2
  flutter_markdown: ^0.7.7+1
  http: ^1.5.0
  markdown: any
  scrollable_positioned_list: ^0.3.8
  glob: ^2.1.3
  path: ^1.9.1
  equatable: any
  tiled: ^0.11.1
  vector_math: ^2.1.4
  xml: any
  meta: any
  flex_color_picker: ^3.7.2
  flutter_native_splash: ^2.4.7
  xterm:
    git:
      url: git@github.com:hommes-doutant/xterm.dart.git
 
dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^6.0.0
  riverpod_generator: ^2.6.5
  build_runner: ^2.4.15
  custom_lint: ^0.7.5
  riverpod_lint: ^2.6.5
  hive_ce_generator: ^1.9.2
  import_sorter: ^4.6.0
# For information on the generic Dart part of this file, see the
# following page: https:

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https:

  # For details regarding adding assets from package dependencies, see
  # https:

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:

  fonts:
    - family: JetBrainsMono
      fonts:
        - asset: assets/fonts/JetBrainsMono-Regular.ttf
        - asset: assets/fonts/JetBrainsMono-Bold.ttf
          weight: 700
        - asset: assets/fonts/JetBrainsMono-Italic.ttf
          style: italic
        - asset: assets/fonts/JetBrainsMono-BoldItalic.ttf
          weight: 700
          style: italic
    - family: FiraCode
      fonts:
        - asset: assets/fonts/FiraCode/FiraCode-Regular.ttf
          weight: 400
        - asset: assets/fonts/FiraCode/FiraCode-Bold.ttf
          weight: 700
    - family: RobotoMono
      fonts:
        - asset: assets/fonts/RobotoMono/RobotoMono-Regular.ttf
          weight: 400
        - asset: assets/fonts/RobotoMono/RobotoMono-Bold.ttf
          weight: 700
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https:
flutter_launcher_icons:
     android: true
     image_path: "assets/icons/android/res/mipmap-hdpi/ic_launcher.png" # Path to your icon image
     adaptive_icon_background: "assets/icons/android/res/mipmap-hdpi/ic_launcher_background.png" # only available for Android 8.0 devices and above
     adaptive_icon_foreground: "assets/icons/android/res/mipmap-hdpi/ic_launcher_foreground.png" # only available for Android 8.0 devices and above
     adaptive_icon_foreground_inset: 0 # only available for Android 8.0 devices and above
     adaptive_icon_monochrome: "assets/icons/android/res/mipmap-hdpi/ic_launcher_monochrome.png" # only available for Android 13 devices and above

import_sorter:
  comments: false # Optional, defaults to true
  
flutter_native_splash:
  color: "#07121A"
  #color_dark: "#042a49"
  image: 'assets/icons/android/play_store_512.png'    
  #image_dark:
  fullscreen: true
  android_12:
    color: "#07121A"
    # color_dark: "#042a49"

    image: 'assets/icons/android/play_store_512.png'