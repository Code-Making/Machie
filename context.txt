.
├── README.md
├── analysis_options.yaml
├── analyze.sh
├── android
│   ├── app
│   │   ├── build.gradle.kts
│   │   └── src
│   │       ├── debug
│   │       │   └── AndroidManifest.xml
│   │       ├── main
│   │       │   ├── AndroidManifest.xml
│   │       │   ├── kotlin
│   │       │   │   └── com
│   │       │   │       └── thomasdumonet
│   │       │   │           └── machine
│   │       │   │               └── MainActivity.kt
│   │       │   └── res
│   │       │       ├── drawable
│   │       │       │   ├── background.png
│   │       │       │   ├── launch_background.xml
│   │       │       │   └── not_icon.png
│   │       │       ├── drawable-hdpi
│   │       │       │   ├── android12splash.png
│   │       │       │   ├── ic_launcher_background.png
│   │       │       │   ├── ic_launcher_foreground.png
│   │       │       │   ├── ic_launcher_monochrome.png
│   │       │       │   ├── ic_stat___.png
│   │       │       │   └── splash.png
│   │       │       ├── drawable-mdpi
│   │       │       │   ├── android12splash.png
│   │       │       │   ├── ic_launcher_background.png
│   │       │       │   ├── ic_launcher_foreground.png
│   │       │       │   ├── ic_launcher_monochrome.png
│   │       │       │   ├── ic_stat___.png
│   │       │       │   └── splash.png
│   │       │       ├── drawable-night-hdpi
│   │       │       │   └── android12splash.png
│   │       │       ├── drawable-night-mdpi
│   │       │       │   └── android12splash.png
│   │       │       ├── drawable-night-xhdpi
│   │       │       │   └── android12splash.png
│   │       │       ├── drawable-night-xxhdpi
│   │       │       │   └── android12splash.png
│   │       │       ├── drawable-night-xxxhdpi
│   │       │       │   └── android12splash.png
│   │       │       ├── drawable-v21
│   │       │       │   ├── background.png
│   │       │       │   └── launch_background.xml
│   │       │       ├── drawable-xhdpi
│   │       │       │   ├── android12splash.png
│   │       │       │   ├── ic_launcher_background.png
│   │       │       │   ├── ic_launcher_foreground.png
│   │       │       │   ├── ic_launcher_monochrome.png
│   │       │       │   ├── ic_stat___.png
│   │       │       │   └── splash.png
│   │       │       ├── drawable-xxhdpi
│   │       │       │   ├── android12splash.png
│   │       │       │   ├── ic_launcher_background.png
│   │       │       │   ├── ic_launcher_foreground.png
│   │       │       │   ├── ic_launcher_monochrome.png
│   │       │       │   ├── ic_stat___.png
│   │       │       │   └── splash.png
│   │       │       ├── drawable-xxxhdpi
│   │       │       │   ├── android12splash.png
│   │       │       │   ├── ic_launcher_background.png
│   │       │       │   ├── ic_launcher_foreground.png
│   │       │       │   ├── ic_launcher_monochrome.png
│   │       │       │   ├── ic_stat___.png
│   │       │       │   └── splash.png
│   │       │       ├── mipmap-anydpi-v26
│   │       │       │   └── ic_launcher.xml
│   │       │       ├── mipmap-hdpi
│   │       │       │   └── ic_launcher.png
│   │       │       ├── mipmap-mdpi
│   │       │       │   └── ic_launcher.png
│   │       │       ├── mipmap-xhdpi
│   │       │       │   └── ic_launcher.png
│   │       │       ├── mipmap-xxhdpi
│   │       │       │   └── ic_launcher.png
│   │       │       ├── mipmap-xxxhdpi
│   │       │       │   └── ic_launcher.png
│   │       │       ├── values
│   │       │       │   └── styles.xml
│   │       │       ├── values-night
│   │       │       │   └── styles.xml
│   │       │       ├── values-night-v31
│   │       │       │   └── styles.xml
│   │       │       ├── values-v31
│   │       │       │   └── styles.xml
│   │       │       └── xml
│   │       │           └── file_paths.xml
│   │       └── profile
│   │           └── AndroidManifest.xml
│   ├── build.gradle.kts
│   ├── gradle
│   │   └── wrapper
│   │       └── gradle-wrapper.properties
│   ├── gradle.properties
│   └── settings.gradle.kts
├── assets
│   ├── fonts
│   │   ├── FiraCode
│   │   │   ├── FiraCode-Bold.ttf
│   │   │   ├── FiraCode-Light.ttf
│   │   │   ├── FiraCode-Medium.ttf
│   │   │   ├── FiraCode-Regular.ttf
│   │   │   └── FiraCode-SemiBold.ttf
│   │   ├── JetBrainsMono-Bold.ttf
│   │   ├── JetBrainsMono-BoldItalic.ttf
│   │   ├── JetBrainsMono-ExtraBold.ttf
│   │   ├── JetBrainsMono-ExtraBoldItalic.ttf
│   │   ├── JetBrainsMono-ExtraLight.ttf
│   │   ├── JetBrainsMono-ExtraLightItalic.ttf
│   │   ├── JetBrainsMono-Italic.ttf
│   │   ├── JetBrainsMono-Light.ttf
│   │   ├── JetBrainsMono-LightItalic.ttf
│   │   ├── JetBrainsMono-Medium.ttf
│   │   ├── JetBrainsMono-MediumItalic.ttf
│   │   ├── JetBrainsMono-Regular.ttf
│   │   ├── JetBrainsMono-SemiBold.ttf
│   │   ├── JetBrainsMono-SemiBoldItalic.ttf
│   │   ├── JetBrainsMono-Thin.ttf
│   │   ├── JetBrainsMono-ThinItalic.ttf
│   │   ├── RobotoMono
│   │   │   ├── RobotoMono-Bold.ttf
│   │   │   ├── RobotoMono-BoldItalic.ttf
│   │   │   ├── RobotoMono-ExtraLight.ttf
│   │   │   ├── RobotoMono-ExtraLightItalic.ttf
│   │   │   ├── RobotoMono-Italic.ttf
│   │   │   ├── RobotoMono-Light.ttf
│   │   │   ├── RobotoMono-LightItalic.ttf
│   │   │   ├── RobotoMono-Medium.ttf
│   │   │   ├── RobotoMono-MediumItalic.ttf
│   │   │   ├── RobotoMono-Regular.ttf
│   │   │   ├── RobotoMono-SemiBold.ttf
│   │   │   ├── RobotoMono-SemiBoldItalic.ttf
│   │   │   ├── RobotoMono-Thin.ttf
│   │   │   └── RobotoMono-ThinItalic.ttf
│   │   └── SourceSans3
│   │       ├── SourceSans3-Black.ttf
│   │       ├── SourceSans3-BlackItalic.ttf
│   │       ├── SourceSans3-Bold.ttf
│   │       ├── SourceSans3-BoldItalic.ttf
│   │       ├── SourceSans3-ExtraBold.ttf
│   │       ├── SourceSans3-ExtraBoldItalic.ttf
│   │       ├── SourceSans3-ExtraLight.ttf
│   │       ├── SourceSans3-ExtraLightItalic.ttf
│   │       ├── SourceSans3-Italic.ttf
│   │       ├── SourceSans3-Light.ttf
│   │       ├── SourceSans3-LightItalic.ttf
│   │       ├── SourceSans3-Medium.ttf
│   │       ├── SourceSans3-MediumItalic.ttf
│   │       ├── SourceSans3-Regular.ttf
│   │       ├── SourceSans3-SemiBold.ttf
│   │       └── SourceSans3-SemiBoldItalic.ttf
│   └── icons
│       └── android
│           ├── play_store_512.png
│           └── res
│               ├── mipmap-anydpi-v26
│               │   └── ic_launcher.xml
│               ├── mipmap-hdpi
│               │   ├── ic_launcher.png
│               │   ├── ic_launcher_background.png
│               │   ├── ic_launcher_foreground.png
│               │   └── ic_launcher_monochrome.png
│               ├── mipmap-mdpi
│               │   ├── ic_launcher.png
│               │   ├── ic_launcher_background.png
│               │   ├── ic_launcher_foreground.png
│               │   └── ic_launcher_monochrome.png
│               ├── mipmap-xhdpi
│               │   ├── ic_launcher.png
│               │   ├── ic_launcher_background.png
│               │   ├── ic_launcher_foreground.png
│               │   └── ic_launcher_monochrome.png
│               ├── mipmap-xxhdpi
│               │   ├── ic_launcher.png
│               │   ├── ic_launcher_background.png
│               │   ├── ic_launcher_foreground.png
│               │   └── ic_launcher_monochrome.png
│               └── mipmap-xxxhdpi
│                   ├── ic_launcher.png
│                   ├── ic_launcher_background.png
│                   ├── ic_launcher_foreground.png
│                   └── ic_launcher_monochrome.png
├── build.sh
├── context.txt
├── lib
│   └── editor
│       ├── models
│       │   ├── editor_command_context.dart
│       │   ├── editor_plugin_models.dart
│       │   ├── editor_tab_models.dart
│       │   └── text_editing_capability.dart
│       ├── plugins
│       │   ├── editor_plugin_registry.dart
│       │   ├── flow_graph
│       │   │   ├── asset
│       │   │   │   ├── flow_asset_models.dart
│       │   │   │   └── flow_loaders.dart
│       │   │   ├── flow_graph_command_context.dart
│       │   │   ├── flow_graph_editor_plugin.dart
│       │   │   ├── flow_graph_editor_tab.dart
│       │   │   ├── flow_graph_editor_widget.dart
│       │   │   ├── flow_graph_notifier.dart
│       │   │   ├── flow_graph_settings_model.dart
│       │   │   ├── models
│       │   │   │   ├── flow_graph_models.dart
│       │   │   │   ├── flow_references.dart
│       │   │   │   └── flow_schema_models.dart
│       │   │   ├── utils
│       │   │   │   └── flow_layout_utils.dart
│       │   │   └── widgets
│       │   │       ├── flow_connection_painter.dart
│       │   │       ├── flow_graph_canvas.dart
│       │   │       ├── flow_graph_settings_widget.dart
│       │   │       ├── node_palette.dart
│       │   │       ├── property_tiled_object_picker.dart
│       │   │       └── schema_node_widget.dart
│       │   ├── texture_packer
│       │   │   ├── services
│       │   │   │   └── pixi_export_service.dart
│       │   │   ├── texture_packer_asset_resolver.dart
│       │   │   ├── texture_packer_command_context.dart
│       │   │   ├── texture_packer_editor_models.dart
│       │   │   ├── texture_packer_editor_widget.dart
│       │   │   ├── texture_packer_loader.dart
│       │   │   ├── texture_packer_models.dart
│       │   │   ├── texture_packer_notifier.dart
│       │   │   ├── texture_packer_plugin.dart
│       │   │   ├── texture_packer_preview_state.dart
│       │   │   ├── texture_packer_settings.dart
│       │   │   └── widgets
│       │   │       ├── hierarchy_panel.dart
│       │   │       ├── preview_app_bar.dart
│       │   │       ├── preview_view.dart
│       │   │       ├── slicing_app_bar.dart
│       │   │       ├── slicing_properties_dialog.dart
│       │   │       ├── slicing_view.dart
│       │   │       ├── source_images_panel.dart
│       │   │       ├── texture_packer_export_dialog.dart
│       │   │       ├── texture_packer_file_dialog.dart
│       │   │       └── texture_packer_settings_widget.dart
│       │   └── tiled_editor
│       │       ├── image_load_result.dart
│       │       ├── inspector
│       │       │   ├── inspector_dialog.dart
│       │       │   ├── property_descriptors.dart
│       │       │   ├── property_widgets.dart
│       │       │   └── tiled_reflectors.dart
│       │       ├── project_tsx_provider.dart
│       │       ├── tiled_asset_resolver.dart
│       │       ├── tiled_command_context.dart
│       │       ├── tiled_editor_models.dart
│       │       ├── tiled_editor_plugin.dart
│       │       ├── tiled_editor_settings_model.dart
│       │       ├── tiled_editor_widget.dart
│       │       ├── tiled_export_service.dart
│       │       ├── tiled_map_notifier.dart
│       │       ├── tiled_map_painter.dart
│       │       ├── tiled_paint_tools.dart
│       │       ├── tmj_writer.dart
│       │       ├── tmx_writer.dart
│       │       ├── tmx_writer_extensions.dart
│       │       └── widgets
│       │           ├── export_dialog.dart
│       │           ├── layers_panel.dart
│       │           ├── map_properties_dialog.dart
│       │           ├── new_layer_dialog.dart
│       │           ├── new_tileset_dialog.dart
│       │           ├── object_editor_app_bar.dart
│       │           ├── paint_editor_app_bar.dart
│       │           ├── sprite_picker_dialog.dart
│       │           ├── tile_palette.dart
│       │           └── tiled_editor_settings_widget.dart
│       ├── services
│       │   ├── editor_service.dart
│       │   └── language
│       │       ├── language_models.dart
│       │       └── language_registry.dart
│       ├── tab_context_commands.dart
│       ├── tab_metadata_notifier.dart
│       └── widgets
│           └── editor_widgets.dart
├── pubspec.yaml
├── sandbox
│   ├── Room_Builder_48x48.png
│   ├── Room_Builder_subfiles_48x48
│   │   ├── Room_Builder_3d_walls_48x48.png
│   │   ├── Room_Builder_Arched_Entryways_48x48.png
│   │   ├── Room_Builder_Floor_Connectors_48x48.png
│   │   ├── Room_Builder_Floor_Paths_48x48.png
│   │   ├── Room_Builder_Floor_Shadows_48x48.png
│   │   ├── Room_Builder_Floors_48x48.png
│   │   ├── Room_Builder_Walls_48x48.png
│   │   ├── Room_Builder_baseboards_48x48.png
│   │   └── Room_Builder_borders_48x48.png
│   ├── Theme_Sorter_48x48
│   │   ├── 10_Birthday_party_48x48.png
│   │   ├── 11_Halloween_48x48.png
│   │   ├── 12_Kitchen_48x48.png
│   │   ├── 13_Conference_Hall_48x48.png
│   │   ├── 14_Basement_48x48.png
│   │   ├── 15_Christmas_48x48.png
│   │   ├── 16_Grocery_store_48x48.png
│   │   ├── 17_Visibile_Upstairs_System_48x48.png
│   │   ├── 18_Jail_48x48.png
│   │   ├── 19_Hospital_48x48.png
│   │   ├── 1_Generic_48x48.png
│   │   ├── 20_Japanese_interiors_48x48.png
│   │   ├── 21_Clothing_Store_48x48.png
│   │   ├── 22_Museum_48x48.png
│   │   ├── 23_Television_and_Film_Studio_48x48.png
│   │   ├── 23_Tevelision_and_Film_Studio_Shadowless_48x48.png
│   │   ├── 24_Ice_Cream_Shop_48x48.png
│   │   ├── 25_Shooting_Range_48x48.png
│   │   ├── 26_Condominium_48x48.png
│   │   ├── 2_LivingRoom_48x48.png
│   │   ├── 3_Bathroom_48x48.png
│   │   ├── 4_Bedroom_48x48.png
│   │   ├── 5_Classroom_and_library_48x48.png
│   │   ├── 6_Music_and_sport_48x48.png
│   │   ├── 7_Art_48x48.png
│   │   ├── 8_Gym_48x48.png
│   │   └── 9_Fishing_48x48.png
│   ├── ecs_schema.json
│   ├── flow.llm
│   ├── flow2.llm
│   ├── flow_schema.json
│   ├── old
│   │   ├── asset.llm
│   │   ├── asset2.llm
│   │   ├── asset3.llm
│   │   ├── map.tmx
│   │   ├── mapa.tmx
│   │   ├── packed_atlas.png
│   │   ├── packed_atlasa.png
│   │   ├── res.llm
│   │   ├── resolver.llm
│   │   └── test.tpacker
│   ├── test.fg
│   ├── test.tmx
│   └── test.tpacker
└── test
    └── widget_test.dart

74 directories, 273 files
// FILE: analysis_options.yaml

# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https:
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https:
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule
    prefer_relative_imports: true
# Additional information about this file can be found at
# https:
analyzer:
  plugins:
    - custom_lint

// FILE: lib/editor/models/editor_command_context.dart


import 'package:flutter/material.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../app/app_notifier.dart';

@immutable
abstract class CommandContext {
  final Widget? appBarOverride;
  final Key? appBarOverrideKey;

  const CommandContext({this.appBarOverride, this.appBarOverrideKey});

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is CommandContext &&
        other.appBarOverrideKey == appBarOverrideKey;
  }

  @override
  int get hashCode => appBarOverrideKey.hashCode;
}

class EmptyCommandContext extends CommandContext {
  const EmptyCommandContext()
    : super(appBarOverride: null, appBarOverrideKey: null);
}

final commandContextProvider = StateProvider.family<CommandContext, String>(
  (ref, tabId) => const EmptyCommandContext(),
);
final activeCommandContextProvider = Provider<CommandContext>((ref) {
  final activeTabId = ref.watch(
    appNotifierProvider.select(
      (s) => s.value?.currentProject?.session.currentTab?.id,
    ),
  );
  if (activeTabId == null) {
    return const EmptyCommandContext();
  }
  return ref.watch(commandContextProvider(activeTabId));
});


// FILE: lib/editor/models/editor_plugin_models.dart


import 'dart:async';

import 'package:flutter/material.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../command/command_models.dart';
import '../../data/cache/type_adapters.dart';
import '../../data/file_handler/file_handler.dart';
import '../../settings/settings_models.dart';
import 'editor_tab_models.dart';
import '../../data/content_provider/file_content_provider.dart';
import '../../asset_cache/asset_models.dart';

export '../../settings/settings_models.dart';

enum PluginDataRequirement { string, bytes }

class EditorInitData {
  final EditorContent initialContent;
  final TabHotStateDto? hotState;
  final String baseContentHash;

  const EditorInitData({
    required this.initialContent,
    this.hotState,
    required this.baseContentHash,
  });
}

abstract class EditorPlugin {
  String get id;
  String get name;
  Widget get icon;
  int get priority;


  PluginDataRequirement get dataRequirement => PluginDataRequirement.string;

  bool supportsFile(DocumentFile file) => false;

  bool canOpenFileContent(String content, DocumentFile file) {
    return dataRequirement == PluginDataRequirement.string;
  }

  List<CommandPosition> getCommandPositions() => [];

  List<Command> getCommands() => [];

  List<CommandGroup> getCommandGroups() => [];
  
  List<Command> getAppCommands() => [];

  List<FileContextCommand> getFileContextMenuCommands(DocumentFile item) => [];

  List<TabContextCommand> getTabContextMenuCommands() => [];

  PluginSettings? get settings => null;

  Widget buildSettingsUI(
    PluginSettings settings,
    void Function(PluginSettings) onChanged,
  ) =>
      const SizedBox.shrink();
  Widget wrapCommandToolbar(Widget toolbar) => toolbar;

  Widget buildToolbar(WidgetRef ref) => const SizedBox.shrink();

  void activateTab(EditorTab tab, Ref ref) {}

  void deactivateTab(EditorTab tab, Ref ref) {}

  void disposeTab(EditorTab tab) {}

  Future<void> dispose() async {}


  List<FileContentProvider Function(Ref ref)>
  get fileContentProviderFactories => [];

  String? get hotStateDtoType;

  Type? get hotStateDtoRuntimeType;

  TypeAdapter<TabHotStateDto>? get hotStateAdapter;

  /// This allows the plugin to define how to load custom file types 
  List<AssetLoader> get assetLoaders => [];


  Future<EditorTab> createTab(
    DocumentFile file,
    EditorInitData initData, {
    String? id,
    Completer<EditorWidgetState>? onReadyCompleter,
  });

  EditorWidget buildEditor(EditorTab tab, WidgetRef ref);
}

abstract class PluginSettings extends MachineSettings {}


// FILE: lib/editor/models/editor_tab_models.dart

// FILE: lib/editor/editor_tab_models.dart

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';

import '../../data/dto/project_dto.dart';
import '../../data/dto/tab_hot_state_dto.dart';
import 'editor_plugin_models.dart';
import '../tab_metadata_notifier.dart';

import '../../data/content_provider/file_content_provider.dart';

export '../../data/dto/tab_hot_state_dto.dart';

@immutable
class TabSessionState {
  final List<EditorTab> tabs;
  final int currentTabIndex;
  final Map<String, TabMetadata> tabMetadata;

  const TabSessionState({
    this.tabs = const [],
    this.currentTabIndex = 0,
    this.tabMetadata = const {},
  });

  TabSessionStateDto toDto(
    Map<String, TabMetadata> liveMetadata,
    FileContentProviderRegistry registry,
  ) {
    return TabSessionStateDto(
      tabs: tabs.map((t) => t.toDto()).toList(),
      currentTabIndex: currentTabIndex,
      tabMetadata: liveMetadata.map(
        (key, value) => MapEntry(
          key,
          TabMetadataDto(
            fileUri: value.file.uri,
            isDirty: value.isDirty,
            fileName: value.file.name,
            fileType: registry.getTypeIdForFile(value.file),
          ),
        ),
      ),
    );
  }

  EditorTab? get currentTab =>
      tabs.isNotEmpty && currentTabIndex < tabs.length
          ? tabs[currentTabIndex]
          : null;

  TabSessionState copyWith({List<EditorTab>? tabs, int? currentTabIndex}) {
    return TabSessionState(
      tabs: tabs ?? List.from(this.tabs),
      currentTabIndex: currentTabIndex ?? this.currentTabIndex,
    );
  }
}

sealed class EditorContent {}

class EditorContentString extends EditorContent {
  final String content;
  EditorContentString(this.content);
}

class EditorContentBytes extends EditorContent {
  final Uint8List bytes;
  EditorContentBytes(this.bytes);
}

abstract class EditorWidget extends ConsumerStatefulWidget {
  final EditorTab tab;

  const EditorWidget({required this.tab, required super.key});
}

abstract class EditorWidgetState<T extends EditorWidget>
    extends ConsumerState<T> {
  @override
  void initState() {
    super.initState();
    init();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        onFirstFrameReady();
      }
    });
  }

  @protected
  void init();

  @protected
  void onFirstFrameReady();

  void syncCommandContext();


  void undo();
  void redo();
  Future<EditorContent> getContent();
  void onSaveSuccess(String newHash);
  Future<TabHotStateDto?> serializeHotState();
}

@immutable
abstract class WorkspaceTab {
  final String id;
  final EditorPlugin plugin;

  WorkspaceTab({required this.plugin, String? id})
    : id = id ?? const Uuid().v4();

  void dispose();
}

@immutable
abstract class EditorTab extends WorkspaceTab {
  GlobalKey<EditorWidgetState> get editorKey;

  final Completer<EditorWidgetState> onReady;

  EditorTab({
    required super.plugin,
    super.id,
    Completer<EditorWidgetState>? onReadyCompleter,
  }) : onReady = onReadyCompleter ?? Completer<EditorWidgetState>();

  @override
  void dispose();

  EditorTabDto toDto() {
    return EditorTabDto(id: id, pluginType: plugin.id);
  }
}


// FILE: lib/editor/models/text_editing_capability.dart

// FILE: lib/editor/services/text_editing_capability.dart

import 'package:flutter/foundation.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../app/app_notifier.dart';
import '../../command/command_models.dart';
import 'editor_command_context.dart';
import 'editor_plugin_models.dart';

@immutable
class TextPosition {
  final int line;
  final int column;

  const TextPosition({required this.line, required this.column});
}

@immutable
class TextRange {
  final TextPosition start;
  final TextPosition end;

  const TextRange({required this.start, required this.end});
}

@immutable
class TextSelectionDetails {
  final TextRange? range;
  final String content;

  const TextSelectionDetails({required this.range, required this.content});
}

@immutable
sealed class TextEdit {
  const TextEdit();
}

class ReplaceLinesEdit extends TextEdit {
  final int startLine;

  final int endLine;

  final String newContent;

  const ReplaceLinesEdit({
    required this.startLine,
    required this.endLine,
    required this.newContent,
  });
}

class ReplaceAllOccurrencesEdit extends TextEdit {
  final String find;
  final String replace;

  const ReplaceAllOccurrencesEdit({required this.find, required this.replace});
}

class RevealRangeEdit extends TextEdit {
  final TextRange range;
  const RevealRangeEdit({required this.range});
}

class ReplaceRangeEdit extends TextEdit {
  final TextRange range;
  final String replacement;
  const ReplaceRangeEdit({required this.range, required this.replacement});
}

class BatchReplaceRangesEdit extends TextEdit {
  final List<ReplaceRangeEdit> edits;
  const BatchReplaceRangesEdit({required this.edits});
}

mixin TextEditablePlugin on EditorPlugin {}

abstract mixin class TextEditable {
  void applyEdit(TextEdit edit) {
    switch (edit) {
      case RevealRangeEdit():
        revealRange(edit.range);
        break;
      case ReplaceLinesEdit():
        replaceLines(edit.startLine, edit.endLine, edit.newContent);
        break;
      case ReplaceAllOccurrencesEdit():
        replaceAllOccurrences(edit.find, edit.replace);
        break;
      case ReplaceRangeEdit():
        replaceSelection(edit.replacement, range: edit.range);
        break;
      case BatchReplaceRangesEdit():
        batchReplaceRanges(edit.edits);
        break;
    }
  }

  Future<TextSelectionDetails> getSelectionDetails();

  void replaceSelection(String replacement, {TextRange? range});

  Future<bool> isSelectionCollapsed();

  Future<String> getSelectedText();

  Future<String> getTextContent();

  void insertTextAtLine(int lineNumber, String textToInsert);

  void replaceLines(int startLine, int endLine, String newContent);

  void replaceAllOccurrences(String find, String replace);

  void replaceAllPattern(Pattern pattern, String replacement);

  void revealRange(TextRange range);

  void batchReplaceRanges(List<ReplaceRangeEdit> edits);
}


abstract class TextEditableCommandContext extends CommandContext {
  final bool hasSelection;

  const TextEditableCommandContext({
    required this.hasSelection,
    super.appBarOverride,
    super.appBarOverrideKey,
  });

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is TextEditableCommandContext &&
        other.hasSelection == hasSelection &&
        super == other;
  }

  @override
  int get hashCode => Object.hash(super.hashCode, hasSelection);
}

class BaseTextEditableCommand extends Command {
  final Future<void> Function(WidgetRef, TextEditable) _execute;
  final bool Function(WidgetRef, TextEditableCommandContext)? _canExecute;

  const BaseTextEditableCommand({
    required super.id,
    required super.label,
    required super.icon,
    required super.defaultPositions,
    required super.sourcePlugin,
    required Future<void> Function(WidgetRef, TextEditable) execute,
    bool Function(WidgetRef, TextEditableCommandContext)? canExecute,
  }) : _execute = execute,
       _canExecute = canExecute;

  @override
  bool canExecute(WidgetRef ref) {
    final activeContext = ref.watch(activeCommandContextProvider);
    if (activeContext is! TextEditableCommandContext) {
      return false;
    }
    return _canExecute?.call(ref, activeContext) ?? true;
  }

  @override
  Future<void> execute(WidgetRef ref) async {
    final activeTab =
        ref.read(appNotifierProvider).value?.currentProject?.session.currentTab;
    final editorState = activeTab?.editorKey.currentState;

    if (editorState != null && editorState is TextEditable) {
      final editableState = editorState as TextEditable;
      await _execute(ref, editableState);
    }
  }
}


// FILE: lib/editor/plugins/editor_plugin_registry.dart


import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'code_editor/code_editor_plugin.dart';
import 'glitch_editor/glitch_editor_plugin.dart';
import 'llm_editor/llm_editor_plugin.dart';
import '../models/editor_plugin_models.dart';
import 'recipe_tex/recipe_tex_plugin.dart';

import 'refactor_editor/refactor_editor_plugin.dart';
import 'tiled_editor/tiled_editor_plugin.dart';
import 'texture_packer/texture_packer_plugin.dart';

export '../models/editor_plugin_models.dart';
import 'flow_graph/flow_graph_editor_plugin.dart';

final pluginRegistryProvider = Provider<Set<EditorPlugin>>(
  (_) => {
    CodeEditorPlugin(),
    GlitchEditorPlugin(),
    RecipeTexPlugin(),
    LlmEditorPlugin(),
    RefactorEditorPlugin(),
    TiledEditorPlugin(),
    TexturePackerPlugin(),
    FlowGraphEditorPlugin(),    
  },
);

final activePluginsProvider =
    StateNotifierProvider<PluginManager, List<EditorPlugin>>((ref) {
      final initialPlugins = ref.read(pluginRegistryProvider);
      return PluginManager(initialPlugins);
    });

class PluginManager extends StateNotifier<List<EditorPlugin>> {
  PluginManager(Set<EditorPlugin> plugins)
    : super(_sortPlugins(plugins.toList()));

  static List<EditorPlugin> _sortPlugins(List<EditorPlugin> plugins) {
    plugins.sort((a, b) => b.priority.compareTo(a.priority));
    return plugins;
  }

  void registerPlugin(EditorPlugin plugin) {
    state = _sortPlugins([...state, plugin]);
  }

  void unregisterPlugin(EditorPlugin plugin) {
    state = _sortPlugins(state.where((p) => p != plugin).toList());
  }
}


// FILE: lib/editor/plugins/flow_graph/asset/flow_asset_models.dart

// FILE: lib/editor/plugins/flow_graph/asset/flow_asset_models.dart

import 'package:machine/asset_cache/asset_models.dart';
import '../models/flow_graph_models.dart';
import '../models/flow_schema_models.dart';

/// The result of loading a flow_schema.json file.
class FlowSchemaAssetData extends AssetData {
  final List<FlowNodeType> nodeTypes;
  
  final Map<String, FlowNodeType> typeMap;

  FlowSchemaAssetData(this.nodeTypes) 
      : typeMap = {for (var t in nodeTypes) t.type: t};
}

/// The result of loading a .fg file.
class FlowGraphAssetData extends AssetData {
  final FlowGraph graph;
  
  /// If the schema file is missing or failed to load, this might be null,
  final FlowSchemaAssetData? schema;

  FlowGraphAssetData({
    required this.graph,
    this.schema,
  });
}

// FILE: lib/editor/plugins/flow_graph/asset/flow_loaders.dart

// FILE: lib/editor/plugins/flow_graph/asset/flow_loaders.dart

import 'dart:convert';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/asset_cache/asset_models.dart';
import 'package:machine/asset_cache/asset_providers.dart';
import 'package:machine/data/file_handler/file_handler.dart';
import 'package:machine/data/repositories/project/project_repository.dart';
import '../models/flow_graph_models.dart';
import '../models/flow_schema_models.dart';
import 'flow_asset_models.dart';

/// to avoid trying to load every JSON file as a schema. Here we assume specific naming or
class FlowSchemaLoader implements AssetLoader<FlowSchemaAssetData> {
  @override
  bool canLoad(ProjectDocumentFile file) {
    return file.name.endsWith('.json') && file.name.contains('schema'); 
  }

  @override
  Future<FlowSchemaAssetData> load(Ref ref, ProjectDocumentFile file, ProjectRepository repo) async {
    final content = await repo.readFile(file.uri);
    final jsonList = jsonDecode(content) as List;
    
    final nodeTypes = jsonList
        .map((e) => FlowNodeType.fromJson(e as Map<String, dynamic>))
        .toList();

    return FlowSchemaAssetData(nodeTypes);
  }
}

class FlowGraphLoader implements AssetLoader<FlowGraphAssetData>, IDependentAssetLoader<FlowGraphAssetData> {
  @override
  bool canLoad(ProjectDocumentFile file) {
    return file.name.endsWith('.fg');
  }

  /// 1. Parse the .fg file superficially to find dependencies (the schema path).
  @override
  Future<Set<String>> getDependencies(Ref ref, ProjectDocumentFile file, ProjectRepository repo) async {
    try {
      final content = await repo.readFile(file.uri);
      final json = jsonDecode(content);
      
      if (json['schema'] != null) {
        // Resolve relative path: "./schema.json" or "../schemas/logic.json" relative to the .fg file
        final contextPath = repo.fileHandler.getPathForDisplay(file.uri, relativeTo: repo.rootUri);
        final parentPath = repo.fileHandler.getParentUri(file.uri);
        
        
        
        final relativeFolder = contextPath.contains('/') 
            ? contextPath.substring(0, contextPath.lastIndexOf('/'))
            : '';
            
        final dependencyUri = repo.resolveRelativePath(relativeFolder, json['schema']);
        return {dependencyUri};
      }
    } catch (e) {
    }
    return {};
  }

  @override
  Future<FlowGraphAssetData> load(Ref ref, ProjectDocumentFile file, ProjectRepository repo) async {
    final content = await repo.readFile(file.uri);
    final graph = FlowGraph.deserialize(content);
    
    FlowSchemaAssetData? schemaData;

    if (graph.schemaPath != null) {
      final contextPath = repo.fileHandler.getPathForDisplay(file.uri, relativeTo: repo.rootUri);
      final relativeFolder = contextPath.contains('/') 
          ? contextPath.substring(0, contextPath.lastIndexOf('/'))
          : '';
          
      final schemaUri = repo.resolveRelativePath(relativeFolder, graph.schemaPath!);
      
      final assetState = await ref.read(assetDataProvider(schemaUri).future);
      
      if (assetState is FlowSchemaAssetData) {
        schemaData = assetState;
      }
    }

    return FlowGraphAssetData(
      graph: graph,
      schema: schemaData,
    );
  }
}

// FILE: lib/editor/plugins/flow_graph/flow_graph_command_context.dart

// FILE: lib/editor/plugins/flow_graph/flow_graph_command_context.dart

import 'package:flutter/material.dart';
import 'package:machine/editor/models/editor_command_context.dart';

@immutable
class FlowGraphCommandContext extends CommandContext {
  final bool hasSelection;

  const FlowGraphCommandContext({
    required this.hasSelection,
    super.appBarOverride,
    super.appBarOverrideKey,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      super == other &&
          other is FlowGraphCommandContext &&
          hasSelection == other.hasSelection;

  @override
  int get hashCode => Object.hash(super.hashCode, hasSelection);
}

// FILE: lib/editor/plugins/flow_graph/flow_graph_editor_plugin.dart

// FILE: lib/editor/plugins/flow_graph/flow_graph_editor_plugin.dart

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/app/app_notifier.dart';
import 'package:machine/command/command_models.dart';
import 'package:machine/editor/models/editor_plugin_models.dart';
import 'package:machine/editor/models/editor_tab_models.dart';
import 'package:machine/data/file_handler/file_handler.dart';
import 'package:machine/asset_cache/asset_models.dart';

import 'asset/flow_loaders.dart';
import 'flow_graph_editor_tab.dart';
import 'flow_graph_editor_widget.dart';
import 'models/flow_graph_models.dart';
import '../../../data/cache/type_adapters.dart';
import 'flow_graph_settings_model.dart';
import 'widgets/flow_graph_settings_widget.dart';
import '../../services/editor_service.dart';
import '../../tab_metadata_notifier.dart';
import '../../../command/command_widgets.dart';
import 'flow_graph_command_context.dart';
import '../../models/editor_command_context.dart';

class FlowGraphEditorPlugin extends EditorPlugin {
  static const String pluginId = 'com.machine.flow_graph';

  @override
  String get id => pluginId;

  @override
  String get name => 'Flow Graph';

  @override
  Widget get icon => const Icon(Icons.hub_outlined);

  @override
  int get priority => 10;

  @override
  PluginDataRequirement get dataRequirement => PluginDataRequirement.string;

  
    @override
  PluginSettings? get settings => FlowGraphSettings();

  @override
  Widget buildSettingsUI(
    PluginSettings settings,
    void Function(PluginSettings) onChanged,
  ) =>
      FlowGraphSettingsWidget(
        settings: settings as FlowGraphSettings,
        onChanged: onChanged,
      );

  
  @override
  List<AssetLoader> get assetLoaders => [
    FlowSchemaLoader(),
  ];

  @override
  bool supportsFile(DocumentFile file) {
    return file.name.toLowerCase().endsWith('.fg');
  }


  @override
  Future<EditorTab> createTab(
    DocumentFile file,
    EditorInitData initData, {
    String? id,
    Completer<EditorWidgetState>? onReadyCompleter,
  }) async {
    final content = (initData.initialContent as EditorContentString).content;
    final graph = FlowGraph.deserialize(content);

    return FlowGraphEditorTab(
      plugin: this,
      id: id,
      initialGraph: graph,
      onReadyCompleter: onReadyCompleter,
    );
  }

  @override
  EditorWidget buildEditor(EditorTab tab, WidgetRef ref) {
    return FlowGraphEditorWidget(
      key: (tab as FlowGraphEditorTab).editorKey,
      tab: tab,
    );
  }
  
  @override
  Widget buildToolbar(WidgetRef ref) {
    return const BottomToolbar();
  }



  @override
  List<Command> getCommands() {
    return [
      BaseCommand(
        id: 'flow_save',
        label: 'Save',
        icon: const Icon(Icons.save),
        defaultPositions: [AppCommandPositions.appBar],
        sourcePlugin: id,
        execute: (ref) async => ref.read(editorServiceProvider).saveCurrentTab(),
        canExecute: (ref) {
          final tabId = ref.watch(appNotifierProvider.select((s) => s.value?.currentProject?.session.currentTab?.id));
          if (tabId == null) return false;
          return ref.watch(tabMetadataProvider.select((m) => m[tabId]))?.isDirty ?? false;
        },
      ),
      
      BaseCommand(
        id: 'flow_delete',
        label: 'Delete',
        icon: const Icon(Icons.delete_outline),
        defaultPositions: [AppCommandPositions.appBar],
        sourcePlugin: id,
        execute: (ref) async => _getEditorState(ref)?.notifier.deleteSelection(),
        canExecute: (ref) {
           final ctx = ref.watch(activeCommandContextProvider);
           return ctx is FlowGraphCommandContext && ctx.hasSelection;
        }
      ),

      BaseCommand(
        id: 'flow_link_schema',
        label: 'Link Schema',
        icon: const Icon(Icons.link),
        defaultPositions: [AppCommandPositions.appBar],
        sourcePlugin: id,
        execute: (ref) async {
          await _getEditorState(ref)?.linkSchema();
        },
      ),
      BaseCommand(
        id: 'flow_add_node',
        label: 'Add Node',
        icon: const Icon(Icons.add_box_outlined),
        defaultPositions: [AppCommandPositions.appBar],
        sourcePlugin: id,
        execute: (ref) async {
          _getEditorState(ref)?.togglePalette();
        },
      ),
      
      BaseCommand(
        id: 'flow_undo',
        label: 'Undo',
        icon: const Icon(Icons.undo),
        defaultPositions: [AppCommandPositions.appBar],
        sourcePlugin: id,
        execute: (ref) async => _getEditorState(ref)?.undo(),
      ),
      BaseCommand(
        id: 'flow_redo',
        label: 'Redo',
        icon: const Icon(Icons.redo),
        defaultPositions: [AppCommandPositions.appBar],
        sourcePlugin: id,
        execute: (ref) async => _getEditorState(ref)?.redo(),
      ),
    ];
  }

  FlowGraphEditorWidgetState? _getEditorState(WidgetRef ref) {
    final tab = ref.read(appNotifierProvider).value?.currentProject?.session.currentTab;
    if (tab is FlowGraphEditorTab) {
      return tab.editorKey.currentState;
    }
    return null;
  }

  @override
  String? get hotStateDtoType => null;
  @override
  Type? get hotStateDtoRuntimeType => null;
  @override
  TypeAdapter<TabHotStateDto>? get hotStateAdapter => null;
}

// FILE: lib/editor/plugins/flow_graph/flow_graph_editor_tab.dart

// FILE: lib/editor/plugins/flow_graph/flow_graph_editor_tab.dart

import 'dart:async';
import 'package:flutter/material.dart';
import '../../models/editor_tab_models.dart';
import 'flow_graph_editor_widget.dart';
import 'models/flow_graph_models.dart';

class FlowGraphEditorTab extends EditorTab {
  @override
  final GlobalKey<FlowGraphEditorWidgetState> editorKey;
  
  final FlowGraph initialGraph;

  FlowGraphEditorTab({
    required super.plugin,
    required this.initialGraph,
    super.id,
    super.onReadyCompleter,
  }) : editorKey = GlobalKey<FlowGraphEditorWidgetState>();

  @override
  void dispose() {
  }
}

// FILE: lib/editor/plugins/flow_graph/flow_graph_editor_widget.dart

// FILE: lib/editor/plugins/flow_graph/flow_graph_editor_widget.dart

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:collection/collection.dart';
import 'package:machine/app/app_notifier.dart';
import 'package:machine/data/repositories/project/project_repository.dart';
import 'package:machine/asset_cache/asset_models.dart';
import 'package:machine/asset_cache/asset_providers.dart';
import 'package:machine/editor/models/editor_tab_models.dart';
import 'package:machine/editor/models/editor_command_context.dart';
import 'package:machine/editor/tab_metadata_notifier.dart';
import 'package:machine/editor/services/editor_service.dart';
import 'package:machine/widgets/dialogs/folder_picker_dialog.dart';
import 'package:machine/settings/settings_notifier.dart';

import 'asset/flow_asset_models.dart';
import 'flow_graph_editor_tab.dart';
import 'flow_graph_notifier.dart';
import 'flow_graph_command_context.dart';
import 'flow_graph_settings_model.dart';
import 'widgets/flow_graph_canvas.dart';
import 'widgets/node_palette.dart';

class FlowGraphEditorWidget extends EditorWidget {
  @override
  final FlowGraphEditorTab tab;

  const FlowGraphEditorWidget({required super.key, required this.tab})
      : super(tab: tab);

  @override
  FlowGraphEditorWidgetState createState() => FlowGraphEditorWidgetState();
}

class FlowGraphEditorWidgetState extends EditorWidgetState<FlowGraphEditorWidget> {
  late final FlowGraphNotifier _notifier;
  
  FlowGraphNotifier get notifier => _notifier;

  bool _isPaletteVisible = false;
  Set<AssetQuery> _requiredAssetQueries = {};

  @override
  void init() {
    _notifier = FlowGraphNotifier(widget.tab.initialGraph);
    _notifier.addListener(_onGraphChanged);
    
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _updateAssetDependencies();
      syncCommandContext();
    });
  }

  @override
  void onFirstFrameReady() {
    if (mounted && !widget.tab.onReady.isCompleted) {
      widget.tab.onReady.complete(this);
    }
  }

  void _updateAssetDependencies() {
    if (!mounted) return;

    final project = ref.read(appNotifierProvider).value?.currentProject;
    final repo = ref.read(projectRepositoryProvider);
    final tabMetadata = ref.read(tabMetadataProvider)[widget.tab.id];

    if (project == null || repo == null || tabMetadata == null) return;

    final contextPath = repo.fileHandler.getPathForDisplay(
      tabMetadata.file.uri,
      relativeTo: project.rootUri,
    );

    final newQueries = <AssetQuery>{};
    
    final schemaPath = _notifier.graph.schemaPath;
    if (schemaPath != null && schemaPath.isNotEmpty) {
      newQueries.add(AssetQuery(
        path: schemaPath,
        mode: AssetPathMode.relativeToContext,
        contextPath: contextPath,
      ));
    }

    if (!const SetEquality().equals(newQueries, _requiredAssetQueries)) {
      _requiredAssetQueries = newQueries;
      ref.read(assetMapProvider(widget.tab.id).notifier).updateUris(newQueries);
    }
  }

  void _onGraphChanged() {
    ref.read(editorServiceProvider).markCurrentTabDirty();
    _updateAssetDependencies();
    syncCommandContext();
    setState(() {});
  }

  void togglePalette() {
    setState(() => _isPaletteVisible = !_isPaletteVisible);
  }

  Future<void> linkSchema() async {
    final project = ref.read(appNotifierProvider).value?.currentProject;
    final repo = ref.read(projectRepositoryProvider);
    final metadata = ref.read(tabMetadataProvider)[widget.tab.id];

    if (project == null || repo == null || metadata == null) return;

    final parentUri = repo.fileHandler.getParentUri(metadata.file.uri);
    
    final selectedPath = await showDialog<String>(
      context: context,
      builder: (_) => FileOrFolderPickerDialog(initialUri: parentUri),
    );

    if (selectedPath == null) return;

    final contextPath = repo.fileHandler.getPathForDisplay(
      metadata.file.uri, 
      relativeTo: project.rootUri
    );
    
    final relativeToGraph = repo.calculateRelativePath(contextPath, selectedPath);

    _notifier.setSchemaPath(relativeToGraph);
  }

  @override
  void syncCommandContext() {
    final hasSelection = _notifier.selectedNodeIds.isNotEmpty;
    
    ref.read(commandContextProvider(widget.tab.id).notifier).state = 
      FlowGraphCommandContext(hasSelection: hasSelection);
  }

  @override
  Widget build(BuildContext context) {
    ref.watch(assetMapProvider(widget.tab.id));

    final settings = ref.watch(effectiveSettingsProvider.select(
      (s) => s.pluginSettings[FlowGraphSettings] as FlowGraphSettings?
    )) ?? FlowGraphSettings();

    FlowSchemaAssetData? schemaData;
    final schemaPath = _notifier.graph.schemaPath;
    
    if (schemaPath != null) {
      final project = ref.watch(appNotifierProvider).value?.currentProject;
      final repo = ref.watch(projectRepositoryProvider);
      final metadata = ref.watch(tabMetadataProvider)[widget.tab.id];

      if (project != null && repo != null && metadata != null) {
        final contextPath = repo.fileHandler.getPathForDisplay(
          metadata.file.uri, 
          relativeTo: project.rootUri
        );
        
        final query = AssetQuery(
          path: schemaPath,
          mode: AssetPathMode.relativeToContext,
          contextPath: contextPath,
        );

        final asset = ref.watch(resolvedAssetProvider(
          ResolvedAssetRequest(tabId: widget.tab.id, query: query)
        ));
        
        if (asset is FlowSchemaAssetData) {
          schemaData = asset;
        }
      }
    }

    return Stack(
      children: [
        FlowGraphCanvas(
          notifier: _notifier,
          schemaMap: schemaData?.typeMap ?? {},
          settings: settings,
        ),

        if (_isPaletteVisible && schemaData != null)
          Positioned(
            right: 0,
            top: 0,
            bottom: 0,
            width: 250,
            child: NodePalette(
              schema: schemaData,
              onNodeSelected: (type) {
                final center = _notifier.graph.viewportPosition * -1 + const Offset(400, 300);
                _notifier.addNode(type.type, center);
                togglePalette();
              },
              onClose: togglePalette,
            ),
          ),
          
        if (_isPaletteVisible && schemaData == null)
           Positioned(
            right: 10,
            top: 50,
            child: Material(
              color: Colors.red.shade900,
              borderRadius: BorderRadius.circular(4),
              child: const Padding(
                padding: EdgeInsets.all(8.0),
                child: Text("No Schema Loaded.\nLink a flow_schema.json via toolbar.", style: TextStyle(color: Colors.white)),
              ),
            ),
           )
      ],
    );
  }

  @override
  void undo() => _notifier.undo();

  @override
  void redo() => _notifier.redo();

  @override
  Future<EditorContent> getContent() async {
    return EditorContentString(_notifier.graph.serialize());
  }

  @override
  void onSaveSuccess(String newHash) {}

  @override
  Future<TabHotStateDto?> serializeHotState() async => null;

  @override
  void dispose() {
    _notifier.removeListener(_onGraphChanged);
    _notifier.dispose();
    super.dispose();
  }
}

// FILE: lib/editor/plugins/flow_graph/flow_graph_notifier.dart

// FILE: lib/editor/plugins/flow_graph/flow_graph_notifier.dart

import 'package:flutter/material.dart';
import 'package:uuid/uuid.dart';
import 'models/flow_graph_models.dart';
import 'models/flow_schema_models.dart';

abstract class _FlowHistoryAction {
  void undo(FlowGraphNotifier notifier);
  void redo(FlowGraphNotifier notifier);
}

class _MoveNodeAction implements _FlowHistoryAction {
  final String nodeId;
  final Offset from;
  final Offset to;
  _MoveNodeAction(this.nodeId, this.from, this.to);
  @override
  void undo(n) => n._setNodePosition(nodeId, from);
  @override
  void redo(n) => n._setNodePosition(nodeId, to);
}

class _ConnectionAction implements _FlowHistoryAction {
  final FlowConnection connection;
  final bool isAdd;
  _ConnectionAction(this.connection, {required this.isAdd});
  @override
  void undo(n) => isAdd ? n._removeConnection(connection) : n._addConnection(connection);
  @override
  void redo(n) => isAdd ? n._addConnection(connection) : n._removeConnection(connection);
}

class FlowGraphNotifier extends ChangeNotifier {
  FlowGraph _graph;
  final List<_FlowHistoryAction> _undoStack = [];
  final List<_FlowHistoryAction> _redoStack = [];
  static const _maxHistory = 50;

  final Set<String> _selectedNodeIds = {};
  FlowConnection? _pendingConnection;
  Offset? _pendingConnectionPointer;
 
  FlowPortType? _draggingPortType;

  FlowGraphNotifier(this._graph);

  FlowGraph get graph => _graph;
  Set<String> get selectedNodeIds => _selectedNodeIds;
  FlowConnection? get pendingConnection => _pendingConnection;
  Offset? get pendingConnectionPointer => _pendingConnectionPointer;
  FlowPortType? get draggingPortType => _draggingPortType;


  void addNode(String type, Offset position, {Map<String, dynamic>? defaults}) {
    final newNode = FlowNode(
      id: const Uuid().v4(),
      type: type,
      position: position,
      properties: defaults ?? {},
    );
    _graph.nodes.add(newNode);
    notifyListeners();
  }
  
    void setSchemaPath(String path) {
    if (_graph.schemaPath == path) return;
    
    _graph = FlowGraph(
      nodes: _graph.nodes,
      connections: _graph.connections,
      viewportPosition: _graph.viewportPosition,
      viewportScale: _graph.viewportScale,
      schemaPath: path,
    );
    
    notifyListeners();
  }

  void moveNode(String nodeId, Offset newPosition) {
    _setNodePosition(nodeId, newPosition);
    notifyListeners();
  }

  void startConnectionDrag(String nodeId, String portKey, bool isInput, FlowPortType type) {
    _pendingConnection = FlowConnection(
      outputNodeId: nodeId, 
      outputPortKey: portKey, 
      inputNodeId: 'CURSOR', 
      inputPortKey: 'CURSOR',
    );
    _draggingPortType = type;
    notifyListeners();
  }

  void updateConnectionDrag(Offset localPosition) {
    _pendingConnectionPointer = localPosition;
    notifyListeners();
  }

  void endConnectionDrag(String? targetNodeId, String? targetPortKey) {
    if (_pendingConnection != null && targetNodeId != null && targetPortKey != null) {
      final newConnection = FlowConnection(
        outputNodeId: _pendingConnection!.outputNodeId,
        outputPortKey: _pendingConnection!.outputPortKey,
        inputNodeId: targetNodeId,
        inputPortKey: targetPortKey,
      );
      
      _graph.connections.removeWhere((c) => 
          c.inputNodeId == targetNodeId && c.inputPortKey == targetPortKey);

      if (!_graph.connections.contains(newConnection)) {
        if (newConnection.outputNodeId != newConnection.inputNodeId) {
           _addConnection(newConnection);
           _record(_ConnectionAction(newConnection, isAdd: true));
        }
      }
    }
    _pendingConnection = null;
    _pendingConnectionPointer = null;
    _draggingPortType = null;
    notifyListeners();
  }

  void deleteConnection(String inputNodeId, String inputPortKey) {
    final toRemove = _graph.connections.where((c) => 
      c.inputNodeId == inputNodeId && c.inputPortKey == inputPortKey
    ).toList();
    
    for (final c in toRemove) {
      removeConnection(c);
    }
  }
  
  void deleteNode(String nodeId) {
    _graph.nodes.removeWhere((n) => n.id == nodeId);
    _graph.connections.removeWhere((c) => c.inputNodeId == nodeId || c.outputNodeId == nodeId);
    _selectedNodeIds.remove(nodeId);
    notifyListeners();
  }


  void removeConnection(FlowConnection connection) {
    _removeConnection(connection);
    _record(_ConnectionAction(connection, isAdd: false));
    notifyListeners();
  }

  void deleteSelection() {
    for (final id in _selectedNodeIds) {
      _graph.nodes.removeWhere((n) => n.id == id);
      _graph.connections.removeWhere((c) => c.inputNodeId == id || c.outputNodeId == id);
    }
    _selectedNodeIds.clear();
    notifyListeners();
  }

  void selectNode(String id, {bool multi = false}) {
    if (!multi) _selectedNodeIds.clear();
    _selectedNodeIds.add(id);
    notifyListeners();
  }

  void clearSelection() {
    _selectedNodeIds.clear();
    notifyListeners();
  }

  void updateNodeProperty(String nodeId, String key, dynamic value) {
    final nodeIndex = _graph.nodes.indexWhere((n) => n.id == nodeId);
    if (nodeIndex == -1) return;

    final oldNode = _graph.nodes[nodeIndex];
    final newProps = Map<String, dynamic>.from(oldNode.properties);
    newProps[key] = value;

    _graph.nodes[nodeIndex] = oldNode.copyWith(properties: newProps);
    notifyListeners();
  }


  void _setNodePosition(String id, Offset pos) {
    final idx = _graph.nodes.indexWhere((n) => n.id == id);
    if (idx != -1) {
      _graph.nodes[idx] = _graph.nodes[idx].copyWith(position: pos);
    }
  }

  void _addConnection(FlowConnection c) => _graph.connections.add(c);
  void _removeConnection(FlowConnection c) => _graph.connections.remove(c);

  void _record(_FlowHistoryAction action) {
    _redoStack.clear();
    _undoStack.add(action);
    if (_undoStack.length > _maxHistory) _undoStack.removeAt(0);
  }

  void undo() {
    if (_undoStack.isEmpty) return;
    final action = _undoStack.removeLast();
    action.undo(this);
    _redoStack.add(action);
    notifyListeners();
  }

  void redo() {
    if (_redoStack.isEmpty) return;
    final action = _redoStack.removeLast();
    action.redo(this);
    _undoStack.add(action);
    notifyListeners();
  }
}

// FILE: lib/editor/plugins/flow_graph/flow_graph_settings_model.dart

// FILE: lib/editor/plugins/flow_graph/flow_graph_settings_model.dart

import 'package:machine/editor/plugins/editor_plugin_registry.dart';

class FlowGraphSettings extends PluginSettings {
  int backgroundColorValue;
  int gridColorValue;
  double gridSpacing;
  double gridThickness;

  FlowGraphSettings({
    this.backgroundColorValue = 0xFF1E1E1E,
    this.gridColorValue = 0x0DFFFFFF,
    this.gridSpacing = 20.0,
    this.gridThickness = 1.0,
  });

  @override
  void fromJson(Map<String, dynamic> json) {
    backgroundColorValue = json['backgroundColorValue'] ?? 0xFF1E1E1E;
    gridColorValue = json['gridColorValue'] ?? 0x0DFFFFFF;
    gridSpacing = (json['gridSpacing'] ?? 20.0).toDouble();
    gridThickness = (json['gridThickness'] ?? 1.0).toDouble();
  }

  @override
  Map<String, dynamic> toJson() => {
        'backgroundColorValue': backgroundColorValue,
        'gridColorValue': gridColorValue,
        'gridSpacing': gridSpacing,
        'gridThickness': gridThickness,
      };

  FlowGraphSettings copyWith({
    int? backgroundColorValue,
    int? gridColorValue,
    double? gridSpacing,
    double? gridThickness,
  }) {
    return FlowGraphSettings(
      backgroundColorValue: backgroundColorValue ?? this.backgroundColorValue,
      gridColorValue: gridColorValue ?? this.gridColorValue,
      gridSpacing: gridSpacing ?? this.gridSpacing,
      gridThickness: gridThickness ?? this.gridThickness,
    );
  }

  @override
  FlowGraphSettings clone() {
    return FlowGraphSettings(
      backgroundColorValue: backgroundColorValue,
      gridColorValue: gridColorValue,
      gridSpacing: gridSpacing,
      gridThickness: gridThickness,
    );
  }
}

// FILE: lib/editor/plugins/flow_graph/models/flow_graph_models.dart

// FILE: lib/editor/plugins/flow_graph/models/flow_graph_models.dart

import 'dart:convert';
import 'dart:ui';
import 'package:flutter/foundation.dart';
import 'package:uuid/uuid.dart';

@immutable
class FlowConnection {
  final String outputNodeId;
  final String outputPortKey;
  final String inputNodeId;
  final String inputPortKey;

  const FlowConnection({
    required this.outputNodeId,
    required this.outputPortKey,
    required this.inputNodeId,
    required this.inputPortKey,
  });

  Map<String, dynamic> toJson() => {
        'outNode': outputNodeId,
        'outPort': outputPortKey,
        'inNode': inputNodeId,
        'inPort': inputPortKey,
      };

  factory FlowConnection.fromJson(Map<String, dynamic> json) {
    return FlowConnection(
      outputNodeId: json['outNode'],
      outputPortKey: json['outPort'],
      inputNodeId: json['inNode'],
      inputPortKey: json['inPort'],
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlowConnection &&
          runtimeType == other.runtimeType &&
          outputNodeId == other.outputNodeId &&
          outputPortKey == other.outputPortKey &&
          inputNodeId == other.inputNodeId &&
          inputPortKey == other.inputPortKey;

  @override
  int get hashCode => Object.hash(outputNodeId, outputPortKey, inputNodeId, inputPortKey);
}

class FlowNode {
  final String id;
  final String type;
  final Offset position;
  final Map<String, dynamic> properties;
  final Map<String, dynamic> customData;

  FlowNode({
    required this.id,
    required this.type,
    required this.position,
    this.properties = const {},
    this.customData = const {},
  });

  FlowNode copyWith({
    String? id,
    String? type,
    Offset? position,
    Map<String, dynamic>? properties,
    Map<String, dynamic>? customData,
  }) {
    return FlowNode(
      id: id ?? this.id,
      type: type ?? this.type,
      position: position ?? this.position,
      properties: properties ?? Map.from(this.properties),
      customData: customData ?? Map.from(this.customData),
    );
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'type': type,
        'x': position.dx,
        'y': position.dy,
        'properties': properties,
        if (customData.isNotEmpty) 'customData': customData,
      };

  factory FlowNode.fromJson(Map<String, dynamic> json) {
    return FlowNode(
      id: json['id'] ?? const Uuid().v4(),
      type: json['type'],
      position: Offset(
        (json['x'] as num).toDouble(),
        (json['y'] as num).toDouble(),
      ),
      properties: Map<String, dynamic>.from(json['properties'] ?? {}),
      customData: Map<String, dynamic>.from(json['customData'] ?? {}),
    );
  }
}

/// The root object for a Flow Graph file.
class FlowGraph {
  final List<FlowNode> nodes;
  final List<FlowConnection> connections;
  
  final Offset viewportPosition;
  final double viewportScale;
  final String? schemaPath;

  const FlowGraph({
    required this.nodes,
    required this.connections,
    this.viewportPosition = Offset.zero,
    this.viewportScale = 1.0,
    this.schemaPath,
  });

  String serialize() {
    final map = {
      if (schemaPath != null) 'schema': schemaPath,
      'nodes': nodes.map((n) => n.toJson()).toList(),
      'connections': connections.map((c) => c.toJson()).toList(),
      'viewport': {
        'x': viewportPosition.dx,
        'y': viewportPosition.dy,
        'zoom': viewportScale,
      }
    };
    return const JsonEncoder.withIndent('  ').convert(map);
  }

  factory FlowGraph.deserialize(String jsonString) {
    if (jsonString.trim().isEmpty) {
      return FlowGraph(
        nodes: <FlowNode>[], 
        connections: <FlowConnection>[]
      );
    }

    final json = jsonDecode(jsonString);
    
    final viewportJson = json['viewport'] ?? {};
    final viewportPos = Offset(
      (viewportJson['x'] as num? ?? 0).toDouble(),
      (viewportJson['y'] as num? ?? 0).toDouble(),
    );
    final viewportZoom = (viewportJson['zoom'] as num? ?? 1.0).toDouble();

    return FlowGraph(
      schemaPath: json['schema'],
      nodes: (json['nodes'] as List?)
              ?.map((e) => FlowNode.fromJson(e))
              .toList() ??
          <FlowNode>[],
      connections: (json['connections'] as List?)
              ?.map((e) => FlowConnection.fromJson(e))
              .toList() ??
          <FlowConnection>[],
      viewportPosition: viewportPos,
      viewportScale: viewportZoom,
    );
  }
}

// FILE: lib/editor/plugins/flow_graph/models/flow_references.dart

// FILE: lib/editor/plugins/flow_graph/models/flow_references.dart

import 'dart:convert';
import 'package:equatable/equatable.dart';

class TiledObjectReference extends Equatable {
  /// Relative path to the .tmx file from the project root.
  final String? sourceMapPath;
  
  final int layerId;
  final int objectId;

  final String? objectNameSnapshot; 

  const TiledObjectReference({
    this.sourceMapPath,
    required this.layerId,
    required this.objectId,
    this.objectNameSnapshot,
  });

  Map<String, dynamic> toJson() => {
        if (sourceMapPath != null) 'map': sourceMapPath,
        'layerId': layerId,
        'objectId': objectId,
        if (objectNameSnapshot != null) '_name': objectNameSnapshot,
      };

  factory TiledObjectReference.fromJson(Map<String, dynamic> json) {
    return TiledObjectReference(
      sourceMapPath: json['map'],
      layerId: json['layerId'],
      objectId: json['objectId'],
      objectNameSnapshot: json['_name'],
    );
  }
  
  static TiledObjectReference? fromDynamic(dynamic value) {
    if (value == null) return null;
    if (value is TiledObjectReference) return value;
    if (value is Map<String, dynamic>) return TiledObjectReference.fromJson(value);
    if (value is String) {
      try {
        return TiledObjectReference.fromJson(jsonDecode(value));
      } catch (_) {
        return null;
      }
    }
    return null;
  }

  @override
  List<Object?> get props => [sourceMapPath, layerId, objectId];
  
  @override
  String toString() => 'Ref(Map: $sourceMapPath, L:$layerId, Obj:$objectId)';
}

// FILE: lib/editor/plugins/flow_graph/models/flow_schema_models.dart

// FILE: lib/editor/plugins/flow_graph/models/flow_schema_models.dart

import 'package:flutter/material.dart';

enum FlowPortType {
  execution,
  string,
  number,
  boolean,
  vector2,
  tiledObject,
  any,
}

enum FlowPropertyType {
  string,
  integer,
  float,
  bool,
  select,
  color,
  tiledObjectRef,
}

class FlowPortDefinition {
  final String key;
  final String label;
  final FlowPortType type;
  final Color? customColor;

  const FlowPortDefinition({
    required this.key,
    required this.label,
    required this.type,
    this.customColor,
  });

  factory FlowPortDefinition.fromJson(Map<String, dynamic> json) {
    return FlowPortDefinition(
      key: json['key'],
      label: json['name'] ?? json['key'],
      type: _parsePortType(json['type']),
      customColor: json['color'] != null ? _parseColor(json['color']) : null,
    );
  }

  static FlowPortType _parsePortType(String? type) {
    return FlowPortType.values.firstWhere(
      (e) => e.name == type,
      orElse: () => FlowPortType.any,
    );
  }
}

class FlowPropertyDefinition {
  final String key;
  final String label;
  final FlowPropertyType type;
  final dynamic defaultValue;
  final List<String>? options;

  const FlowPropertyDefinition({
    required this.key,
    required this.label,
    required this.type,
    this.defaultValue,
    this.options,
  });

  factory FlowPropertyDefinition.fromJson(Map<String, dynamic> json) {
    return FlowPropertyDefinition(
      key: json['key'],
      label: json['name'] ?? json['key'],
      type: _parsePropertyType(json['type']),
      defaultValue: json['default'],
      options: (json['options'] as List?)?.map((e) => e.toString()).toList(),
    );
  }

  static FlowPropertyType _parsePropertyType(String? type) {
    return FlowPropertyType.values.firstWhere(
      (e) => e.name == type,
      orElse: () => FlowPropertyType.string,
    );
  }
}

class FlowNodeType {
  final String type;
  final String label;
  final String category;
  final String description;
  final List<FlowPortDefinition> inputs;
  final List<FlowPortDefinition> outputs;
  final List<FlowPropertyDefinition> properties;

  const FlowNodeType({
    required this.type,
    required this.label,
    required this.category,
    this.description = '',
    this.inputs = const [],
    this.outputs = const [],
    this.properties = const [],
  });

  factory FlowNodeType.fromJson(Map<String, dynamic> json) {
    return FlowNodeType(
      type: json['type'],
      label: json['label'] ?? json['type'],
      category: json['category'] ?? 'General',
      description: json['description'] ?? '',
      inputs: (json['inputs'] as List?)
              ?.map((e) => FlowPortDefinition.fromJson(e))
              .toList() ??
          [],
      outputs: (json['outputs'] as List?)
              ?.map((e) => FlowPortDefinition.fromJson(e))
              .toList() ??
          [],
      properties: (json['properties'] as List?)
              ?.map((e) => FlowPropertyDefinition.fromJson(e))
              .toList() ??
          [],
    );
  }
}

Color _parseColor(String hex) {
  hex = hex.replaceAll('#', '');
  if (hex.length == 6) hex = 'FF$hex';
  return Color(int.parse(hex, radix: 16));
}

// FILE: lib/editor/plugins/flow_graph/utils/flow_layout_utils.dart

// FILE: lib/editor/plugins/flow_graph/utils/flow_layout_utils.dart

import 'dart:ui';
import '../models/flow_graph_models.dart';
import '../models/flow_schema_models.dart';

class FlowLayoutUtils {
  static const double headerHeight = 40.0;
  static const double rowHeight = 32.0;
  static const double nodeWidth = 200.0;

  static Offset? getPortPosition(
    FlowNode node, 
    String portKey, 
    bool isInput, 
    FlowNodeType? schema
  ) {
    if (schema == null) return node.position + const Offset(10, 10);

    final list = isInput ? schema.inputs : schema.outputs;
    final index = list.indexWhere((p) => p.key == portKey);
    
    if (index == -1) return node.position;

    final y = node.position.dy + 
              headerHeight + 
              8.0 +
              (index * rowHeight) + 
              (rowHeight / 2); 
    
    final x = isInput 
        ? node.position.dx + 6.0 
        : node.position.dx + nodeWidth - 6.0; 

    return Offset(x, y);
  }

  static Path generateConnectionPath(Offset p1, Offset p2) {
    final path = Path();
    path.moveTo(p1.dx, p1.dy);

    final dx = (p2.dx - p1.dx).abs();
    final curvature = (dx / 2).clamp(30.0, 150.0);

    path.cubicTo(
      p1.dx + curvature, p1.dy,
      p2.dx - curvature, p2.dy,
      p2.dx, p2.dy,
    );
    return path;
  }

  static bool isPointNearPath(Offset point, Path path, {double threshold = 10.0}) {
    final thresholdSq = threshold * threshold;
    final metrics = path.computeMetrics();
    
    for (final metric in metrics) {
      for (double d = 0; d < metric.length; d += 6.0) {
        final pos = metric.getTangentForOffset(d)!.position;
        if ((point - pos).distanceSquared < thresholdSq) {
          return true;
        }
      }
    }
    return false;
  }
}

// FILE: lib/editor/plugins/flow_graph/widgets/flow_connection_painter.dart

// FILE: lib/editor/plugins/flow_graph/widgets/flow_connection_painter.dart

import 'package:flutter/material.dart';
import '../models/flow_graph_models.dart';
import '../models/flow_schema_models.dart';
import '../utils/flow_layout_utils.dart';

class FlowConnectionPainter extends CustomPainter {
  final List<FlowConnection> connections;
  final List<FlowNode> nodes;
  final Map<String, FlowNodeType> schemaMap;
  final FlowConnection? pendingConnection;
  final Offset? pendingCursor;

  FlowConnectionPainter({
    required this.connections,
    required this.nodes,
    required this.schemaMap,
    this.pendingConnection,
    this.pendingCursor,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.0
      ..strokeCap = StrokeCap.round;

    for (final conn in connections) {
      final outNode = _getNode(conn.outputNodeId);
      final inNode = _getNode(conn.inputNodeId);
      
      final outPos = FlowLayoutUtils.getPortPosition(outNode, conn.outputPortKey, false, schemaMap[outNode.type]);
      final inPos = FlowLayoutUtils.getPortPosition(inNode, conn.inputPortKey, true, schemaMap[inNode.type]);

      if (outPos != null && inPos != null) {
        paint.color = Colors.white70;
        final path = FlowLayoutUtils.generateConnectionPath(outPos, inPos);
        canvas.drawPath(path, paint);
      }
    }

    if (pendingConnection != null && pendingCursor != null) {
      final outNode = _getNode(pendingConnection!.outputNodeId);
      final startPos = FlowLayoutUtils.getPortPosition(
        outNode, 
        pendingConnection!.outputPortKey, 
        false, 
        schemaMap[outNode.type]
      );
      
      if (startPos != null) {
        paint.color = Colors.yellowAccent;
        final path = FlowLayoutUtils.generateConnectionPath(startPos, pendingCursor!);
        canvas.drawPath(path, paint);
      }
    }
  }

  FlowNode _getNode(String id) {
    return nodes.firstWhere(
      (n) => n.id == id, 
      orElse: () => FlowNode(id: '', type: '', position: Offset.zero)
    );
  }

  @override
  bool shouldRepaint(covariant FlowConnectionPainter old) => true;
}

// FILE: lib/editor/plugins/flow_graph/widgets/flow_graph_canvas.dart

// FILE: lib/editor/plugins/flow_graph/widgets/flow_graph_canvas.dart

import 'package:flutter/material.dart';
import '../flow_graph_notifier.dart';
import '../models/flow_schema_models.dart';
import '../models/flow_graph_models.dart';
import '../flow_graph_settings_model.dart';
import '../utils/flow_layout_utils.dart';
import 'schema_node_widget.dart';
import 'flow_connection_painter.dart';

class FlowGraphCanvas extends StatefulWidget {
  final FlowGraphNotifier notifier;
  final Map<String, FlowNodeType> schemaMap;
  final FlowGraphSettings settings;

  const FlowGraphCanvas({
    super.key,
    required this.notifier,
    required this.schemaMap,
    required this.settings,
  });

  @override
  State<FlowGraphCanvas> createState() => _FlowGraphCanvasState();
}

class _FlowGraphCanvasState extends State<FlowGraphCanvas> {
  final TransformationController _transformCtrl = TransformationController();
  final GlobalKey _stackKey = GlobalKey();

  @override
  void initState() {
    super.initState();
    final initialPos = widget.notifier.graph.viewportPosition;
    final initialScale = widget.notifier.graph.viewportScale;
    final matrix = Matrix4.identity()..translate(initialPos.dx, initialPos.dy)..scale(initialScale);
    _transformCtrl.value = matrix;
    _transformCtrl.addListener(() {
      if (mounted) setState(() {}); 
    });
  }

  @override
  void dispose() {
    _transformCtrl.dispose();
    super.dispose();
  }

  Offset _globalToLocal(Offset global) {
    final RenderBox? box = _stackKey.currentContext?.findRenderObject() as RenderBox?;
    if (box != null) return box.globalToLocal(global);
    return global;
  }

  void _handleDoubleTap(TapDownDetails details) {
    final localPos = _globalToLocal(details.globalPosition);
    
    final graph = widget.notifier.graph;
    final nodes = graph.nodes;
    
    for (final conn in graph.connections) {
      final outNode = nodes.firstWhere((n) => n.id == conn.outputNodeId, orElse: () => FlowNode(id: '', type: '', position: Offset.zero));
      final inNode = nodes.firstWhere((n) => n.id == conn.inputNodeId, orElse: () => FlowNode(id: '', type: '', position: Offset.zero));
      
      if (outNode.id.isEmpty || inNode.id.isEmpty) continue;

      final outPos = FlowLayoutUtils.getPortPosition(outNode, conn.outputPortKey, false, widget.schemaMap[outNode.type]);
      final inPos = FlowLayoutUtils.getPortPosition(inNode, conn.inputPortKey, true, widget.schemaMap[inNode.type]);

      if (outPos != null && inPos != null) {
        final path = FlowLayoutUtils.generateConnectionPath(outPos, inPos);
        if (FlowLayoutUtils.isPointNearPath(localPos, path, threshold: 12.0)) {
          widget.notifier.removeConnection(conn);
          return;
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final currentScale = _transformCtrl.value.getMaxScaleOnAxis();

    return ListenableBuilder(
      listenable: widget.notifier,
      builder: (context, _) {
        final graph = widget.notifier.graph;
        return Stack(
          children: [
            GestureDetector(
              onTap: () => widget.notifier.clearSelection(),
              onDoubleTapDown: _handleDoubleTap, 
              child: InteractiveViewer(
                transformationController: _transformCtrl,
                boundaryMargin: const EdgeInsets.all(double.infinity),
                minScale: 0.1,
                maxScale: 2.0,
                constrained: false,
                child: SizedBox(
                  width: 50000,
                  height: 50000,
                  child: Stack(
                    key: _stackKey,
                    clipBehavior: Clip.none,
                    children: [
                      Positioned.fill(
                        child: CustomPaint(
                          painter: GridPainter(
                            scale: currentScale,
                            offset: Offset.zero,
                            settings: widget.settings,
                          ),
                        ),
                      ),
                      Positioned.fill(
                        child: CustomPaint(
                          painter: FlowConnectionPainter(
                            connections: graph.connections,
                            nodes: graph.nodes,
                            schemaMap: widget.schemaMap,
                            pendingConnection: widget.notifier.pendingConnection,
                            pendingCursor: widget.notifier.pendingConnectionPointer,
                          ),
                        ),
                      ),
                      ...graph.nodes.map((node) {
                        return Positioned(
                          left: node.position.dx,
                          top: node.position.dy,
                          child: SchemaNodeWidget(
                            node: node,
                            schema: widget.schemaMap[node.type],
                            isSelected: widget.notifier.selectedNodeIds.contains(node.id),
                            notifier: widget.notifier,
                            globalToLocal: _globalToLocal,
                            canvasScale: currentScale,
                          ),
                        );
                      }),
                    ],
                  ),
                ),
              ),
            ),
          ],
        );
      },
    );
  }
}

class GridPainter extends CustomPainter {
  final double scale;
  final Offset offset;
  final FlowGraphSettings settings;
  GridPainter({required this.scale, required this.offset, required this.settings});
  @override
  void paint(Canvas canvas, Size size) {
    final bgPaint = Paint()..color = Color(settings.backgroundColorValue);
    canvas.drawRect(Offset.zero & size, bgPaint);
    final linePaint = Paint()..color = Color(settings.gridColorValue)..strokeWidth = settings.gridThickness;
    final gridSize = settings.gridSpacing;
    for (double x = 0; x < size.width; x += gridSize) canvas.drawLine(Offset(x, 0), Offset(x, size.height), linePaint);
    for (double y = 0; y < size.height; y += gridSize) canvas.drawLine(Offset(0, y), Offset(size.width, y), linePaint);
  }
  @override
  bool shouldRepaint(covariant GridPainter old) => old.scale != scale || old.settings != settings;
}

// FILE: lib/editor/plugins/flow_graph/widgets/flow_graph_settings_widget.dart

// FILE: lib/editor/plugins/flow_graph/widgets/flow_graph_settings_widget.dart

import 'package:flex_color_picker/flex_color_picker.dart';
import 'package:flutter/material.dart';
import '../flow_graph_settings_model.dart';

class FlowGraphSettingsWidget extends StatelessWidget {
  final FlowGraphSettings settings;
  final void Function(FlowGraphSettings) onChanged;

  const FlowGraphSettingsWidget({
    super.key,
    required this.settings,
    required this.onChanged,
  });

  Future<void> _pickColor(BuildContext context, Color current, Function(int) onSave) async {
    final newColor = await showColorPickerDialog(
      context,
      current,
      enableOpacity: true,
      showColorCode: true,
    );
    onSave(newColor.value);
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        ListTile(
          contentPadding: EdgeInsets.zero,
          title: const Text('Background Color'),
          trailing: ColorIndicator(
            color: Color(settings.backgroundColorValue),
            onSelect: () => _pickColor(
              context,
              Color(settings.backgroundColorValue),
              (val) => onChanged(settings.copyWith(backgroundColorValue: val)),
            ),
          ),
        ),
        ListTile(
          contentPadding: EdgeInsets.zero,
          title: const Text('Grid Line Color'),
          trailing: ColorIndicator(
            color: Color(settings.gridColorValue),
            onSelect: () => _pickColor(
              context,
              Color(settings.gridColorValue),
              (val) => onChanged(settings.copyWith(gridColorValue: val)),
            ),
          ),
        ),
        const SizedBox(height: 16),
        Text('Grid Spacing: ${settings.gridSpacing.toStringAsFixed(0)}'),
        Slider(
          value: settings.gridSpacing,
          min: 10.0,
          max: 100.0,
          divisions: 18,
          label: settings.gridSpacing.toStringAsFixed(0),
          onChanged: (value) {
            onChanged(settings.copyWith(gridSpacing: value));
          },
        ),
        Text('Grid Thickness: ${settings.gridThickness.toStringAsFixed(1)}'),
        Slider(
          value: settings.gridThickness,
          min: 0.5,
          max: 5.0,
          divisions: 9,
          label: settings.gridThickness.toStringAsFixed(1),
          onChanged: (value) {
            onChanged(settings.copyWith(gridThickness: value));
          },
        ),
      ],
    );
  }
}

// FILE: lib/editor/plugins/flow_graph/widgets/node_palette.dart

// FILE: lib/editor/plugins/flow_graph/widgets/node_palette.dart

import 'package:flutter/material.dart';
import '../asset/flow_asset_models.dart';
import '../models/flow_schema_models.dart';

class NodePalette extends StatefulWidget {
  final FlowSchemaAssetData schema;
  final ValueChanged<FlowNodeType> onNodeSelected;
  final VoidCallback onClose;

  const NodePalette({
    super.key,
    required this.schema,
    required this.onNodeSelected,
    required this.onClose,
  });

  @override
  State<NodePalette> createState() => _NodePaletteState();
}

class _NodePaletteState extends State<NodePalette> {
  String _searchQuery = '';

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    final filtered = widget.schema.nodeTypes.where((n) {
      return n.label.toLowerCase().contains(_searchQuery.toLowerCase()) ||
             n.category.toLowerCase().contains(_searchQuery.toLowerCase());
    }).toList();

    final grouped = <String, List<FlowNodeType>>{};
    for (var node in filtered) {
      grouped.putIfAbsent(node.category, () => []).add(node);
    }

    return Material(
      elevation: 8,
      color: theme.colorScheme.surface,
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: Row(
              children: [
                const Text("Add Node", style: TextStyle(fontWeight: FontWeight.bold)),
                const Spacer(),
                IconButton(icon: const Icon(Icons.close, size: 18), onPressed: widget.onClose),
              ],
            ),
          ),
          
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8.0),
            child: TextField(
              decoration: const InputDecoration(
                hintText: "Search...",
                prefixIcon: Icon(Icons.search, size: 16),
                isDense: true,
                border: OutlineInputBorder(),
              ),
              onChanged: (val) => setState(() => _searchQuery = val),
            ),
          ),
          const SizedBox(height: 8),

          Expanded(
            child: ListView.builder(
              itemCount: grouped.keys.length,
              itemBuilder: (context, index) {
                final category = grouped.keys.elementAt(index);
                final nodes = grouped[category]!;
                
                return ExpansionTile(
                  title: Text(category, style: const TextStyle(fontSize: 14)),
                  initiallyExpanded: true,
                  children: nodes.map((node) {
                    return ListTile(
                      dense: true,
                      title: Text(node.label),
                      subtitle: node.description.isNotEmpty 
                          ? Text(node.description, maxLines: 1, overflow: TextOverflow.ellipsis) 
                          : null,
                      onTap: () => widget.onNodeSelected(node),
                    );
                  }).toList(),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

// FILE: lib/editor/plugins/flow_graph/widgets/property_tiled_object_picker.dart

// FILE: lib/editor/plugins/flow_graph/widgets/property_tiled_object_picker.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:tiled/tiled.dart' hide Text;
import 'package:machine/data/repositories/project/project_repository.dart';
import 'package:machine/widgets/dialogs/folder_picker_dialog.dart';
import '../models/flow_references.dart';
import '../models/flow_schema_models.dart';

class PropertyTiledObjectPicker extends ConsumerWidget {
  final FlowPropertyDefinition definition;
  final TiledObjectReference? value;
  final ValueChanged<TiledObjectReference> onChanged;

  const PropertyTiledObjectPicker({
    super.key,
    required this.definition,
    required this.value,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final displayText = value != null
        ? '${value!.objectNameSnapshot ?? "Obj#${value!.objectId}"} (L:${value!.layerId})'
        : 'Select Object...';

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(definition.label, style: const TextStyle(fontSize: 10, color: Colors.grey)),
          const SizedBox(height: 2),
          InkWell(
            onTap: () => _showPickerDialog(context, ref),
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
              decoration: BoxDecoration(
                color: Colors.black38,
                borderRadius: BorderRadius.circular(4),
                border: Border.all(color: Colors.grey.shade700),
              ),
              child: Row(
                children: [
                  Icon(Icons.category, size: 14, color: Colors.green.shade300),
                  const SizedBox(width: 6),
                  Expanded(
                    child: Text(
                      displayText,
                      style: const TextStyle(fontSize: 11, color: Colors.white),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  const Icon(Icons.arrow_drop_down, size: 16, color: Colors.grey),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _showPickerDialog(BuildContext context, WidgetRef ref) async {
    final repo = ref.read(projectRepositoryProvider);
    if (repo == null) return;

    final result = await showDialog<TiledObjectReference>(
      context: context,
      builder: (ctx) => _TiledObjectSelectionDialog(
        initialValue: value,
        repo: repo,
      ),
    );

    if (result != null) {
      onChanged(result);
    }
  }
}

class _TiledObjectSelectionDialog extends StatefulWidget {
  final TiledObjectReference? initialValue;
  final ProjectRepository repo;

  const _TiledObjectSelectionDialog({required this.initialValue, required this.repo});

  @override
  State<_TiledObjectSelectionDialog> createState() => _TiledObjectSelectionDialogState();
}

class _TiledObjectSelectionDialogState extends State<_TiledObjectSelectionDialog> {
  String? _selectedMapPath;
  int? _selectedLayerId;
  int? _selectedObjectId;
  String? _selectedObjectName;

  TiledMap? _parsedMap;
  bool _isLoadingMap = false;

  @override
  void initState() {
    super.initState();
    if (widget.initialValue != null) {
      _selectedMapPath = widget.initialValue!.sourceMapPath;
      _selectedLayerId = widget.initialValue!.layerId;
      _selectedObjectId = widget.initialValue!.objectId;
      if (_selectedMapPath != null) {
        _loadMap(_selectedMapPath!);
      }
    }
  }

  Future<void> _loadMap(String path) async {
    setState(() => _isLoadingMap = true);
    try {
      final file = await widget.repo.fileHandler.resolvePath(widget.repo.rootUri, path);
      if (file != null) {
        final content = await widget.repo.readFile(file.uri);
        final map = TileMapParser.parseTmx(content);
        setState(() => _parsedMap = map);
      }
    } catch (e) {
    } finally {
      setState(() => _isLoadingMap = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Select Tiled Object'),
      content: SizedBox(
        width: 400,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              title: const Text('Map File'),
              subtitle: Text(_selectedMapPath ?? 'None'),
              trailing: const Icon(Icons.folder_open),
              onTap: () async {
                final path = await showDialog<String>(
                  context: context,
                  builder: (_) => const FileOrFolderPickerDialog(),
                );
                if (path != null && path.endsWith('.tmx')) {
                  setState(() {
                    _selectedMapPath = path;
                    _selectedLayerId = null;
                    _selectedObjectId = null;
                    _parsedMap = null;
                  });
                  _loadMap(path);
                }
              },
            ),
            const Divider(),
            
            if (_isLoadingMap)
              const Center(child: CircularProgressIndicator())
            else if (_parsedMap != null) ...[
              DropdownButtonFormField<int>(
                value: _selectedLayerId,
                decoration: const InputDecoration(labelText: 'Layer'),
                items: _parsedMap!.layers
                    .whereType<ObjectGroup>()
                    .map((l) => DropdownMenuItem(
                          value: l.id,
                          child: Text(l.name),
                        ))
                    .toList(),
                onChanged: (val) {
                  setState(() {
                    _selectedLayerId = val;
                    _selectedObjectId = null;
                  });
                },
              ),
              const SizedBox(height: 16),
              
              if (_selectedLayerId != null)
                DropdownButtonFormField<int>(
                  value: _selectedObjectId,
                  decoration: const InputDecoration(labelText: 'Object'),
                  items: _getObjectsInLayer(_selectedLayerId!).map((o) {
                    final name = o.name.isEmpty ? 'Object ${o.id}' : o.name;
                    return DropdownMenuItem(
                      value: o.id,
                      onTap: () => _selectedObjectName = name,
                      child: Text('$name (ID:${o.id})'),
                    );
                  }).toList(),
                  onChanged: (val) => setState(() => _selectedObjectId = val),
                ),
            ],
          ],
        ),
      ),
      actions: [
        TextButton(onPressed: () => Navigator.pop(context), child: const Text('Cancel')),
        FilledButton(
          onPressed: _selectedMapPath != null && _selectedLayerId != null && _selectedObjectId != null
              ? () {
                  Navigator.pop(
                    context,
                    TiledObjectReference(
                      sourceMapPath: _selectedMapPath,
                      layerId: _selectedLayerId!,
                      objectId: _selectedObjectId!,
                      objectNameSnapshot: _selectedObjectName,
                    ),
                  );
                }
              : null,
          child: const Text('Select'),
        ),
      ],
    );
  }

  List<TiledObject> _getObjectsInLayer(int layerId) {
    if (_parsedMap == null) return [];
    final layer = _parsedMap!.layers.firstWhere(
      (l) => l.id == layerId, 
      orElse: () => ObjectGroup(id: -1, name: 'dummy', objects: []),
    );
    if (layer is ObjectGroup) {
      return layer.objects;
    }
    return [];
  }
}

// FILE: lib/editor/plugins/flow_graph/widgets/schema_node_widget.dart

// FILE: lib/editor/plugins/flow_graph/widgets/schema_node_widget.dart

import 'package:flex_color_picker/flex_color_picker.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:collection/collection.dart';
import '../flow_graph_notifier.dart';
import '../models/flow_graph_models.dart';
import '../models/flow_schema_models.dart';
import '../models/flow_references.dart';
import 'property_tiled_object_picker.dart';

class SchemaNodeWidget extends StatelessWidget {
  final FlowNode node;
  final FlowNodeType? schema;
  final bool isSelected;
  final FlowGraphNotifier notifier;
  final Offset Function(Offset) globalToLocal;
  final double canvasScale;

  const SchemaNodeWidget({
    super.key,
    required this.node,
    required this.schema,
    required this.isSelected,
    required this.notifier,
    required this.globalToLocal,
    required this.canvasScale,
  });

  bool _isInputConnected(String portKey) {
    return notifier.graph.connections.any(
      (c) => c.inputNodeId == node.id && c.inputPortKey == portKey
    );
  }

  @override
  Widget build(BuildContext context) {
    if (schema == null) return _buildErrorNode();

    final inputKeys = schema!.inputs.map((i) => i.key).toSet();
    final standaloneProps = schema!.properties.where((p) => !inputKeys.contains(p.key)).toList();

    return GestureDetector(
      onPanUpdate: (details) {
        notifier.moveNode(node.id, node.position + (details.delta / canvasScale));
      },
      onSecondaryTapUp: (details) => _showNodeContextMenu(context, details.globalPosition),
      onTap: () => notifier.selectNode(node.id),
      child: Container(
        width: 200, 
        decoration: BoxDecoration(
          color: const Color(0xFF2D2D2D),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: isSelected ? Colors.orange : Colors.black,
            width: isSelected ? 2 : 1,
          ),
          boxShadow: const [BoxShadow(blurRadius: 4, color: Colors.black26)],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              height: 40,
              padding: const EdgeInsets.symmetric(horizontal: 8),
              decoration: BoxDecoration(
                color: _getCategoryColor(schema!.category),
                borderRadius: const BorderRadius.vertical(top: Radius.circular(7)),
              ),
              child: Row(
                children: [
                  Expanded(
                    child: Text(
                      schema!.label,
                      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white, fontSize: 13),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  InkWell(
                    onTap: () => notifier.deleteNode(node.id),
                    child: const Icon(Icons.close, size: 16, color: Colors.white54),
                  )
                ],
              ),
            ),
            const SizedBox(height: 8),

            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: schema!.inputs.map((input) {
                      final prop = schema!.properties.firstWhereOrNull((p) => p.key == input.key);
                      final connected = _isInputConnected(input.key);
                      return _buildInputRow(context, input, prop, connected);
                    }).toList(),
                  ),
                ),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.end,
                    children: schema!.outputs.map((output) {
                      return _buildOutputRow(context, output);
                    }).toList(),
                  ),
                ),
              ],
            ),

            if (standaloneProps.isNotEmpty) ...[
              const Divider(color: Colors.white12, height: 16),
              ...standaloneProps.map((prop) => _buildPropertyField(context, prop)),
            ],
            
            const SizedBox(height: 8),
          ],
        ),
      ),
    );
  }

  void _showNodeContextMenu(BuildContext context, Offset globalPos) {
    final RenderBox overlay = Overlay.of(context).context.findRenderObject() as RenderBox;
    final RelativeRect position = RelativeRect.fromRect(
      globalPos & const Size(1, 1),
      Offset.zero & overlay.size,
    );

    showMenu(
      context: context,
      position: position,
      items: [
        const PopupMenuItem(value: 'delete', child: Text('Delete Node')),
      ],
    ).then((value) {
      if (value == 'delete') notifier.deleteNode(node.id);
    });
  }

  Widget _buildInputRow(BuildContext context, FlowPortDefinition port, FlowPropertyDefinition? prop, bool isConnected) {
    return SizedBox(
      height: 32, 
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildPortTarget(context, port, isConnected), 
          Expanded(
            child: _buildInputContent(context, port, prop, isConnected),
          ),
        ],
      ),
    );
  }

  Widget _buildInputContent(BuildContext context, FlowPortDefinition port, FlowPropertyDefinition? prop, bool isConnected) {
    if (isConnected || prop == null) {
      return Padding(
        padding: const EdgeInsets.only(left: 0),
        child: Align(
          alignment: Alignment.centerLeft,
          child: Text(
            port.label,
            style: const TextStyle(fontSize: 12, color: Colors.white70),
            overflow: TextOverflow.ellipsis,
          ),
        ),
      );
    }
    return Padding(
      padding: const EdgeInsets.only(left: 0),
      child: Align(
        alignment: Alignment.centerLeft,
        child: _buildInlineProperty(context, prop),
      ),
    );
  }

  Widget _buildOutputRow(BuildContext context, FlowPortDefinition port) {
    return SizedBox(
      height: 32,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          Expanded(
            child: Padding(
              padding: const EdgeInsets.only(right: 0, left: 4),
              child: Text(
                port.label,
                style: const TextStyle(fontSize: 12, color: Colors.white70),
                overflow: TextOverflow.ellipsis,
                textAlign: TextAlign.right,
              ),
            ),
          ),
          _buildPortSource(context, port),
        ],
      ),
    );
  }


  Widget _buildPortSource(BuildContext context, FlowPortDefinition port) {
    final color = _getPortColor(port);
    
    return Draggable<String>(
      data: node.id,
      feedback: const SizedBox.shrink(),
      hitTestBehavior: HitTestBehavior.opaque,
      onDragStarted: () => notifier.startConnectionDrag(node.id, port.key, false, port.type),
      onDragUpdate: (details) {
        final localPos = globalToLocal(details.globalPosition);
        notifier.updateConnectionDrag(localPos);
      },
      onDragEnd: (_) => notifier.endConnectionDrag(null, null),
      child: Container(
        width: 30,
        height: 30,
        alignment: Alignment.center,
        color: Colors.transparent,
        child: Container(
          width: 12,
          height: 12,
          decoration: BoxDecoration(
            color: color,
            shape: BoxShape.circle,
            border: Border.all(color: Colors.black87, width: 1.5),
          ),
        ),
      ),
    );
  }

  Widget _buildPortTarget(BuildContext context, FlowPortDefinition port, bool isConnected) {
    final color = _getPortColor(port);

    return GestureDetector(
      onSecondaryTap: () {
        if (isConnected) notifier.deleteConnection(node.id, port.key);
      },
      child: DragTarget<String>(
        builder: (context, candidateData, rejectedData) {
          final isHovering = candidateData.isNotEmpty;
          final finalColor = isHovering ? Colors.white : (isConnected ? Colors.white : color);
          
          return Container(
            width: 30,
            height: 30,
            alignment: Alignment.center,
            color: Colors.transparent,
            child: Container(
              width: 12,
              height: 12,
              decoration: BoxDecoration(
                color: finalColor,
                shape: BoxShape.circle,
                border: Border.all(
                  color: isHovering ? Colors.white : Colors.black87, 
                  width: isHovering ? 2.5 : 1.5
                ),
                boxShadow: isHovering ? [
                  BoxShadow(
                    color: color.withOpacity(0.8),
                    blurRadius: 8,
                    spreadRadius: 2,
                  )
                ] : null,
              ),
            ),
          );
        },
        onWillAccept: (data) {
          final draggingType = notifier.draggingPortType;
          if (draggingType == null) return false;
          if (draggingType == port.type) return true;
          if (draggingType == FlowPortType.execution && port.type != FlowPortType.execution) return false;
          if (draggingType != FlowPortType.execution && port.type == FlowPortType.execution) return false;
          if (draggingType == FlowPortType.any || port.type == FlowPortType.any) return true;
          return false;
        },
        onAccept: (data) => notifier.endConnectionDrag(node.id, port.key),
      ),
    );
  }

  
  Widget _buildPropertyField(BuildContext context, FlowPropertyDefinition prop) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      child: Row(
        children: [
          Text("${prop.label}: ", style: const TextStyle(fontSize: 11, color: Colors.white54)),
          Expanded(child: _buildInlineProperty(context, prop)),
        ],
      ),
    );
  }

  Widget _buildInlineProperty(BuildContext context, FlowPropertyDefinition prop) {
    final val = node.properties[prop.key] ?? prop.defaultValue;

    if (prop.type == FlowPropertyType.tiledObjectRef) {
      final refValue = TiledObjectReference.fromDynamic(val);
      return PropertyTiledObjectPicker(
        definition: prop,
        value: refValue,
        onChanged: (newRef) => notifier.updateNodeProperty(node.id, prop.key, newRef),
      );
    }

    if (prop.type == FlowPropertyType.bool) {
      final boolValue = val == true;
      return GestureDetector(
        onTap: () => notifier.updateNodeProperty(node.id, prop.key, !boolValue),
        child: Container(
          padding: const EdgeInsets.symmetric(vertical: 2),
          child: Row(
            children: [
              Icon(
                boolValue ? Icons.check_box : Icons.check_box_outline_blank,
                size: 16,
                color: boolValue ? Colors.greenAccent : Colors.grey,
              ),
              const SizedBox(width: 4),
              Text(boolValue ? "True" : "False", style: const TextStyle(fontSize: 11, color: Colors.white))
            ],
          ),
        ),
      );
    }

    if (prop.type == FlowPropertyType.color) {
      final color = _parseColor(val) ?? Colors.white;
      return GestureDetector(
        onTap: () => _showEditDialog(context, prop, val),
        child: Container(
          height: 16, width: 30,
          decoration: BoxDecoration(
            color: color,
            border: Border.all(color: Colors.white30),
            borderRadius: BorderRadius.circular(2),
          ),
        ),
      );
    }

    String display = "$val";
    if (prop.type == FlowPropertyType.select) display = "$val ▼";

    return GestureDetector(
      onTap: () => _showEditDialog(context, prop, val),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
        decoration: BoxDecoration(
          color: Colors.black26,
          borderRadius: BorderRadius.circular(4),
          border: Border.all(color: Colors.white12),
        ),
        child: Text(
          display,
          style: const TextStyle(fontSize: 11, color: Colors.white),
          overflow: TextOverflow.ellipsis,
        ),
      ),
    );
  }

  // Helper methods copied for completeness if full file replace
  Future<void> _showEditDialog(BuildContext context, FlowPropertyDefinition prop, dynamic currentValue) async {
    dynamic result;
    switch (prop.type) {
      case FlowPropertyType.string:
      case FlowPropertyType.integer:
      case FlowPropertyType.float:
        result = await showDialog(
          context: context,
          builder: (ctx) => _ValueEditDialog(
            title: prop.label,
            initialValue: currentValue?.toString() ?? '',
            isNumeric: prop.type != FlowPropertyType.string,
            isFloat: prop.type == FlowPropertyType.float,
          ),
        );
        if (result != null && prop.type == FlowPropertyType.integer) result = int.tryParse(result);
        if (result != null && prop.type == FlowPropertyType.float) result = double.tryParse(result);
        break;
      case FlowPropertyType.select:
        result = await showDialog(
          context: context,
          builder: (ctx) => SimpleDialog(
            title: Text("Select ${prop.label}"),
            children: (prop.options ?? []).map((opt) => SimpleDialogOption(
              onPressed: () => Navigator.pop(ctx, opt),
              child: Padding(padding: const EdgeInsets.symmetric(vertical: 4), child: Text(opt)),
            )).toList(),
          ),
        );
        break;
      case FlowPropertyType.color:
        final Color current = _parseColor(currentValue) ?? Colors.white;
        final newColor = await showColorPickerDialog(context, current, enableOpacity: true);
        result = '#${newColor.value.toRadixString(16).padLeft(8, '0').toUpperCase()}';
        break;
      default: break;
    }
    if (result != null) notifier.updateNodeProperty(node.id, prop.key, result);
  }

  Widget _buildErrorNode() {
    return Container(
      width: 150, padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(color: Colors.red.shade900, borderRadius: BorderRadius.circular(8), border: Border.all(color: Colors.red)),
      child: Column(children: [Text(node.type, style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white)), const Text("Missing Schema", style: TextStyle(fontSize: 10, color: Colors.white70))]),
    );
  }

  Color _getPortColor(FlowPortDefinition port) {
    if (port.customColor != null) return port.customColor!;
    switch (port.type) {
      case FlowPortType.execution: return Colors.white;
      case FlowPortType.string: return const Color(0xFFE91E63);
      case FlowPortType.number: return const Color(0xFF00E676);
      case FlowPortType.boolean: return const Color(0xFFD50000);
      case FlowPortType.vector2: return const Color(0xFFFFEA00);
      case FlowPortType.tiledObject: return const Color(0xFF2979FF);
      default: return Colors.grey;
    }
  }

  Color _getCategoryColor(String category) {
    switch (category.toLowerCase()) {
      case 'logic': return const Color(0xFF1565C0);
      case 'math': return const Color(0xFF00695C);
      case 'events': return const Color(0xFFC62828);
      case 'tiled': return const Color(0xFF2E7D32);
      case 'debug': return const Color(0xFF424242);
      default: return const Color(0xFF455A64);
    }
  }
  
  Color? _parseColor(dynamic val) {
    if (val is String) { try { var hex = val.replaceAll('#', ''); if (hex.length == 6) hex = 'FF$hex'; return Color(int.parse(hex, radix: 16)); } catch (_) {} }
    return null;
  }
}

class _ValueEditDialog extends StatefulWidget {
  final String title;
  final String initialValue;
  final bool isNumeric;
  final bool isFloat;
  const _ValueEditDialog({required this.title, required this.initialValue, this.isNumeric = false, this.isFloat = false});
  @override
  State<_ValueEditDialog> createState() => _ValueEditDialogState();
}

class _ValueEditDialogState extends State<_ValueEditDialog> {
  late TextEditingController _ctrl;
  @override
  void initState() { super.initState(); _ctrl = TextEditingController(text: widget.initialValue); }
  @override
  void dispose() { _ctrl.dispose(); super.dispose(); }
  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text("Edit ${widget.title}"),
      content: TextField(
        controller: _ctrl, autofocus: true,
        keyboardType: widget.isNumeric ? TextInputType.numberWithOptions(decimal: widget.isFloat) : TextInputType.text,
        inputFormatters: widget.isNumeric ? [widget.isFloat ? FilteringTextInputFormatter.allow(RegExp(r'[0-9.-]')) : FilteringTextInputFormatter.digitsOnly] : null,
      ),
      actions: [
        TextButton(onPressed: () => Navigator.pop(context), child: const Text("Cancel")),
        FilledButton(onPressed: () => Navigator.pop(context, _ctrl.text), child: const Text("OK")),
      ],
    );
  }
}

// FILE: lib/editor/plugins/texture_packer/services/pixi_export_service.dart

import 'dart:convert';
import 'dart:ui' as ui;
import 'dart:typed_data';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/asset_cache/asset_models.dart';
import 'package:machine/data/repositories/project/project_repository.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_models.dart';
import 'package:machine/utils/texture_packer_algo.dart';
import 'package:machine/logs/logs_provider.dart';

final pixiExportServiceProvider = Provider<PixiExportService>((ref) {
  return PixiExportService(ref);
});

class PixiExportService {
  final Ref _ref;

  PixiExportService(this._ref);

  Future<void> export({
    required TexturePackerProject project,
    required Map<String, AssetData> assetDataMap,
    required String destinationFolderUri,
    required String fileName,
  }) async {
    final talker = _ref.read(talkerProvider);
    final repo = _ref.read(projectRepositoryProvider)!;

    talker.info('Starting Texture Packer export for $fileName...');

    final packerItems = <PackerInputItem<SpriteDefinition>>[];
    final spriteNames = <String, String>{};

    SourceImageConfig? findSourceConfig(String id) {
      SourceImageConfig? traverse(SourceImageNode node) {
        if (node.id == id && node.type == SourceNodeType.image) return node.content;
        for (final child in node.children) {
          final result = traverse(child);
          if (result != null) return result;
        }
        return null;
      }
      return traverse(project.sourceImagesRoot);
    }

    void collectSprites(PackerItemNode node) {
      if (node.type == PackerItemType.sprite) {
        final def = project.definitions[node.id];
        if (def is SpriteDefinition) {
          final sourceConfig = findSourceConfig(def.sourceImageId);
          if (sourceConfig != null) {
            if (assetDataMap.containsKey(sourceConfig.path) &&
                assetDataMap[sourceConfig.path] is ImageAssetData) {
              
              final pxRect = _calculatePixelRect(sourceConfig, def.gridRect);
              
              packerItems.add(PackerInputItem(
                width: pxRect.width,
                height: pxRect.height,
                data: def,
              ));
              spriteNames[node.id] = node.name;
            } else {
              talker.warning('Skipping sprite ${node.name}: Asset not loaded (${sourceConfig.path})');
            }
          }
        }
      } else {
        for (final child in node.children) collectSprites(child);
      }
    }
    collectSprites(project.tree);

    if (packerItems.isEmpty) {
      throw Exception('No valid sprites found to export.');
    }

    final packer = MaxRectsPacker(padding: 2);
    final packedResult = packer.pack(packerItems);

    final recorder = ui.PictureRecorder();
    final canvas = ui.Canvas(recorder);
    
    final paint = ui.Paint()..filterQuality = ui.FilterQuality.none;

    final framesData = <String, Map<String, dynamic>>{};

    for (final item in packedResult.items) {
      final def = item.data;
      final sourceConfig = findSourceConfig(def.sourceImageId)!;
      final asset = assetDataMap[sourceConfig.path] as ImageAssetData;
      
      final srcRect = _calculatePixelRect(sourceConfig, def.gridRect);
      final dstRect = ui.Rect.fromLTWH(item.x, item.y, item.width, item.height);

      canvas.drawImageRect(asset.image, srcRect, dstRect, paint);

      final nodeId = project.definitions.entries.firstWhere((e) => e.value == def).key;
      final name = spriteNames[nodeId] ?? 'unknown';

      framesData[name] = {
        "frame": {"x": item.x.toInt(), "y": item.y.toInt(), "w": item.width.toInt(), "h": item.height.toInt()},
        "rotated": false,
        "trimmed": false,
        "spriteSourceSize": {"x": 0, "y": 0, "w": item.width.toInt(), "h": item.height.toInt()},
        "sourceSize": {"w": item.width.toInt(), "h": item.height.toInt()},
        "anchor": {"x": 0.5, "y": 0.5} 
      };
    }

    final picture = recorder.endRecording();
    final atlasImage = await picture.toImage(packedResult.width.toInt(), packedResult.height.toInt());
    final pngBytes = await atlasImage.toByteData(format: ui.ImageByteFormat.png);

    if (pngBytes == null) {
      throw Exception('Failed to encode atlas image.');
    }

    final animationsData = <String, List<String>>{};
    
    void collectAnimations(PackerItemNode node) {
      if (node.type == PackerItemType.animation) {
        final frameNames = node.children
            .where((c) => c.type == PackerItemType.sprite)
            .map((c) => c.name)
            .toList();
        
        if (frameNames.isNotEmpty) {
          animationsData[node.name] = frameNames;
        }
      }
      for (final child in node.children) collectAnimations(child);
    }
    collectAnimations(project.tree);

    final jsonOutput = {
      "frames": framesData,
      "animations": animationsData,
      "meta": {
        "app": "Machine Editor",
        "version": "1.0",
        "image": "$fileName.png",
        "format": "RGBA8888",
        "size": {"w": packedResult.width.toInt(), "h": packedResult.height.toInt()},
        "scale": "1"
      }
    };

    await repo.createDocumentFile(
      destinationFolderUri,
      '$fileName.png',
      initialBytes: pngBytes.buffer.asUint8List(),
      overwrite: true,
    );

    const encoder = JsonEncoder.withIndent('  ');
    await repo.createDocumentFile(
      destinationFolderUri,
      '$fileName.json',
      initialContent: encoder.convert(jsonOutput),
      overwrite: true,
    );

    talker.info('Texture Packer export completed successfully.');
  }

  ui.Rect _calculatePixelRect(SourceImageConfig config, GridRect grid) {
    final s = config.slicing;
    final left = s.margin + grid.x * (s.tileWidth + s.padding);
    final top = s.margin + grid.y * (s.tileHeight + s.padding);
    final width = grid.width * s.tileWidth + (grid.width - 1) * s.padding;
    final height = grid.height * s.tileHeight + (grid.height - 1) * s.padding;
    return ui.Rect.fromLTWH(left.toDouble(), top.toDouble(), width.toDouble(), height.toDouble());
  }
}

// FILE: lib/editor/plugins/texture_packer/texture_packer_asset_resolver.dart

// FILE: lib/editor/plugins/texture_packer/texture_packer_asset_resolver.dart

import 'dart:ui' as ui;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/asset_cache/asset_models.dart';
import 'package:machine/asset_cache/asset_providers.dart';
import 'package:machine/data/repositories/project/project_repository.dart';
import 'package:machine/editor/tab_metadata_notifier.dart';
import 'package:machine/app/app_notifier.dart';
import 'package:machine/project/project_settings_notifier.dart';


class TexturePackerAssetResolver {
  final Map<String, AssetData> _assets;
  final ProjectRepository _repo;
  final String _tpackerPath; // The project-relative path of the .tpacker file.

  TexturePackerAssetResolver(this._assets, this._repo, this._tpackerPath);
  
  /// The [sourcePath] is the raw, relative path as stored in the .tpacker file
  ui.Image? getImage(String? sourcePath) {
    if (sourcePath == null || sourcePath.isEmpty) return null;

    // Use the stored tpacker file path as the context to resolve the relative asset path.
    final canonicalKey = _repo.resolveRelativePath(_tpackerPath, sourcePath);
    final asset = _assets[canonicalKey];

    if (asset is ImageAssetData) {
      return asset.image;
    }
    return null;
  }
}

final texturePackerAssetResolverProvider = Provider.family.autoDispose<AsyncValue<TexturePackerAssetResolver>, String>((ref, tabId) {
  final assetMapAsync = ref.watch(assetMapProvider(tabId));
  final repo = ref.watch(projectRepositoryProvider);
  final project = ref.watch(currentProjectProvider);
  final metadata = ref.watch(tabMetadataProvider)[tabId];

  return assetMapAsync.whenData((assetMap) {
    if (repo == null || project == null || metadata == null) {
      throw Exception("Project context is not available for TexturePackerAssetResolver.");
    }
    
    // Determine the project-relative path for the .tpacker file.
    final tpackerPath = repo.fileHandler.getPathForDisplay(metadata.file.uri, relativeTo: project.rootUri);
    
    return TexturePackerAssetResolver(assetMap, repo, tpackerPath);
  });
});


// FILE: lib/editor/plugins/texture_packer/texture_packer_command_context.dart

import 'package:flutter/material.dart';
import 'package:machine/editor/models/editor_command_context.dart';
import 'package:meta/meta.dart';

enum TexturePackerMode {
  panZoom,
  slicing,
  preview,
}

@immutable
class TexturePackerCommandContext extends CommandContext {
  final TexturePackerMode mode;
  final bool isSourceImagesPanelVisible;
  final bool isHierarchyPanelVisible;
  final bool hasSelection;

  const TexturePackerCommandContext({
    required this.mode,
    required this.isSourceImagesPanelVisible,
    required this.isHierarchyPanelVisible,
    required this.hasSelection,
    super.appBarOverride,
    super.appBarOverrideKey,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      super == other &&
          other is TexturePackerCommandContext &&
          runtimeType == other.runtimeType &&
          mode == other.mode &&
          isSourceImagesPanelVisible == other.isSourceImagesPanelVisible &&
          isHierarchyPanelVisible == other.isHierarchyPanelVisible &&
          hasSelection == other.hasSelection;

  @override
  int get hashCode =>
      super.hashCode ^
      mode.hashCode ^
      isSourceImagesPanelVisible.hashCode ^
      isHierarchyPanelVisible.hashCode ^
      hasSelection.hashCode;
}

// FILE: lib/editor/plugins/texture_packer/texture_packer_editor_models.dart

import 'package:flutter/material.dart';
import 'package:machine/editor/models/editor_tab_models.dart';
import 'texture_packer_editor_widget.dart';
import 'texture_packer_models.dart';

@immutable
class TexturePackerTab extends EditorTab {
  @override
  final GlobalKey<TexturePackerEditorWidgetState> editorKey;
  
  /// The initial state of the texture packer project, parsed from the .tpacker file.
  final TexturePackerProject initialProjectState;

  TexturePackerTab({
    required super.plugin,
    required this.initialProjectState,
    super.id,
    super.onReadyCompleter,
  }) : editorKey = GlobalKey<TexturePackerEditorWidgetState>();
  
  @override
  void dispose() {
  }
}

// FILE: lib/editor/plugins/texture_packer/texture_packer_editor_widget.dart

import 'dart:convert';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:collection/collection.dart';
import 'package:path/path.dart' as p;

import 'package:machine/asset_cache/asset_models.dart';
import 'package:machine/asset_cache/asset_providers.dart';
import 'package:machine/app/app_notifier.dart';
import 'package:machine/command/command_widgets.dart';
import 'package:machine/data/repositories/project/project_repository.dart';
import 'package:machine/editor/models/editor_command_context.dart';
import 'package:machine/editor/models/editor_tab_models.dart';
import 'package:machine/editor/services/editor_service.dart';
import 'package:machine/project/project_settings_notifier.dart';
import 'package:machine/utils/toast.dart';
import 'package:machine/widgets/dialogs/file_explorer_dialogs.dart';
import 'package:machine/editor/tab_metadata_notifier.dart';
import 'texture_packer_command_context.dart';
import 'texture_packer_editor_models.dart';
import 'texture_packer_models.dart';
import 'texture_packer_notifier.dart';
import 'texture_packer_plugin.dart';
import 'texture_packer_settings.dart';

import 'widgets/hierarchy_panel.dart';
import 'widgets/preview_view.dart';
import 'widgets/preview_app_bar.dart';
import 'widgets/slicing_app_bar.dart';
import 'widgets/slicing_view.dart';
import 'widgets/slicing_properties_dialog.dart';
import 'widgets/source_images_panel.dart';
import 'widgets/texture_packer_file_dialog.dart';
import 'texture_packer_asset_resolver.dart';

final activeSourceImageIdProvider = StateProvider.autoDispose<String?>((ref) => null);
final selectedNodeIdProvider = StateProvider.autoDispose<String?>((ref) => null);

class TexturePackerEditorWidget extends EditorWidget {
  @override
  final TexturePackerTab tab;

  const TexturePackerEditorWidget({required super.key, required this.tab})
      : super(tab: tab);

  @override
  TexturePackerEditorWidgetState createState() => TexturePackerEditorWidgetState();
}

class TexturePackerEditorWidgetState extends EditorWidgetState<TexturePackerEditorWidget> {
  
  late final TexturePackerNotifier _notifier;
  TexturePackerNotifier get notifier => _notifier;
  
  Set<AssetQuery> _requiredAssetQueries = const {};

  TexturePackerMode _mode = TexturePackerMode.panZoom;
  bool _isSourceImagesPanelVisible = false;
  bool _isHierarchyPanelVisible = false;
  
  late final TransformationController _transformationController;
  
  Offset? _dragStart;
  GridRect? _selectionRect;

  @override
  void init() {
    _transformationController = TransformationController();
    _notifier = TexturePackerNotifier(widget.tab.initialProjectState);
    _notifier.addListener(_onNotifierUpdate);
  }
  
  void _onNotifierUpdate() {
    if (!mounted) return;

    final currentSourceId = ref.read(activeSourceImageIdProvider);
    if (currentSourceId != null) {
      if (_notifier.findSourceImageConfig(currentSourceId) == null) {
        ref.read(activeSourceImageIdProvider.notifier).state = null;
      }
    }

    ref.read(editorServiceProvider).markCurrentTabDirty();
    
    syncCommandContext();
    
    _updateAndLoadAssetUris();
    
    setState(() {});
  }

  @override
  void dispose() {
    _notifier.removeListener(_onNotifierUpdate);
    _notifier.dispose();
    _transformationController.dispose();
    super.dispose();
  }

  @override
  void onFirstFrameReady() {
    if (mounted && !widget.tab.onReady.isCompleted) {
      widget.tab.onReady.complete(this);
    }
    _updateAndLoadAssetUris();
    syncCommandContext();
  }

  /// Traverses the SourceImage tree to find all file paths and tells the
  /// AssetMapNotifier to load them, using the .tpacker file as context.
  void _updateAndLoadAssetUris() {
    if (!mounted) return;

    final project = ref.read(appNotifierProvider).value?.currentProject;
    final repo = ref.read(projectRepositoryProvider);
    final tpackerFileMetadata = ref.read(tabMetadataProvider)[widget.tab.id];

    if (project == null || repo == null || tpackerFileMetadata == null) return;

    // GET the project-relative path of the .tpacker file. This is our context.
    final tpackerPath = repo.fileHandler.getPathForDisplay(
      tpackerFileMetadata.file.uri,
      relativeTo: project.rootUri,
    );
    
    final newQueries = <AssetQuery>{};
    void collectPaths(SourceImageNode node) {
      if (node.type == SourceNodeType.image && node.content != null) {
        if (node.content!.path.isNotEmpty) {
          // Describe the asset we need relative to our context file.
          newQueries.add(AssetQuery(
            path: node.content!.path,
            mode: AssetPathMode.relativeToContext,
            contextPath: tpackerPath,
          ));
        }
      }
      for (final child in node.children) collectPaths(child);
    }
    collectPaths(_notifier.project.sourceImagesRoot);

    if (!const SetEquality().equals(newQueries, _requiredAssetQueries)) {
      _requiredAssetQueries = newQueries;
      ref.read(assetMapProvider(widget.tab.id).notifier).updateUris(newQueries);
    }
  }


  void setMode(TexturePackerMode newMode) {
    if (_mode == newMode) {
      setState(() => _mode = TexturePackerMode.panZoom);
    } else {
      setState(() => _mode = newMode);
    }
    syncCommandContext();
  }

  void toggleSourceImagesPanel() {
    setState(() {
      _isSourceImagesPanelVisible = !_isSourceImagesPanelVisible;
      if (_isSourceImagesPanelVisible) _isHierarchyPanelVisible = false;
    });
    syncCommandContext();
  }

  void toggleHierarchyPanel() {
    setState(() {
      _isHierarchyPanelVisible = !_isHierarchyPanelVisible;
      if (_isHierarchyPanelVisible) _isSourceImagesPanelVisible = false;
    });
    syncCommandContext();
  }
  
  void cancelSpriteSelection() {
    setState(() {
      _dragStart = null;
      _selectionRect = null;
    });
    syncCommandContext();
  }


  Point<int>? _pixelToGridPoint(Offset positionInImage, SlicingConfig slicing) {
    if (positionInImage.dx < slicing.margin || positionInImage.dy < slicing.margin) return null;
    
    final effectiveX = positionInImage.dx - slicing.margin;
    final effectiveY = positionInImage.dy - slicing.margin;
    final cellW = slicing.tileWidth + slicing.padding;
    final cellH = slicing.tileHeight + slicing.padding;

    if (cellW <= 0 || cellH <= 0) return null;

    final gridX = (effectiveX / cellW).floor();
    final gridY = (effectiveY / cellH).floor();

    if (effectiveX % cellW >= slicing.tileWidth || effectiveY % cellH >= slicing.tileHeight) return null;

    return Point(gridX, gridY);
  }

  void onSlicingGestureStart(Offset localPosition, SlicingConfig slicing) {
    if (_mode != TexturePackerMode.slicing) return;

    final invMatrix = Matrix4.copy(_transformationController.value)..invert();
    final positionInImage = MatrixUtils.transformPoint(invMatrix, localPosition);
    
    setState(() {
      _dragStart = positionInImage;
      final point = _pixelToGridPoint(positionInImage, slicing);
      if (point != null) {
        _selectionRect = GridRect(x: point.x, y: point.y, width: 1, height: 1);
      } else {
        _selectionRect = null;
      }
    });
    syncCommandContext();
  }

  void onSlicingGestureUpdate(Offset localPosition, SlicingConfig slicing) {
    if (_mode != TexturePackerMode.slicing || _dragStart == null) return;

    final invMatrix = Matrix4.copy(_transformationController.value)..invert();
    final positionInImage = MatrixUtils.transformPoint(invMatrix, localPosition);

    final startPoint = _pixelToGridPoint(_dragStart!, slicing);
    final endPoint = _pixelToGridPoint(positionInImage, slicing);

    if (startPoint == null || endPoint == null) return;
    
    final left = min(startPoint.x, endPoint.x);
    final top = min(startPoint.y, endPoint.y);
    final right = max(startPoint.x, endPoint.x);
    final bottom = max(startPoint.y, endPoint.y);
    
    setState(() {
      _selectionRect = GridRect(
        x: left, 
        y: top, 
        width: right - left + 1, 
        height: bottom - top + 1
      );
    });
  }

  Future<void> confirmSpriteSelection() async {
    if (_selectionRect == null) return;
    final rect = _selectionRect!;
    
    final activeImageId = ref.read(activeSourceImageIdProvider);
    if (activeImageId == null) {
      MachineToast.error("No source image selected.");
      return;
    }

    final bool isMulti = rect.width > 1 || rect.height > 1;

    if (!isMulti) {
      await _createSingleSprite(rect, activeImageId);
    } else {
      await _handleMultiSelection(rect, activeImageId);
    }
    cancelSpriteSelection();
  }

  Future<void> _createSingleSprite(GridRect rect, String activeImageId) async {
    final spriteName = await showTextInputDialog(context, title: 'Create New Sprite');
    if (spriteName != null && spriteName.trim().isNotEmpty) {
      String parentId = ref.read(selectedNodeIdProvider) ?? 'root';
      
      
      final newNode = _notifier.createNode(
        type: PackerItemType.sprite,
        name: spriteName.trim(),
        parentId: parentId, 
      );

      _notifier.updateSpriteDefinition(newNode.id, SpriteDefinition(
        sourceImageId: activeImageId,
        gridRect: rect,
      ));
      
      ref.read(selectedNodeIdProvider.notifier).state = newNode.id;
    }
  }

  Future<void> _handleMultiSelection(GridRect rect, String activeImageId) async {
    const optionAnim = 'Create Animation';
    const optionBatch = 'Batch Sprites';
    const optionSingle = 'Single Sprite (Merged)';

    final choice = await showDialog<String>(
      context: context,
      builder: (ctx) => SimpleDialog(
        title: const Text('Multi-Selection Action'),
        children: [
          SimpleDialogOption(
            onPressed: () => Navigator.pop(ctx, optionAnim),
            child: const ListTile(leading: Icon(Icons.movie), title: Text(optionAnim)),
          ),
          SimpleDialogOption(
            onPressed: () => Navigator.pop(ctx, optionBatch),
            child: const ListTile(leading: Icon(Icons.copy_all), title: Text(optionBatch)),
          ),
          SimpleDialogOption(
            onPressed: () => Navigator.pop(ctx, optionSingle),
            child: const ListTile(leading: Icon(Icons.crop_free), title: Text(optionSingle)),
          ),
        ],
      ),
    );

    if (choice == null) return;

    if (choice == optionSingle) {
      await _createSingleSprite(rect, activeImageId);
      return;
    }

    final baseName = await showTextInputDialog(context, title: 'Base Name');
    if (baseName == null || baseName.trim().isEmpty) return;
    
    final parentId = ref.read(selectedNodeIdProvider); 

    final definitions = <SpriteDefinition>[];
    final names = <String>[];
    
    int counter = 0;
    for (int y = 0; y < rect.height; y++) {
      for (int x = 0; x < rect.width; x++) {
        final tileRect = GridRect(x: rect.x + x, y: rect.y + y, width: 1, height: 1);
        definitions.add(SpriteDefinition(
          sourceImageId: activeImageId, 
          gridRect: tileRect,
        ));
        names.add('${baseName.trim()}_$counter');
        counter++;
      }
    }

    if (choice == optionBatch) {
      _notifier.createBatchSprites(
        names: names,
        definitions: definitions,
        parentId: parentId,
      );
    } else if (choice == optionAnim) {
      final nodes = _notifier.createBatchSprites(
        names: names,
        definitions: definitions,
        parentId: parentId, 
      );
      
      final settings = ref.read(effectiveSettingsProvider
        .select((s) => s.pluginSettings[TexturePackerSettings] as TexturePackerSettings?));
      
      _notifier.createAnimationFromExistingSprites(
        name: baseName.trim(),
        frameNodeIds: nodes.map((n) => n.id).toList(),
        parentId: parentId,
        speed: settings?.defaultAnimationSpeed ?? 10.0,
      );
    }
  }

  void onSlicingGestureEnd() {
    if (_mode != TexturePackerMode.slicing) return;
  }
  

  Future<void> _promptAndAddSourceImages() async {
    final project = ref.read(appNotifierProvider).value?.currentProject;
    if (project == null) return;

    final result = await showDialog<TexturePackerImportResult>(
      context: context,
      builder: (_) => TexturePackerFilePickerDialog(projectRootUri: project.rootUri),
    );

    if (result == null || result.files.isEmpty) return;

    final repo = ref.read(projectRepositoryProvider)!;
    final outputParentId = ref.read(selectedNodeIdProvider); 

    final tpackerFileMetadata = ref.read(tabMetadataProvider)[widget.tab.id]!;
    final tpackerProjectRelativePath = repo.fileHandler.getPathForDisplay(
      tpackerFileMetadata.file.uri, 
      relativeTo: project.rootUri
    );
    final tpackerDirectory = p.dirname(tpackerProjectRelativePath);

    String mode = 'batch'; 
    String? baseName;
    
    if (result.asSprites && result.files.length > 1) {
      final choice = await showDialog<String>(
        context: context,
        builder: (ctx) => SimpleDialog(
          title: const Text('Import Mode'),
          children: [
            SimpleDialogOption(
                onPressed: () => Navigator.pop(ctx, 'batch'),
                child: const Text('Batch Sprites'),
            ),
            SimpleDialogOption(
                onPressed: () => Navigator.pop(ctx, 'anim'),
                child: const Text('Animation'),
            ),
          ],
        ),
      );
      if (choice == null) return; 
      mode = choice;
      if (mode == 'anim') {
        baseName = await showTextInputDialog(context, title: 'Animation Name');
        if (baseName == null || baseName.trim().isEmpty) return;
      }
    }

    final List<String> createdSpriteNodeIds = [];

    for (final file in result.files) {
      final imageProjectRelativePath = repo.fileHandler.getPathForDisplay(file.uri, relativeTo: project.rootUri);
      
      final pathRelativeToTpacker = p.relative(imageProjectRelativePath, from: tpackerDirectory).replaceAll(r'\', '/');

      SlicingConfig config = const SlicingConfig();
      if (result.asSprites) {
        try {
          final assetData = await ref.read(assetDataProvider(imageProjectRelativePath).future);
          if (assetData is ImageAssetData) {
            config = SlicingConfig(tileWidth: assetData.image.width, tileHeight: assetData.image.height);
          }
        } catch (_) {}
      }

      final sourceNode = _notifier.addSourceNode(
        name: p.basename(imageProjectRelativePath),
        type: SourceNodeType.image,
        content: SourceImageConfig(path: pathRelativeToTpacker, slicing: config),
        parentId: null,
      );

      if (result.asSprites) {
        final spriteName = p.basenameWithoutExtension(file.name);
        final spriteNode = _notifier.createNode(
          type: PackerItemType.sprite,
          name: spriteName,
          parentId: outputParentId,
        );
        _notifier.updateSpriteDefinition(spriteNode.id, SpriteDefinition(
          sourceImageId: sourceNode.id,
          gridRect: const GridRect(x: 0, y: 0, width: 1, height: 1),
        ));
        createdSpriteNodeIds.add(spriteNode.id);
      }
    }

    if (mode == 'anim' && baseName != null && createdSpriteNodeIds.isNotEmpty) {
       _notifier.createAnimationFromExistingSprites(
        name: baseName,
        frameNodeIds: createdSpriteNodeIds,
        parentId: outputParentId,
       );
    }
    
    _updateAndLoadAssetUris();
  }


  @override
  void syncCommandContext() {
    Widget? appBarOverride;

    if (_mode == TexturePackerMode.slicing) {
      appBarOverride = SlicingAppBar(
        onExit: () => setMode(TexturePackerMode.panZoom),
        onConfirm: confirmSpriteSelection,
        onCancel: cancelSpriteSelection,
        hasSelection: _selectionRect != null,
      );
    } else if (_mode == TexturePackerMode.preview) {
      appBarOverride = PreviewAppBar(
        tabId: widget.tab.id,
        onExit: () => setMode(TexturePackerMode.panZoom),
      );
    }

    ref.read(commandContextProvider(widget.tab.id).notifier).state =
        TexturePackerCommandContext(
      mode: _mode,
      isSourceImagesPanelVisible: _isSourceImagesPanelVisible,
      isHierarchyPanelVisible: _isHierarchyPanelVisible,
      hasSelection: _selectionRect != null,
      appBarOverride: appBarOverride,
    );
  }
  
  @override
  void undo() {}
  @override
  void redo() {}
  
  @override
  Future<EditorContent> getContent() async {
    final currentState = _notifier.project;
    const encoder = JsonEncoder.withIndent('  ');
    final jsonString = encoder.convert(currentState.toJson());
    return EditorContentString(jsonString);
  }

  @override
  void onSaveSuccess(String newHash) {}

  @override
  Future<TabHotStateDto?> serializeHotState() async => null;


  @override
  Widget build(BuildContext context) {
    ref.listen(selectedNodeIdProvider, (previous, next) {
      if (next != null) {
        final def = _notifier.project.definitions[next];
        if (def is SpriteDefinition) {
          ref.read(activeSourceImageIdProvider.notifier).state = def.sourceImageId;
        }
      }
    });

    return Stack(
      children: [
        _buildMainContent(),
        
        Positioned(
          top: 8,
          right: 8,
          child: Card(
            child: Padding(
              padding: const EdgeInsets.all(4.0),
              child: CommandToolbar(position: TexturePackerPlugin.textureFloatingToolbar),
            ),
          ),
        ),
        
        AnimatedPositioned(
          duration: const Duration(milliseconds: 250),
          curve: Curves.easeInOut,
          top: 0,
          bottom: 0,
          left: _isSourceImagesPanelVisible ? 0 : -251,
          width: 250,
          child: SourceImagesPanel(
            notifier: _notifier, 
            onAddImage: _promptAndAddSourceImages,
            onClose: toggleSourceImagesPanel,
          ),
        ),
        
        AnimatedPositioned(
          duration: const Duration(milliseconds: 250),
          curve: Curves.easeInOut,
          top: 0,
          bottom: 0,
          right: _isHierarchyPanelVisible ? 0 : -301,
          width: 300,
          child: HierarchyPanel(
            notifier: _notifier,
            onClose: toggleHierarchyPanel,
          ),
        ),
      ],
    );
  }
  
  Widget _buildMainContent() {
    if (_mode == TexturePackerMode.preview) {
      return PreviewView(tabId: widget.tab.id, notifier: _notifier);
    }
    
    if (_notifier.getAllSourceImages().isEmpty) {
        return _buildEmptyState();
    }

    final activeId = ref.watch(activeSourceImageIdProvider);
    if (activeId == null) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.touch_app, size: 64, color: Colors.grey),
            SizedBox(height: 16),
            Text('Select a source image from the panel to start slicing.'),
          ],
        ),
      );
    }

    final sourceConfig = _notifier.findSourceImageConfig(activeId);
    if (sourceConfig == null) {
      return const Center(child: Text('Source image not found.'));
    }
    
    return SlicingView(
      tabId: widget.tab.id,
      notifier: _notifier,
      transformationController: _transformationController,
      dragSelection: _selectionRect,
      isPanZoomMode: _mode == TexturePackerMode.panZoom,
      onGestureStart: (pos) => onSlicingGestureStart(pos, sourceConfig.slicing),
      onGestureUpdate: (pos) => onSlicingGestureUpdate(pos, sourceConfig.slicing),
      onGestureEnd: onSlicingGestureEnd,
    );
  }
  
  Widget _buildEmptyState() {
    final theme = Theme.of(context);
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.image_search, size: 80, color: theme.textTheme.bodySmall?.color),
          const SizedBox(height: 24),
          Text('Empty Texture Packer Project', style: theme.textTheme.headlineSmall),
          const SizedBox(height: 8),
          Text(
            'Add a source image to begin slicing sprites.',
            style: theme.textTheme.bodyMedium,
          ),
          const SizedBox(height: 24),
          FilledButton.icon(
            onPressed: _promptAndAddSourceImages,
            icon: const Icon(Icons.add_photo_alternate_outlined),
            label: const Text('Add First Source Image'),
          ),
        ],
      ),
    );
  }
}

// FILE: lib/editor/plugins/texture_packer/texture_packer_loader.dart

// FILE: lib/editor/plugins/texture_packer/texture_packer_loader.dart

import 'dart:convert';
import 'dart:ui' as ui;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/asset_cache/asset_models.dart';
import 'package:machine/asset_cache/asset_providers.dart';
import 'package:machine/data/file_handler/file_handler.dart';
import 'package:machine/data/repositories/project/project_repository.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_models.dart';
import 'package:machine/utils/texture_packer_algo.dart';
import 'package:machine/app/app_notifier.dart';
import 'package:machine/project/project_settings_notifier.dart';
import 'package:path/path.dart' as p;
import 'texture_packer_asset_resolver.dart';
import '../../../logs/logs_provider.dart';

class TexturePackerAssetLoader implements IDependentAssetLoader<TexturePackerAssetData> {
  @override
  bool canLoad(ProjectDocumentFile file) {
    return file.name.toLowerCase().endsWith('.tpacker');
  }

  @override
  Future<Set<String>> getDependencies(Ref ref, ProjectDocumentFile file, ProjectRepository repo) async {
    final content = await repo.readFile(file.uri);
    if (content.trim().isEmpty) return {};

    try {
      final projectRootUri = ref.read(currentProjectProvider)!.rootUri;
      // Get the project-relative path of the .tpacker file to use as a context.
      final tpackerPath = repo.fileHandler.getPathForDisplay(file.uri, relativeTo: projectRootUri);
      
      final json = jsonDecode(content);
      final project = TexturePackerProject.fromJson(json);
      
      final dependencies = <String>{};
      
      void collectPaths(SourceImageNode node) {
        if (node.type == SourceNodeType.image && node.content != null) {
          if (node.content!.path.isNotEmpty) {
            // Use the repository to resolve the path relative to the .tpacker file.
            final resolvedPath = repo.resolveRelativePath(tpackerPath, node.content!.path);
            dependencies.add(resolvedPath);
          }
        }
        for (final child in node.children) collectPaths(child);
      }
      collectPaths(project.sourceImagesRoot);
      
      return dependencies;
    } catch (e) {
      return {};
    }
  }

  @override
  Future<TexturePackerAssetData> load(Ref ref, ProjectDocumentFile file, ProjectRepository repo) async {
    final content = await repo.readFile(file.uri);
    final project = TexturePackerProject.fromJson(jsonDecode(content));
    
    final projectRootUri = ref.read(currentProjectProvider)!.rootUri;
    // Get the project-relative path of the .tpacker file to use as a context.
    final tpackerPath = repo.fileHandler.getPathForDisplay(file.uri, relativeTo: projectRootUri);

    final Map<String, ui.Image> sourceImages = {};
    
    final sourceNodes = <SourceImageNode>[];
    void collectNodes(SourceImageNode node) {
      if (node.type == SourceNodeType.image && node.content != null) {
        sourceNodes.add(node);
      }
      for (final child in node.children) collectNodes(child);
    }
    collectNodes(project.sourceImagesRoot);

    for (final node in sourceNodes) {
      final relativePath = node.content!.path;
      if (relativePath.isNotEmpty) {
        try {
          final resolvedPath = repo.resolveRelativePath(tpackerPath, relativePath);
          final assetData = await ref.read(assetDataProvider(resolvedPath).future);
          if (assetData is ImageAssetData) {
            sourceImages[node.id] = assetData.image;
          }
        } catch (e, st) {
          ref.read(talkerProvider).handle(e, st, 'TexturePackerLoader: Failed to load source image $relativePath');
        }
      }
    }
    
    final packerItems = <PackerInputItem<SpriteDefinition>>[];
    final spriteNames = <String, String>{}; 

    void collectSprites(PackerItemNode node) {
      if (node.type == PackerItemType.sprite) {
        final def = project.definitions[node.id];
        if (def is SpriteDefinition) {
          final sourceImage = sourceImages[def.sourceImageId];
          if (sourceImage != null) {
            final sourceConfig = _findSourceConfig(project.sourceImagesRoot, def.sourceImageId);
            if (sourceConfig != null) {
              final pxRect = _calculatePixelRect(sourceConfig, def.gridRect);
              
              packerItems.add(PackerInputItem(
                width: pxRect.width,
                height: pxRect.height,
                data: def, 
              ));
              spriteNames[node.id] = node.name;
            }
          }
        }
      } else {
        for(final child in node.children) collectSprites(child);
      }
    }
    collectSprites(project.tree);

    final packer = MaxRectsPacker(padding: 2);
    final result = packer.pack(packerItems);

    final frames = <String, TexturePackerSpriteData>{};
    final animations = <String, List<String>>{};

    for (final item in result.items) {
      final nodeId = project.definitions.entries
          .firstWhere((e) => e.value == item.data)
          .key;
          
      final name = spriteNames[nodeId] ?? 'unknown';
      final def = item.data as SpriteDefinition;
      final sourceImage = sourceImages[def.sourceImageId]!;
      final sourceConfig = _findSourceConfig(project.sourceImagesRoot, def.sourceImageId)!;
      final sourceRect = _calculatePixelRect(sourceConfig, def.gridRect);

      frames[name] = TexturePackerSpriteData(
        name: name,
        sourceImage: sourceImage,
        sourceRect: sourceRect,
        packedRect: ui.Rect.fromLTWH(item.x, item.y, item.width, item.height),
      );
    }

    void collectAnimations(PackerItemNode node) {
      if (node.type == PackerItemType.animation) {
        final frameNames = node.children
            .where((c) => c.type == PackerItemType.sprite)
            .map((c) => c.name)
            .toList();
        
        if (frameNames.isNotEmpty) {
          animations[node.name] = frameNames;
        }
      }
      for(final child in node.children) collectAnimations(child);
    }
    collectAnimations(project.tree);

    return TexturePackerAssetData(
      frames: frames,
      animations: animations,
      metaSize: ui.Size(result.width, result.height),
    );
  }
  
  SourceImageConfig? _findSourceConfig(SourceImageNode node, String id) {
    if (node.id == id && node.type == SourceNodeType.image) return node.content;
    for (final child in node.children) {
      final res = _findSourceConfig(child, id);
      if (res != null) return res;
    }
    return null;
  }

  ui.Rect _calculatePixelRect(SourceImageConfig config, GridRect grid) {
    final s = config.slicing;
    final left = s.margin + grid.x * (s.tileWidth + s.padding);
    final top = s.margin + grid.y * (s.tileHeight + s.padding);
    final width = grid.width * s.tileWidth + (grid.width - 1) * s.padding;
    final height = grid.height * s.tileHeight + (grid.height - 1) * s.padding;
    return ui.Rect.fromLTWH(left.toDouble(), top.toDouble(), width.toDouble(), height.toDouble());
  }
}

// FILE: lib/editor/plugins/texture_packer/texture_packer_models.dart

import 'package:flutter/foundation.dart';
import 'package:collection/collection.dart';
import 'package:uuid/uuid.dart';

enum PackerItemType { folder, sprite, animation }

/// Enum defining types for source images (grouping vs actual file).
enum SourceNodeType { folder, image }


@immutable
class SlicingConfig {
  final int tileWidth;
  final int tileHeight;
  final int margin;
  final int padding;

  const SlicingConfig({
    this.tileWidth = 16,
    this.tileHeight = 16,
    this.margin = 0,
    this.padding = 0,
  });

  factory SlicingConfig.fromJson(Map<String, dynamic> json) {
    return SlicingConfig(
      tileWidth: json['tileWidth'] ?? 16,
      tileHeight: json['tileHeight'] ?? 16,
      margin: json['margin'] ?? 0,
      padding: json['padding'] ?? 0,
    );
  }

  Map<String, dynamic> toJson() => {
        'tileWidth': tileWidth,
        'tileHeight': tileHeight,
        'margin': margin,
        'padding': padding,
      };

  SlicingConfig copyWith({
    int? tileWidth,
    int? tileHeight,
    int? margin,
    int? padding,
  }) {
    return SlicingConfig(
      tileWidth: tileWidth ?? this.tileWidth,
      tileHeight: tileHeight ?? this.tileHeight,
      margin: margin ?? this.margin,
      padding: padding ?? this.padding,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SlicingConfig &&
          runtimeType == other.runtimeType &&
          tileWidth == other.tileWidth &&
          tileHeight == other.tileHeight &&
          margin == other.margin &&
          padding == other.padding;

  @override
  int get hashCode => Object.hash(tileWidth, tileHeight, margin, padding);
}

@immutable
class SourceImageConfig {
  final String path;
  final SlicingConfig slicing;

  const SourceImageConfig({
    required this.path,
    this.slicing = const SlicingConfig(),
  });

  factory SourceImageConfig.fromJson(Map<String, dynamic> json) {
    return SourceImageConfig(
      path: json['path'],
      slicing: SlicingConfig.fromJson(json['slicing'] ?? {}),
    );
  }

  Map<String, dynamic> toJson() => {
        'path': path,
        'slicing': slicing.toJson(),
      };

  SourceImageConfig copyWith({String? path, SlicingConfig? slicing}) {
    return SourceImageConfig(
      path: path ?? this.path,
      slicing: slicing ?? this.slicing,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SourceImageConfig &&
          runtimeType == other.runtimeType &&
          path == other.path &&
          slicing == other.slicing;

  @override
  int get hashCode => Object.hash(path, slicing);
}

@immutable
class SourceImageNode {
  final String id;
  final String name;
  final SourceNodeType type;
  final List<SourceImageNode> children;
  
  final SourceImageConfig? content;

  SourceImageNode({
    String? id,
    required this.name,
    required this.type,
    this.children = const [],
    this.content,
  }) : id = id ?? const Uuid().v4();

  factory SourceImageNode.fromJson(Map<String, dynamic> json) {
    return SourceImageNode(
      id: json['id'],
      name: json['name'],
      type: SourceNodeType.values.byName(json['type']),
      children: (json['children'] as List? ?? [])
          .map((childJson) => SourceImageNode.fromJson(childJson))
          .toList(),
      content: json['content'] != null 
          ? SourceImageConfig.fromJson(json['content']) 
          : null,
    );
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'type': type.name,
        'children': children.map((child) => child.toJson()).toList(),
        if (content != null) 'content': content!.toJson(),
      };

  SourceImageNode copyWith({
    String? name,
    SourceNodeType? type,
    List<SourceImageNode>? children,
    SourceImageConfig? content,
  }) {
    return SourceImageNode(
      id: id,
      name: name ?? this.name,
      type: type ?? this.type,
      children: children ?? this.children,
      content: content ?? this.content,
    );
  }
}



@immutable
class GridRect {
  final int x;
  final int y;
  final int width;
  final int height;

  const GridRect({
    required this.x,
    required this.y,
    this.width = 1,
    this.height = 1,
  });

  factory GridRect.fromJson(Map<String, dynamic> json) => GridRect(
        x: json['x'],
        y: json['y'],
        width: json['width'] ?? 1,
        height: json['height'] ?? 1,
      );

  Map<String, dynamic> toJson() => {
        'x': x,
        'y': y,
        'width': width,
        'height': height,
      };
}

@immutable
abstract class PackerItemDefinition {
  const PackerItemDefinition();
  
  Map<String, dynamic> toJson();

  static PackerItemDefinition? fromJson(PackerItemType type, Map<String, dynamic>? json) {
    if (json == null) return null;
    switch (type) {
      case PackerItemType.sprite:
        return SpriteDefinition.fromJson(json);
      case PackerItemType.animation:
        return AnimationDefinition.fromJson(json);
      case PackerItemType.folder:
      default:
        return null;
    }
  }
}

class SpriteDefinition extends PackerItemDefinition {
  final String sourceImageId; 
  final GridRect gridRect;

  const SpriteDefinition({
    required this.sourceImageId,
    required this.gridRect,
  });

  factory SpriteDefinition.fromJson(Map<String, dynamic> json) {
    return SpriteDefinition(
      sourceImageId: json['sourceImageId'] ?? '',
      gridRect: GridRect.fromJson(json['gridRect']),
    );
  }

  @override
  Map<String, dynamic> toJson() => {
        'sourceImageId': sourceImageId,
        'gridRect': gridRect.toJson(),
      };
}

class AnimationDefinition extends PackerItemDefinition {
  final double speed;

  const AnimationDefinition({
    this.speed = 10.0,
  });

  factory AnimationDefinition.fromJson(Map<String, dynamic> json) {
    return AnimationDefinition(
      speed: json['speed']?.toDouble() ?? 10.0,
    );
  }

  @override
  Map<String, dynamic> toJson() => {
        'speed': speed,
      };
}



@immutable
class PackerItemNode {
  final String id;
  final String name;
  final PackerItemType type;
  final List<PackerItemNode> children;

  PackerItemNode({
    String? id,
    required this.name,
    required this.type,
    this.children = const [],
  }) : id = id ?? const Uuid().v4();

  factory PackerItemNode.fromJson(Map<String, dynamic> json) {
    return PackerItemNode(
      id: json['id'],
      name: json['name'],
      type: PackerItemType.values.byName(json['type']),
      children: (json['children'] as List? ?? [])
          .map((childJson) => PackerItemNode.fromJson(childJson))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'type': type.name,
        'children': children.map((child) => child.toJson()).toList(),
      };

  PackerItemNode copyWith({
    String? name,
    PackerItemType? type,
    List<PackerItemNode>? children,
  }) {
    return PackerItemNode(
      id: id,
      name: name ?? this.name,
      type: type ?? this.type,
      children: children ?? this.children,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PackerItemNode &&
          runtimeType == other.runtimeType &&
          id == other.id;

  @override
  int get hashCode => id.hashCode;
}

/// The root data model for a `.tpacker` file.
@immutable
class TexturePackerProject {
  final SourceImageNode sourceImagesRoot;
  
  final PackerItemNode tree;
  
  final Map<String, PackerItemDefinition> definitions;

  const TexturePackerProject({
    required this.sourceImagesRoot,
    required this.tree,
    this.definitions = const {},
  });
  
  factory TexturePackerProject.fresh() {
    return TexturePackerProject(
      sourceImagesRoot: SourceImageNode(name: 'root', type: SourceNodeType.folder, id: 'root'),
      tree: PackerItemNode(name: 'root', type: PackerItemType.folder, id: 'root'),
    );
  }

  factory TexturePackerProject.fromJson(Map<String, dynamic> json) {
    final tree = PackerItemNode.fromJson(json['tree']);
    
    SourceImageNode sourceRoot;
    if (json['sourceImagesRoot'] != null) {
      sourceRoot = SourceImageNode.fromJson(json['sourceImagesRoot']);
    } else {
      sourceRoot = SourceImageNode(name: 'root', type: SourceNodeType.folder, id: 'root');
    }

    final Map<String, PackerItemDefinition> defs = {};
    if (json['definitions'] != null) {
      final Map<String, dynamic> rawDefs = json['definitions'];
      
      PackerItemType? findType(String id) {
        PackerItemNode? find(PackerItemNode node) {
          if (node.id == id) return node;
          for (final child in node.children) {
            final found = find(child);
            if (found != null) return found;
          }
          return null;
        }
        return find(tree)?.type;
      }
      
      rawDefs.forEach((id, defJson) {
        final type = findType(id);
        if (type != null) {
          final def = PackerItemDefinition.fromJson(type, defJson);
          if (def != null) {
            defs[id] = def;
          }
        }
      });
    }

    return TexturePackerProject(
      sourceImagesRoot: sourceRoot,
      tree: tree,
      definitions: defs,
    );
  }

  Map<String, dynamic> toJson() => {
        'sourceImagesRoot': sourceImagesRoot.toJson(),
        'tree': tree.toJson(),
        'definitions': definitions.map((key, value) => MapEntry(key, value.toJson())),
      };
      
  TexturePackerProject copyWith({
    SourceImageNode? sourceImagesRoot,
    PackerItemNode? tree,
    Map<String, PackerItemDefinition>? definitions,
  }) {
    return TexturePackerProject(
      sourceImagesRoot: sourceImagesRoot ?? this.sourceImagesRoot,
      tree: tree ?? this.tree,
      definitions: definitions ?? this.definitions,
    );
  }
}

// FILE: lib/editor/plugins/texture_packer/texture_packer_notifier.dart


import 'package:flutter/foundation.dart';
import 'package:collection/collection.dart';
import 'package:uuid/uuid.dart';
import 'texture_packer_models.dart';

class TexturePackerNotifier extends ChangeNotifier {
  TexturePackerProject project;

  TexturePackerNotifier(this.project);


  String _resolveValidPackerParent(String? targetId) {
    if (targetId == null || targetId == 'root') return 'root';

    PackerItemNode? targetNode;
    PackerItemNode? findNode(PackerItemNode current) {
      if (current.id == targetId) return current;
      for (final child in current.children) {
        final res = findNode(child);
        if (res != null) return res;
      }
      return null;
    }
    targetNode = findNode(project.tree);

    if (targetNode == null) return 'root';

    if (targetNode.type == PackerItemType.folder || targetNode.type == PackerItemType.animation) {
      return targetNode.id;
    }

    String? findParent(PackerItemNode current, String childId) {
      for (final child in current.children) {
        if (child.id == childId) return current.id;
        final res = findParent(child, childId);
        if (res != null) return res;
      }
      return null;
    }

    return findParent(project.tree, targetId) ?? 'root';
  }

  String _resolveValidSourceParent(String? targetId) {
    if (targetId == null || targetId == 'root') return 'root';

    SourceImageNode? targetNode;
    SourceImageNode? findNode(SourceImageNode current) {
      if (current.id == targetId) return current;
      for (final child in current.children) {
        final res = findNode(child);
        if (res != null) return res;
      }
      return null;
    }
    targetNode = findNode(project.sourceImagesRoot);

    if (targetNode == null) return 'root';

    if (targetNode.type == SourceNodeType.folder) {
      return targetNode.id;
    }

    String? findParent(SourceImageNode current, String childId) {
      for (final child in current.children) {
        if (child.id == childId) return current.id;
        final res = findParent(child, childId);
        if (res != null) return res;
      }
      return null;
    }

    return findParent(project.sourceImagesRoot, targetId) ?? 'root';
  }


  SourceImageNode? _findSourceNode(String id) {
    SourceImageNode? find(SourceImageNode node) {
      if (node.id == id) return node;
      for (final child in node.children) {
        final found = find(child);
        if (found != null) return found;
      }
      return null;
    }
    return find(project.sourceImagesRoot);
  }
  
  SourceImageConfig? findSourceImageConfig(String id) {
    SourceImageConfig? traverse(SourceImageNode node) {
      if (node.id == id && node.type == SourceNodeType.image) return node.content;
      for (final child in node.children) {
        final result = traverse(child);
        if (result != null) return result;
      }
      return null;
    }
    return traverse(project.sourceImagesRoot);
  }

  SourceImageNode addSourceNode({
    required String name,
    required SourceNodeType type,
    String? parentId,
    SourceImageConfig? content, 
  }) {
    final newNode = SourceImageNode(name: name, type: type, content: content);

    final validParentId = _resolveValidSourceParent(parentId);

    SourceImageNode insert(SourceImageNode currentNode) {
      if (currentNode.id == validParentId) {
        return currentNode.copyWith(children: [...currentNode.children, newNode]);
      }
      return currentNode.copyWith(
        children: currentNode.children.map(insert).toList(),
      );
    }

    project = project.copyWith(
      sourceImagesRoot: insert(project.sourceImagesRoot),
    );
    notifyListeners();
    return newNode;
  }

  void removeSourceNode(String nodeId) {
    if (nodeId == 'root') return;

    SourceImageNode removeRecursive(SourceImageNode current) {
      final newChildren = current.children
          .where((child) => child.id != nodeId)
          .map(removeRecursive)
          .toList();
      return current.copyWith(children: newChildren);
    }

    project = project.copyWith(
      sourceImagesRoot: removeRecursive(project.sourceImagesRoot),
    );
    notifyListeners();
  }
  
  void moveSourceNode(String nodeId, String newParentId, int newIndex) {
    if (nodeId == newParentId) return; 
    if (nodeId == 'root') return;

    final validParentId = _resolveValidSourceParent(newParentId);
    
    if (_isSourceDescendant(nodeId, validParentId)) return;

    final result = _extractSourceNode(project.sourceImagesRoot, nodeId);
    final newRootWithoutNode = result.newRoot;
    final movedNode = result.extractedNode;

    if (movedNode == null) return; 

    if (!_sourceNodeExists(newRootWithoutNode, validParentId)) return;

    final finalRoot = _insertSourceNode(newRootWithoutNode, validParentId, newIndex, movedNode);

    project = project.copyWith(sourceImagesRoot: finalRoot);
    notifyListeners();
  }


  bool _isSourceDescendant(String ancestorId, String targetId) {
    final ancestor = _findSourceNode(ancestorId);
    if (ancestor == null) return false;
    bool contains(SourceImageNode node) {
      if (node.id == targetId) return true;
      return node.children.any(contains);
    }
    return ancestor.children.any(contains);
  }

  bool _sourceNodeExists(SourceImageNode root, String id) {
    if (root.id == id) return true;
    for (final child in root.children) {
      if (_sourceNodeExists(child, id)) return true;
    }
    return false;
  }

  ({SourceImageNode newRoot, SourceImageNode? extractedNode}) _extractSourceNode(SourceImageNode root, String idToExtract) {
    SourceImageNode? foundNode;
    SourceImageNode traverse(SourceImageNode current) {
      final index = current.children.indexWhere((c) => c.id == idToExtract);
      if (index != -1) {
        foundNode = current.children[index];
        final newChildren = List<SourceImageNode>.from(current.children)..removeAt(index);
        return current.copyWith(children: newChildren);
      }
      final newChildren = current.children.map(traverse).toList();
      return current.copyWith(children: newChildren);
    }
    final newRoot = traverse(root);
    return (newRoot: newRoot, extractedNode: foundNode);
  }

  SourceImageNode _insertSourceNode(SourceImageNode root, String parentId, int index, SourceImageNode nodeToInsert) {
    if (root.id == parentId) {
      final safeIndex = index.clamp(0, root.children.length);
      final newChildren = List<SourceImageNode>.from(root.children)..insert(safeIndex, nodeToInsert);
      return root.copyWith(children: newChildren);
    }
    final newChildren = root.children.map((child) => _insertSourceNode(child, parentId, index, nodeToInsert)).toList();
    return root.copyWith(children: newChildren);
  }

  void updateSlicingConfig(String nodeId, SlicingConfig newConfig) {
    SourceImageNode update(SourceImageNode current) {
      if (current.id == nodeId && current.type == SourceNodeType.image && current.content != null) {
        return current.copyWith(content: current.content!.copyWith(slicing: newConfig));
      }
      return current.copyWith(children: current.children.map(update).toList());
    }
    project = project.copyWith(sourceImagesRoot: update(project.sourceImagesRoot));
    notifyListeners();
  }


  void renameNode(String nodeId, String newName) {
    if (nodeId == 'root') return;
    PackerItemNode renameRecursive(PackerItemNode currentNode) {
      if (currentNode.id == nodeId) {
        return currentNode.copyWith(name: newName);
      }
      return currentNode.copyWith(children: currentNode.children.map(renameRecursive).toList());
    }
    project = project.copyWith(tree: renameRecursive(project.tree));
    notifyListeners();
  }

  PackerItemNode createNode({
    required PackerItemType type,
    required String name,
    String? parentId,
  }) {
    final newNode = PackerItemNode(name: name, type: type);
    
    final validParentId = _resolveValidPackerParent(parentId);

    final parentExists = _packerNodeExists(project.tree, validParentId);
    final safeParentId = parentExists ? validParentId : 'root';

    PackerItemNode insert(PackerItemNode currentNode) {
      if (currentNode.id == safeParentId) {
        return currentNode.copyWith(children: [...currentNode.children, newNode]);
      }
      return currentNode.copyWith(children: currentNode.children.map(insert).toList());
    }
    
    project = project.copyWith(tree: insert(project.tree));
    notifyListeners();
    return newNode;
  }
  
  void updateSpriteDefinition(String nodeId, SpriteDefinition definition) {
      final newDefinitions = Map<String, PackerItemDefinition>.from(project.definitions);
      newDefinitions[nodeId] = definition;
      project = project.copyWith(definitions: newDefinitions);
      notifyListeners();
  }

  void updateAnimationDefinition(String nodeId, AnimationDefinition definition) {
      final newDefinitions = Map<String, PackerItemDefinition>.from(project.definitions);
      newDefinitions[nodeId] = definition;
      project = project.copyWith(definitions: newDefinitions);
      notifyListeners();
  }

  void deleteNode(String nodeId) {
    if (nodeId == 'root') return;
    final newDefinitions = Map<String, PackerItemDefinition>.from(project.definitions);
    final List<String> idsToDelete = [];

    PackerItemNode? filter(PackerItemNode currentNode) {
      if (currentNode.id == nodeId) {
        void collectIds(PackerItemNode node) {
          idsToDelete.add(node.id);
          for (final child in node.children) collectIds(child);
        }
        collectIds(currentNode);
        return null;
      }
      final newChildren = currentNode.children.map(filter).whereType<PackerItemNode>().toList();
      return currentNode.copyWith(children: newChildren);
    }

    final newTree = filter(project.tree);
    for (final id in idsToDelete) newDefinitions.remove(id);
    
    project = project.copyWith(tree: newTree, definitions: newDefinitions);
    notifyListeners();
  }
  
  List<PackerItemNode> createBatchSprites({
    required List<String> names,
    required List<SpriteDefinition> definitions,
    String? parentId,
  }) {
    if (names.length != definitions.length) return [];

    final List<PackerItemNode> newNodes = [];
    final newDefinitions = Map<String, PackerItemDefinition>.from(project.definitions);

    for (int i = 0; i < names.length; i++) {
      final node = PackerItemNode(name: names[i], type: PackerItemType.sprite);
      newNodes.add(node);
      newDefinitions[node.id] = definitions[i];
    }

    final validParentId = _resolveValidPackerParent(parentId);
    final safeParentId = _packerNodeExists(project.tree, validParentId) ? validParentId : 'root';

    PackerItemNode insert(PackerItemNode currentNode) {
      if (currentNode.id == safeParentId) {
        return currentNode.copyWith(children: [...currentNode.children, ...newNodes]);
      }
      return currentNode.copyWith(children: currentNode.children.map(insert).toList());
    }

    project = project.copyWith(tree: insert(project.tree), definitions: newDefinitions);
    notifyListeners();
    return newNodes;
  }

  void createAnimationFromExistingSprites({
    required String name,
    required List<String> frameNodeIds,
    String? parentId,
    double speed = 10.0,
  }) {
    final animNode = PackerItemNode(name: name, type: PackerItemType.animation);
    final animDef = AnimationDefinition(speed: speed);

    final newDefinitions = Map<String, PackerItemDefinition>.from(project.definitions);
    newDefinitions[animNode.id] = animDef;

    final List<PackerItemNode> framesToMove = [];
    
    PackerItemNode removeFramesRecursive(PackerItemNode current) {
      final keptChildren = <PackerItemNode>[];
      for (final child in current.children) {
        if (frameNodeIds.contains(child.id)) {
          framesToMove.add(child); 
        } else {
          keptChildren.add(removeFramesRecursive(child));
        }
      }
      return current.copyWith(children: keptChildren);
    }

    final treeAfterRemoval = removeFramesRecursive(project.tree);
    framesToMove.sort((a, b) => frameNodeIds.indexOf(a.id).compareTo(frameNodeIds.indexOf(b.id)));
    final populatedAnimNode = animNode.copyWith(children: framesToMove);

    final validParentId = _resolveValidPackerParent(parentId);
    final safeParentId = _packerNodeExists(treeAfterRemoval, validParentId) ? validParentId : 'root';

    PackerItemNode insertRecursive(PackerItemNode current) {
      if (current.id == safeParentId) {
        return current.copyWith(children: [...current.children, populatedAnimNode]);
      }
      return current.copyWith(children: current.children.map(insertRecursive).toList());
    }

    project = project.copyWith(tree: insertRecursive(treeAfterRemoval), definitions: newDefinitions);
    notifyListeners();
  }

  void moveNode(String nodeId, String newParentId, int newIndex) {
    if (nodeId == newParentId) return;
    if (nodeId == 'root') return;
    
    final validParentId = _resolveValidPackerParent(newParentId);

    if (_isPackerDescendant(nodeId, validParentId)) return;

    final result = _extractPackerNode(project.tree, nodeId);
    final newTreeWithoutNode = result.newRoot;
    final movedNode = result.extractedNode;

    if (movedNode == null) return;

    if (!_packerNodeExists(newTreeWithoutNode, validParentId)) return;

    final finalTree = _insertPackerNode(newTreeWithoutNode, validParentId, newIndex, movedNode);

    project = project.copyWith(tree: finalTree);
    notifyListeners();
  }


  bool _packerNodeExists(PackerItemNode root, String id) {
    if (root.id == id) return true;
    for (final child in root.children) {
      if (_packerNodeExists(child, id)) return true;
    }
    return false;
  }

  bool _isPackerDescendant(String ancestorId, String targetId) {
    PackerItemNode? find(PackerItemNode node) {
      if (node.id == ancestorId) return node;
      for (final child in node.children) {
        final res = find(child);
        if (res != null) return res;
      }
      return null;
    }
    final ancestor = find(project.tree);
    if (ancestor == null) return false;

    bool contains(PackerItemNode node) {
      if (node.id == targetId) return true;
      return node.children.any(contains);
    }
    return ancestor.children.any(contains);
  }

  ({PackerItemNode newRoot, PackerItemNode? extractedNode}) _extractPackerNode(PackerItemNode root, String idToExtract) {
    PackerItemNode? foundNode;
    PackerItemNode traverse(PackerItemNode current) {
      final index = current.children.indexWhere((c) => c.id == idToExtract);
      if (index != -1) {
        foundNode = current.children[index];
        final newChildren = List<PackerItemNode>.from(current.children)..removeAt(index);
        return current.copyWith(children: newChildren);
      }
      final newChildren = current.children.map(traverse).toList();
      return current.copyWith(children: newChildren);
    }
    final newRoot = traverse(root);
    return (newRoot: newRoot, extractedNode: foundNode);
  }

  PackerItemNode _insertPackerNode(PackerItemNode root, String parentId, int index, PackerItemNode nodeToInsert) {
    if (root.id == parentId) {
      final safeIndex = index.clamp(0, root.children.length);
      final newChildren = List<PackerItemNode>.from(root.children)..insert(safeIndex, nodeToInsert);
      return root.copyWith(children: newChildren);
    }
    final newChildren = root.children.map((child) => _insertPackerNode(child, parentId, index, nodeToInsert)).toList();
    return root.copyWith(children: newChildren);
  }
  
  List<SourceImageNode> getAllSourceImages() {
    final List<SourceImageNode> images = [];
    void traverse(SourceImageNode node) {
      if (node.type == SourceNodeType.image) images.add(node);
      for (final child in node.children) traverse(child);
    }
    traverse(project.sourceImagesRoot);
    return images;
  }
}

// FILE: lib/editor/plugins/texture_packer/texture_packer_plugin.dart

import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/app/app_notifier.dart';
import 'package:machine/command/command_models.dart';
import 'package:machine/data/file_handler/file_handler.dart';
import 'package:machine/data/cache/type_adapters.dart';
import 'package:machine/editor/models/editor_command_context.dart';
import 'package:machine/asset_cache/asset_models.dart';
import 'package:machine/editor/models/editor_plugin_models.dart';
import 'package:machine/editor/models/editor_tab_models.dart';
import 'package:machine/editor/services/editor_service.dart';
import 'package:machine/editor/tab_metadata_notifier.dart';
import 'texture_packer_command_context.dart';
import 'texture_packer_editor_models.dart';
import 'texture_packer_editor_widget.dart';
import 'texture_packer_models.dart';
import 'widgets/slicing_properties_dialog.dart';
import '../../../command/command_widgets.dart';
import 'widgets/texture_packer_settings_widget.dart';
import 'texture_packer_settings.dart';
import 'texture_packer_loader.dart';
import 'widgets/texture_packer_export_dialog.dart';

class TexturePackerPlugin extends EditorPlugin {
  static const textureFloatingToolbar = CommandPosition(
    id: 'com.machine.texture_packer.floating_toolbar',
    label: 'Texture Packer Floating Toolbar',
    icon: Icons.grid_on_outlined,
  );
  
  @override
  String get id => 'com.machine.texture_packer';

  @override
  String get name => 'Texture Packer';

  @override
  Widget get icon => const Icon(Icons.grid_view);

  @override
  int get priority => 5;

  @override
  bool supportsFile(DocumentFile file) {
    return file.name.toLowerCase().endsWith('.tpacker');
  }

  @override
  List<AssetLoader> get assetLoaders => [
    TexturePackerAssetLoader(),
  ];

  @override
  PluginSettings? get settings => TexturePackerSettings();

  @override
  Widget buildSettingsUI(
    PluginSettings settings,
    void Function(PluginSettings) onChanged,
  ) {
    if (settings is! TexturePackerSettings) return const SizedBox.shrink();
    return TexturePackerSettingsWidget(
      settings: settings,
      onChanged: (newSettings) => onChanged(newSettings),
    );
  }
  
  @override
  Future<EditorTab> createTab(
    DocumentFile file,
    EditorInitData initData, {
    String? id,
    Completer<EditorWidgetState>? onReadyCompleter,
  }) async {
    final content = (initData.initialContent as EditorContentString).content;
    
    final TexturePackerProject projectState;
    if (content.trim().isEmpty) {
      projectState = TexturePackerProject.fresh();
    } else {
      projectState = TexturePackerProject.fromJson(jsonDecode(content));
    }

    return TexturePackerTab(
      plugin: this,
      initialProjectState: projectState,
      id: id,
      onReadyCompleter: onReadyCompleter,
    );
  }

  @override
  EditorWidget buildEditor(EditorTab tab, WidgetRef ref) {
    return TexturePackerEditorWidget(
      key: (tab as TexturePackerTab).editorKey,
      tab: tab,
    );
  }
  
  @override
  Widget buildToolbar(WidgetRef ref) {
    return const BottomToolbar();
  }
  
  TexturePackerEditorWidgetState? _getEditorState(WidgetRef ref) {
    final tab =
        ref.read(appNotifierProvider).value?.currentProject?.session.currentTab;
    if (tab is TexturePackerTab) {
      return tab.editorKey.currentState as TexturePackerEditorWidgetState?;
    }
    return null;
  }
  
  @override
  List<CommandPosition> getCommandPositions() => [
    textureFloatingToolbar
  ];

  @override
  List<Command> getCommands() {
    return [
      BaseCommand(
        id: 'packer_save',
        label: 'Save Atlas',
        icon: const Icon(Icons.save),
        defaultPositions: [AppCommandPositions.appBar],
        sourcePlugin: id,
        execute: (ref) async => ref.read(editorServiceProvider).saveCurrentTab(),
        canExecute: (ref) {
          final tabId = ref.watch(appNotifierProvider.select((s) => s.value?.currentProject?.session.currentTab?.id));
          if (tabId == null) return false;
          return ref.watch(tabMetadataProvider.select((m) => m[tabId]))?.isDirty ?? false;
        },
      ),
      BaseCommand(
        id: 'packer_save_as',
        label: 'Save As...',
        icon: const Icon(Icons.save_as),
        defaultPositions: [AppCommandPositions.appBar],
        sourcePlugin: id,
        execute: (ref) async => ref.read(editorServiceProvider).saveCurrentTabAs(),
      ),
      BaseCommand(
        id: 'packer_toggle_pan_zoom_mode',
        label: 'Pan/Zoom',
        icon: Consumer(builder: (context, ref, _) {
          final ctx = ref.watch(activeCommandContextProvider);
          final isActive = ctx is TexturePackerCommandContext && ctx.mode == TexturePackerMode.panZoom;
          return Icon(Icons.pan_tool_outlined, color: isActive ? Theme.of(context).colorScheme.primary : null);
        }),
        defaultPositions: [textureFloatingToolbar],
        sourcePlugin: id,
        execute: (ref) async => _getEditorState(ref)?.setMode(TexturePackerMode.panZoom),
      ),
      BaseCommand(
        id: 'packer_toggle_slicing_mode',
        label: 'Slice & Select',
        icon: Consumer(builder: (context, ref, _) {
          final ctx = ref.watch(activeCommandContextProvider);
          final isActive = ctx is TexturePackerCommandContext && ctx.mode == TexturePackerMode.slicing;
          return Icon(Icons.select_all_outlined, color: isActive ? Theme.of(context).colorScheme.primary : null);
        }),
        defaultPositions: [textureFloatingToolbar],
        sourcePlugin: id,
        execute: (ref) async => _getEditorState(ref)?.setMode(TexturePackerMode.slicing),
      ),
      BaseCommand(
        id: 'packer_toggle_preview_mode',
        label: 'Preview',
        icon: Consumer(builder: (context, ref, _) {
          final ctx = ref.watch(activeCommandContextProvider);
          final isActive = ctx is TexturePackerCommandContext && ctx.mode == TexturePackerMode.preview;
          return Icon(Icons.play_circle_outline, color: isActive ? Theme.of(context).colorScheme.primary : null);
        }),
        defaultPositions: [textureFloatingToolbar],
        sourcePlugin: id,
        execute: (ref) async => _getEditorState(ref)?.setMode(TexturePackerMode.preview),
      ),
      
      BaseCommand(
        id: 'packer_toggle_sources_panel',
        label: 'Source Images',
        icon: Consumer(builder: (context, ref, _) {
          final ctx = ref.watch(activeCommandContextProvider);
          final isActive = ctx is TexturePackerCommandContext && ctx.isSourceImagesPanelVisible;
          return Icon(Icons.photo_library_outlined, color: isActive ? Theme.of(context).colorScheme.primary : null);
        }),
        defaultPositions: [AppCommandPositions.pluginToolbar],
        sourcePlugin: id,
        execute: (ref) async => _getEditorState(ref)?.toggleSourceImagesPanel(),
      ),
      BaseCommand(
        id: 'packer_toggle_hierarchy_panel',
        label: 'Hierarchy',
        icon: Consumer(builder: (context, ref, _) {
          final ctx = ref.watch(activeCommandContextProvider);
          final isActive = ctx is TexturePackerCommandContext && ctx.isHierarchyPanelVisible;
          return Icon(Icons.account_tree_outlined, color: isActive ? Theme.of(context).colorScheme.primary : null);
        }),
        defaultPositions: [AppCommandPositions.pluginToolbar],
        sourcePlugin: id,
        execute: (ref) async => _getEditorState(ref)?.toggleHierarchyPanel(),
      ),
      BaseCommand(
        id: 'packer_edit_slicing_properties',
        label: 'Slicing Properties',
        icon: const Icon(Icons.tune_outlined),
        defaultPositions: [AppCommandPositions.pluginToolbar],
        sourcePlugin: id,
        execute: (ref) async {
          final editor = _getEditorState(ref);
          if (editor?.mounted == true) {
            await SlicingPropertiesDialog.show(editor!.context, editor.widget.tab.id, editor.notifier);
          }
        },
      ),
      BaseCommand(
        id: 'packer_export_atlas',
        label: 'Export Atlas',
        icon: const Icon(Icons.output),
        defaultPositions: [AppCommandPositions.appBar],
        sourcePlugin: id,
        execute: (ref) async {
          final editor = _getEditorState(ref);
          if (editor?.mounted == true) {
            await showDialog(
              context: editor!.context,
              builder: (_) => TexturePackerExportDialog(
                tabId: editor.widget.tab.id,
                notifier: editor.notifier,
              ),
            );
          }
        },
      ),
    ];
  }
  
  @override
  String? get hotStateDtoType => null;
  @override
  Type? get hotStateDtoRuntimeType => null;
  @override
  TypeAdapter<TabHotStateDto>? get hotStateAdapter => null;
}

// FILE: lib/editor/plugins/texture_packer/texture_packer_preview_state.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';

class PreviewState {
  final bool isPlaying;
  final double speedMultiplier;
  final bool isLooping;
  final bool showGrid;

  const PreviewState({
    this.isPlaying = true,
    this.speedMultiplier = 1.0,
    this.isLooping = true,
    this.showGrid = true,
  });

  PreviewState copyWith({
    bool? isPlaying,
    double? speedMultiplier,
    bool? isLooping,
    bool? showGrid,
  }) {
    return PreviewState(
      isPlaying: isPlaying ?? this.isPlaying,
      speedMultiplier: speedMultiplier ?? this.speedMultiplier,
      isLooping: isLooping ?? this.isLooping,
      showGrid: showGrid ?? this.showGrid,
    );
  }
}

final previewStateProvider = StateProvider.family.autoDispose<PreviewState, String>(
  (ref, tabId) => const PreviewState(),
);

// FILE: lib/editor/plugins/texture_packer/texture_packer_settings.dart

import 'package:flutter/material.dart';
import 'package:machine/editor/plugins/editor_plugin_registry.dart';

class TexturePackerSettings extends PluginSettings {
  int checkerBoardColor1;
  int checkerBoardColor2;
  int gridColor;
  double gridThickness;
  double defaultAnimationSpeed;

  TexturePackerSettings({
    this.checkerBoardColor1 = 0xFF404040,
    this.checkerBoardColor2 = 0xFF505050,
    this.gridColor = 0x66FFFFFF,
    this.gridThickness = 1.0,
    this.defaultAnimationSpeed = 10.0,
  });

  @override
  void fromJson(Map<String, dynamic> json) {
    checkerBoardColor1 = json['checkerBoardColor1'] ?? 0xFF404040;
    checkerBoardColor2 = json['checkerBoardColor2'] ?? 0xFF505050;
    gridColor = json['gridColor'] ?? 0x66FFFFFF;
    gridThickness = (json['gridThickness'] ?? 1.0).toDouble();
    defaultAnimationSpeed = (json['defaultAnimationSpeed'] ?? 10.0).toDouble();
  }

  @override
  Map<String, dynamic> toJson() => {
        'checkerBoardColor1': checkerBoardColor1,
        'checkerBoardColor2': checkerBoardColor2,
        'gridColor': gridColor,
        'gridThickness': gridThickness,
        'defaultAnimationSpeed': defaultAnimationSpeed,
      };

  TexturePackerSettings copyWith({
    int? checkerBoardColor1,
    int? checkerBoardColor2,
    int? gridColor,
    double? gridThickness,
    double? defaultAnimationSpeed,
  }) {
    return TexturePackerSettings(
      checkerBoardColor1: checkerBoardColor1 ?? this.checkerBoardColor1,
      checkerBoardColor2: checkerBoardColor2 ?? this.checkerBoardColor2,
      gridColor: gridColor ?? this.gridColor,
      gridThickness: gridThickness ?? this.gridThickness,
      defaultAnimationSpeed: defaultAnimationSpeed ?? this.defaultAnimationSpeed,
    );
  }

  @override
  TexturePackerSettings clone() {
    return copyWith();
  }
}

// FILE: lib/editor/plugins/texture_packer/widgets/hierarchy_panel.dart


import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_editor_widget.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_models.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_notifier.dart';
import 'package:machine/widgets/dialogs/file_explorer_dialogs.dart';

class _FlatNode {
  final PackerItemNode node;
  final int depth;
  final String parentId;
  final int indexInParent;

  _FlatNode({
    required this.node,
    required this.depth,
    required this.parentId,
    required this.indexInParent,
  });
}

enum _DropPosition { above, inside, below }

class HierarchyPanel extends ConsumerStatefulWidget {
  final TexturePackerNotifier notifier;
  final VoidCallback onClose;

  const HierarchyPanel({
    super.key,
    required this.notifier,
    required this.onClose,
  });

  @override
  ConsumerState<HierarchyPanel> createState() => _HierarchyPanelState();
}

class _HierarchyPanelState extends ConsumerState<HierarchyPanel> {
  final Set<String> _expandedIds = {'root'};

  void _toggleExpansion(String id) {
    setState(() {
      if (_expandedIds.contains(id)) {
        _expandedIds.remove(id);
      } else {
        _expandedIds.add(id);
      }
    });
  }

  List<_FlatNode> _buildFlatList() {
    final List<_FlatNode> flatList = [];
    final root = widget.notifier.project.tree;

    void traverse(PackerItemNode node, int depth, String parentId, int index) {
      if (node.id != 'root') {
        flatList.add(_FlatNode(
          node: node,
          depth: depth,
          parentId: parentId,
          indexInParent: index,
        ));
      }

      if (node.id == 'root' || _expandedIds.contains(node.id)) {
        for (int i = 0; i < node.children.length; i++) {
          traverse(node.children[i], node.id == 'root' ? 0 : depth + 1, node.id, i);
        }
      }
    }

    traverse(root, 0, 'root', 0);
    return flatList;
  }

  Future<void> _showCreateDialog(PackerItemType type, {String? parentId}) async {
    final String title = type == PackerItemType.folder ? 'New Folder' : 'New Animation';
    final name = await showTextInputDialog(context, title: title);
    if (name != null && name.trim().isNotEmpty) {
      widget.notifier.createNode(
        type: type, 
        name: name.trim(), 
        parentId: parentId ?? ref.read(selectedNodeIdProvider) ?? 'root'
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final flatList = _buildFlatList();

    return Material(
      elevation: 4,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 8, 8, 8),
            child: Row(
              children: [
                Text('Hierarchy', style: Theme.of(context).textTheme.titleMedium),
                const Spacer(),
                IconButton(icon: const Icon(Icons.close), onPressed: widget.onClose),
              ],
            ),
          ),
          const Divider(height: 1),

          Expanded(
            child: GestureDetector(
              onTap: () => ref.read(selectedNodeIdProvider.notifier).state = null,
              child: ListView.builder(
                itemCount: flatList.length + 1,
                itemBuilder: (context, index) {
                  if (index == flatList.length) {
                    return _HierarchyRootDropZone(
                      notifier: widget.notifier, 
                      rootNode: widget.notifier.project.tree
                    );
                  }

                  final item = flatList[index];
                  return _HierarchyItemRow(
                    key: ValueKey(item.node.id),
                    flatNode: item,
                    isExpanded: _expandedIds.contains(item.node.id),
                    onToggleExpand: () => _toggleExpansion(item.node.id),
                    notifier: widget.notifier,
                  );
                },
              ),
            ),
          ),

          const Divider(height: 1),
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: () => _showCreateDialog(PackerItemType.folder),
                    icon: const Icon(Icons.create_new_folder_outlined),
                    label: const Text('Folder'),
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: () => _showCreateDialog(PackerItemType.animation),
                    icon: const Icon(Icons.movie_creation_outlined),
                    label: const Text('Anim'),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _HierarchyItemRow extends ConsumerStatefulWidget {
  final _FlatNode flatNode;
  final bool isExpanded;
  final VoidCallback onToggleExpand;
  final TexturePackerNotifier notifier;

  const _HierarchyItemRow({
    super.key,
    required this.flatNode,
    required this.isExpanded,
    required this.onToggleExpand,
    required this.notifier,
  });

  @override
  ConsumerState<_HierarchyItemRow> createState() => _HierarchyItemRowState();
}

class _HierarchyItemRowState extends ConsumerState<_HierarchyItemRow> {
  _DropPosition? _dropPosition;

  bool get _isContainer => 
      widget.flatNode.node.type == PackerItemType.folder || 
      widget.flatNode.node.type == PackerItemType.animation;

  @override
  Widget build(BuildContext context) {
    final node = widget.flatNode.node;
    final isSelected = ref.watch(selectedNodeIdProvider) == node.id;
    final theme = Theme.of(context);

    Widget content = Container(
      height: 32,
      padding: EdgeInsets.only(left: widget.flatNode.depth * 16.0 + 8.0),
      color: isSelected ? theme.colorScheme.primaryContainer.withOpacity(0.3) : null,
      child: Row(
        children: [
          if (_isContainer)
            GestureDetector(
              onTap: widget.onToggleExpand,
              child: Icon(
                widget.isExpanded ? Icons.arrow_drop_down : Icons.arrow_right,
                size: 20,
              ),
            )
          else
            const SizedBox(width: 20),
          
          Icon(
            _getIcon(),
            size: 18,
            color: node.type == PackerItemType.folder ? Colors.yellow[700] : null,
          ),
          const SizedBox(width: 8),
          
          Expanded(
            child: Text(
              node.name,
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
              style: TextStyle(
                color: isSelected ? theme.colorScheme.primary : null,
                fontWeight: isSelected ? FontWeight.w500 : FontWeight.normal,
              ),
            ),
          ),
          
          _buildContextMenu(),
        ],
      ),
    );

    if (_dropPosition != null) {
      content = CustomPaint(
        foregroundPainter: _DropIndicatorPainter(
          position: _dropPosition!,
          color: theme.colorScheme.primary,
        ),
        child: content,
      );
    }

    final draggable = LongPressDraggable<String>(
      data: node.id,
      feedback: Material(
        elevation: 4,
        borderRadius: BorderRadius.circular(4),
        child: Container(
          padding: const EdgeInsets.all(8),
          color: theme.cardColor,
          child: Row(
            children: [
              const Icon(Icons.drag_indicator),
              const SizedBox(width: 8),
              Text(node.name),
            ],
          ),
        ),
      ),
      childWhenDragging: Opacity(opacity: 0.5, child: content),
      child: content,
    );

    return DragTarget<String>(
      onWillAccept: (draggedId) {
        if (draggedId == null || draggedId == node.id) return false;
        return true;
      },
      onMove: (details) {
        final renderBox = context.findRenderObject() as RenderBox;
        final localPos = renderBox.globalToLocal(details.offset);
        final height = renderBox.size.height;
        
        
        _DropPosition newPos;
        if (localPos.dy < height * 0.25) {
          newPos = _DropPosition.above;
        } else if (localPos.dy > height * 0.75) {
          newPos = _DropPosition.below;
        } else {
          newPos = _isContainer ? _DropPosition.inside : _DropPosition.below;
        }

        if (_dropPosition != newPos) {
          setState(() => _dropPosition = newPos);
        }
      },
      onLeave: (_) => setState(() => _dropPosition = null),
      onAccept: (draggedId) {
        if (_dropPosition == null) return;
        
        final targetParent = widget.flatNode.parentId;
        final targetIndex = widget.flatNode.indexInParent;

        switch (_dropPosition!) {
          case _DropPosition.above:
            widget.notifier.moveNode(draggedId, targetParent, targetIndex);
            break;
          case _DropPosition.below:
            widget.notifier.moveNode(draggedId, targetParent, targetIndex + 1);
            break;
          case _DropPosition.inside:
            widget.notifier.moveNode(draggedId, node.id, 0);
            if (!widget.isExpanded) widget.onToggleExpand();
            break;
        }
        setState(() => _dropPosition = null);
      },
      builder: (ctx, candidates, rejects) {
        return InkWell(
          onTap: () => ref.read(selectedNodeIdProvider.notifier).state = node.id,
          child: draggable,
        );
      },
    );
  }

  IconData _getIcon() {
    switch (widget.flatNode.node.type) {
      case PackerItemType.folder: return widget.isExpanded ? Icons.folder_open : Icons.folder;
      case PackerItemType.sprite: return Icons.image_outlined;
      case PackerItemType.animation: return Icons.movie_creation_outlined;
    }
  }

  Widget _buildContextMenu() {
    return PopupMenuButton<String>(
      icon: const Icon(Icons.more_vert, size: 16),
      onSelected: (value) async {
        if (value == 'rename') {
          final newName = await showTextInputDialog(context, title: 'Rename', initialValue: widget.flatNode.node.name);
          if (newName != null && newName.trim().isNotEmpty) {
            widget.notifier.renameNode(widget.flatNode.node.id, newName.trim());
          }
        } else if (value == 'delete') {
          final confirm = await showConfirmDialog(context, title: 'Delete?', content: 'Cannot be undone.');
          if (confirm) widget.notifier.deleteNode(widget.flatNode.node.id);
        }
      },
      itemBuilder: (_) => [
        const PopupMenuItem(value: 'rename', child: Text('Rename')),
        const PopupMenuItem(value: 'delete', child: Text('Delete', style: TextStyle(color: Colors.red))),
      ],
    );
  }
}

class _HierarchyRootDropZone extends StatefulWidget {
  final TexturePackerNotifier notifier;
  final PackerItemNode rootNode;

  const _HierarchyRootDropZone({required this.notifier, required this.rootNode});

  @override
  State<_HierarchyRootDropZone> createState() => _HierarchyRootDropZoneState();
}

class _HierarchyRootDropZoneState extends State<_HierarchyRootDropZone> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    return DragTarget<String>(
      onWillAccept: (data) {
        if (data != null) {
          setState(() => _isHovered = true);
          return true;
        }
        return false;
      },
      onLeave: (_) => setState(() => _isHovered = false),
      onAccept: (draggedId) {
        setState(() => _isHovered = false);
        widget.notifier.moveNode(draggedId, 'root', widget.rootNode.children.length);
      },
      builder: (context, candidates, rejected) {
        return Container(
          height: 100,
          color: _isHovered ? Theme.of(context).colorScheme.primary.withOpacity(0.1) : Colors.transparent,
          alignment: Alignment.center,
          child: _isHovered 
            ? const Text("Move to Root", style: TextStyle(color: Colors.grey)) 
            : null,
        );
      },
    );
  }
}

class _DropIndicatorPainter extends CustomPainter {
  final _DropPosition position;
  final Color color;

  _DropIndicatorPainter({required this.position, required this.color});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;

    switch (position) {
      case _DropPosition.above:
        canvas.drawLine(Offset(0, 1), Offset(size.width, 1), paint);
        break;
      case _DropPosition.below:
        canvas.drawLine(Offset(0, size.height - 1), Offset(size.width, size.height - 1), paint);
        break;
      case _DropPosition.inside:
        final rect = Rect.fromLTWH(1, 1, size.width - 2, size.height - 2);
        canvas.drawRect(rect, paint);
        break;
    }
  }

  @override
  bool shouldRepaint(covariant _DropIndicatorPainter oldDelegate) {
    return oldDelegate.position != position || oldDelegate.color != color;
  }
}

// FILE: lib/editor/plugins/texture_packer/widgets/preview_app_bar.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../texture_packer_preview_state.dart';

class PreviewAppBar extends ConsumerWidget implements PreferredSizeWidget {
  final String tabId;
  final VoidCallback onExit;

  const PreviewAppBar({
    super.key,
    required this.tabId,
    required this.onExit,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(previewStateProvider(tabId));
    final notifier = ref.read(previewStateProvider(tabId).notifier);

    return AppBar(
      leading: IconButton(
        icon: const Icon(Icons.arrow_back),
        tooltip: 'Back to Editor',
        onPressed: onExit,
      ),
      title: const Text('Preview'),
      actions: [
        IconButton(
          icon: Icon(state.showGrid ? Icons.grid_on : Icons.grid_off),
          tooltip: 'Toggle Background',
          onPressed: () => notifier.state = state.copyWith(showGrid: !state.showGrid),
        ),
        const VerticalDivider(indent: 12, endIndent: 12, width: 24),
        
        IconButton(
          icon: Icon(state.isLooping ? Icons.repeat_on_outlined : Icons.repeat),
          color: state.isLooping ? Theme.of(context).colorScheme.primary : null,
          tooltip: 'Loop Animation',
          onPressed: () => notifier.state = state.copyWith(isLooping: !state.isLooping),
        ),

        SizedBox(
          width: 150,
          child: Slider(
            value: state.speedMultiplier,
            min: 0.1,
            max: 5.0,
            divisions: 49,
            label: '${state.speedMultiplier.toStringAsFixed(1)}x',
            onChanged: (val) => notifier.state = state.copyWith(speedMultiplier: val),
          ),
        ),

        IconButton(
          icon: Icon(state.isPlaying ? Icons.pause_circle_filled : Icons.play_circle_filled),
          iconSize: 32,
          color: Theme.of(context).colorScheme.primary,
          tooltip: state.isPlaying ? 'Pause' : 'Play',
          onPressed: () => notifier.state = state.copyWith(isPlaying: !state.isPlaying),
        ),
        const SizedBox(width: 16),
      ],
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}

// FILE: lib/editor/plugins/texture_packer/widgets/preview_view.dart

// FILE: lib/editor/plugins/texture_packer/widgets/preview_view.dart

import 'dart:ui' as ui;
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/asset_cache/asset_models.dart';
import 'package:machine/asset_cache/asset_providers.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_editor_widget.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_models.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_notifier.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_settings.dart';
import 'package:machine/settings/settings_notifier.dart';
import '../texture_packer_asset_resolver.dart';
import '../texture_packer_preview_state.dart';

class PreviewView extends ConsumerStatefulWidget {
  final String tabId;
  final TexturePackerNotifier notifier;
  const PreviewView({super.key, required this.tabId, required this.notifier});

  @override
  ConsumerState<PreviewView> createState() => _PreviewViewState();
}

class _PreviewViewState extends ConsumerState<PreviewView> with TickerProviderStateMixin {
  late final AnimationController _animationController;
  late final TransformationController _transformationController;
  
  Animation<int>? _frameAnimation;
  String? _currentAnimationNodeId; 
  bool _needsFit = true;

  @override
  void initState() {
    super.initState();
    _transformationController = TransformationController();
    _animationController = AnimationController(vsync: this, duration: const Duration(seconds: 1));
    
    _animationController.addListener(() => setState(() {}));
    
    _animationController.addStatusListener((status) {
      if (status == AnimationStatus.completed) {
        final selectedId = ref.read(selectedNodeIdProvider);
        if (selectedId != null) {
           final node = _findNodeById(widget.notifier.project.tree, selectedId);
           if (node?.type == PackerItemType.animation) {
              final state = ref.read(previewStateProvider(widget.tabId));
              if (!state.isLooping) {
                ref.read(previewStateProvider(widget.tabId).notifier).state = 
                    state.copyWith(isPlaying: false);
                _animationController.reset();
              }
           }
        }
      }
    });
  }

  @override
  void dispose() {
    _animationController.dispose();
    _transformationController.dispose();
    super.dispose();
  }


  PackerItemNode? _findNodeById(PackerItemNode node, String id) {
    if (node.id == id) return node;
    for (final child in node.children) {
      final found = _findNodeById(child, id);
      if (found != null) return found;
    }
    return null;
  }

  SourceImageConfig? _findSourceConfig(String sourceId) {
    return widget.notifier.findSourceImageConfig(sourceId);
  }

  List<PackerItemNode> _collectItemsInFolder(PackerItemNode folder) {
    List<PackerItemNode> items = [];
    for (final child in folder.children) {
      if (child.type == PackerItemType.folder) {
        items.addAll(_collectItemsInFolder(child));
      } else if (child.type == PackerItemType.sprite || child.type == PackerItemType.animation) {
        items.add(child);
      }
    }
    return items;
  }


  void _updateAnimationState(PackerItemNode node, AnimationDefinition animDef, PreviewState state) {
    final frameCount = node.children.length;

    if (frameCount == 0 || animDef.speed <= 0) {
      _animationController.stop();
      _currentAnimationNodeId = null;
      _frameAnimation = null;
      return;
    }

    final effectiveSpeed = animDef.speed * state.speedMultiplier;
    final durationMs = (frameCount / effectiveSpeed * 1000).round();
    final newDuration = Duration(milliseconds: durationMs > 0 ? durationMs : 1000);

    bool configChanged = node.id != _currentAnimationNodeId || 
                         _animationController.duration != newDuration;

    if (configChanged) {
      _currentAnimationNodeId = node.id;
      _animationController.duration = newDuration;
      _frameAnimation = StepTween(begin: 0, end: frameCount).animate(_animationController);
    }

    if (state.isPlaying) {
      if (!_animationController.isAnimating && 
          _animationController.status != AnimationStatus.completed) {
        state.isLooping ? _animationController.repeat() : _animationController.forward();
      } else if (state.isLooping && !_animationController.isAnimating) {
         _animationController.repeat();
      }
    } else {
      if (_animationController.isAnimating) {
        _animationController.stop();
      }
    }
  }

  void _fitContent(Size contentSize, Size viewportSize) {
    if (contentSize.isEmpty || viewportSize.isEmpty) return;

    final double margin = 32.0;
    final double availableW = viewportSize.width - margin * 2;
    final double availableH = viewportSize.height - margin * 2;

    final double scaleX = availableW / contentSize.width;
    final double scaleY = availableH / contentSize.height;
    final double scale = math.min(scaleX, scaleY).clamp(0.1, 10.0); 

    final double offsetX = (viewportSize.width - contentSize.width * scale) / 2;
    final double offsetY = (viewportSize.height - contentSize.height * scale) / 2;

    _transformationController.value = Matrix4.identity()
      ..translate(offsetX, offsetY)
      ..scale(scale);

    _needsFit = false;
  }


  @override
  Widget build(BuildContext context) {
    final selectedNodeId = ref.watch(selectedNodeIdProvider);
    
    ref.listen(selectedNodeIdProvider, (prev, next) {
      if (prev != next) {
        setState(() {
          _needsFit = true;
          _animationController.stop();
          _animationController.reset();
          _currentAnimationNodeId = null;
        });
      }
    });

    final resolverAsync = ref.watch(texturePackerAssetResolverProvider(widget.tabId));
    final previewState = ref.watch(previewStateProvider(widget.tabId));
    final settings = ref.watch(effectiveSettingsProvider
        .select((s) => s.pluginSettings[TexturePackerSettings] as TexturePackerSettings?)) 
        ?? TexturePackerSettings();

    return resolverAsync.when(
      data: (resolver) {
        Widget content;
        Size contentSize = Size.zero;
        
        if (selectedNodeId == null) {
          content = _buildPlaceholder('No Item Selected', 'Select a sprite or animation to preview.');
        } else {
          final node = _findNodeById(widget.notifier.project.tree, selectedNodeId);
          
          if (node == null) {
            content = _buildPlaceholder('Item Not Found', 'The selected item may have been deleted.');
          } else if (node.type == PackerItemType.folder || node.id == 'root') {
            final items = _collectItemsInFolder(node);
            
            if (previewState.isPlaying && !_animationController.isAnimating) {
              _animationController.repeat();
            } else if (!previewState.isPlaying && _animationController.isAnimating) {
              _animationController.stop();
            }

            content = _buildAtlasPreview(items, resolver, previewState);
            contentSize = const Size(500, 500); 
          } else {
            final definition = widget.notifier.project.definitions[node.id];
            
            if (definition is SpriteDefinition) {
              _animationController.stop();
              final size = _getSpriteSize(definition);
              contentSize = size ?? Size.zero;
              content = _buildSpritePreview(definition, resolver, size);
            } else if (definition is AnimationDefinition) {
              _updateAnimationState(node, definition, previewState);
              
              if (node.children.isNotEmpty) {
                 final firstFrameDef = widget.notifier.project.definitions[node.children.first.id];
                 if (firstFrameDef is SpriteDefinition) {
                   contentSize = _getSpriteSize(firstFrameDef) ?? Size.zero;
                 }
              }
              content = _buildAnimationPreview(node, resolver, contentSize);
            } else {
              content = _buildPlaceholder('No Data', 'Item definition missing.');
            }
          }
        }

        return LayoutBuilder(
          builder: (context, constraints) {
            if (_needsFit && !contentSize.isEmpty) {
              WidgetsBinding.instance.addPostFrameCallback((_) {
                if (mounted && _needsFit) {
                  _fitContent(contentSize, constraints.biggest);
                }
              });
            }

            return Container(
              color: Theme.of(context).scaffoldBackgroundColor,
              child: Stack(
                children: [
                  if (previewState.showGrid)
                    Positioned.fill(
                      child: CustomPaint(painter: _BackgroundPainter(settings: settings)),
                    ),
                  InteractiveViewer(
                    transformationController: _transformationController,
                    boundaryMargin: const EdgeInsets.all(double.infinity),
                    minScale: 0.01,
                    maxScale: 20.0,
                    constrained: false, 
                    child: contentSize.isEmpty 
                      ? SizedBox(
                          width: constraints.maxWidth,
                          height: constraints.maxHeight,
                          child: Center(child: content),
                        )
                      : Align(
                          alignment: Alignment.topLeft,
                          child: SizedBox(
                            width: contentSize.width, 
                            height: contentSize.height, 
                            child: content
                          ),
                        ),
                  ),
                ],
              ),
            );
          }
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, stack) => Center(child: Text('Error loading assets: $err')),
    );
  }

  Size? _getSpriteSize(SpriteDefinition def) {
    final sourceConfig = _findSourceConfig(def.sourceImageId);
    if (sourceConfig == null) return null;
    final rect = _calculateSourceRect(sourceConfig, def.gridRect);
    return Size(rect.width, rect.height);
  }

  Widget _buildSpritePreview(
    SpriteDefinition spriteDef,
    TexturePackerAssetResolver resolver,
    Size? precalcSize,
  ) {
    final sourceConfig = _findSourceConfig(spriteDef.sourceImageId);
    if (sourceConfig == null) return const Icon(Icons.broken_image, size: 48);

    final image = resolver.getImage(sourceConfig.path);
    if (image == null) return const Icon(Icons.broken_image, size: 48);

    final srcRect = _calculateSourceRect(sourceConfig, spriteDef.gridRect);
    final size = precalcSize ?? Size(srcRect.width, srcRect.height);

    return CustomPaint(
      size: size,
      painter: _SpritePainter(image: image, srcRect: srcRect),
    );
  }

  Widget _buildAnimationPreview(
    PackerItemNode animNode,
    TexturePackerAssetResolver resolver,
    Size frameSize,
  ) {
    if (_frameAnimation == null || animNode.children.isEmpty) {
      return _buildPlaceholder('Empty Animation', 'Add sprites to this animation.');
    }

    var frameIndex = _frameAnimation!.value;
    if (frameIndex >= animNode.children.length) frameIndex = 0;

    final frameNode = animNode.children[frameIndex];
    final spriteDef = widget.notifier.project.definitions[frameNode.id] as SpriteDefinition?;

    if (spriteDef == null) return const Icon(Icons.error_outline);
    
    return _buildSpritePreview(spriteDef, resolver, frameSize);
  }

  Widget _buildAtlasPreview(
    List<PackerItemNode> items,
    TexturePackerAssetResolver resolver,
    PreviewState state,
  ) {
    if (items.isEmpty) return _buildPlaceholder('Empty Folder', 'No items to display.');

    return Wrap(
      spacing: 8,
      runSpacing: 8,
      alignment: WrapAlignment.center,
      children: items.map((node) {
        if (node.type == PackerItemType.sprite) {
          final def = widget.notifier.project.definitions[node.id];
          if (def is SpriteDefinition) {
            final size = _getSpriteSize(def);
            return Container(
              decoration: BoxDecoration(border: Border.all(color: Colors.white24)),
              child: _buildSpritePreview(def, resolver, size),
            );
          }
        }
        else if (node.type == PackerItemType.animation) {
          final def = widget.notifier.project.definitions[node.id];
          if (def is AnimationDefinition && node.children.isNotEmpty) {
            int frameIndex = 0;
            if (state.isPlaying && def.speed > 0) {
              final ms = DateTime.now().millisecondsSinceEpoch;
              final effectiveSpeed = def.speed * state.speedMultiplier;
              final frameDurationMs = (1000 / effectiveSpeed).round();
              if (frameDurationMs > 0) {
                frameIndex = (ms ~/ frameDurationMs) % node.children.length;
              }
            }
            
            final frameNode = node.children[frameIndex];
            final spriteDef = widget.notifier.project.definitions[frameNode.id];
            
            if (spriteDef is SpriteDefinition) {
              final size = _getSpriteSize(spriteDef);
              return Container(
                decoration: BoxDecoration(border: Border.all(color: Colors.green.withOpacity(0.3))),
                child: _buildSpritePreview(spriteDef, resolver, size),
              );
            }
          }
        }
        return const SizedBox.shrink();
      }).toList(),
    );
  }

  Rect _calculateSourceRect(SourceImageConfig source, GridRect gridRect) {
    final slicing = source.slicing;
    final left = slicing.margin + gridRect.x * (slicing.tileWidth + slicing.padding);
    final top = slicing.margin + gridRect.y * (slicing.tileHeight + slicing.padding);
    final width = gridRect.width * slicing.tileWidth + (gridRect.width - 1) * slicing.padding;
    final height = gridRect.height * slicing.tileHeight + (gridRect.height - 1) * slicing.padding;
    return Rect.fromLTWH(left.toDouble(), top.toDouble(), width.toDouble(), height.toDouble());
  }
  
  Widget _buildPlaceholder(String title, String message) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(title, style: Theme.of(context).textTheme.headlineSmall),
          const SizedBox(height: 8),
          Text(message, style: Theme.of(context).textTheme.bodyMedium),
        ],
      ),
    );
  }
}

class _BackgroundPainter extends CustomPainter {
  final TexturePackerSettings settings;
  _BackgroundPainter({required this.settings});
  @override
  void paint(Canvas canvas, Size size) {
    final c1 = Color(settings.checkerBoardColor1);
    final c2 = Color(settings.checkerBoardColor2);
    final paint = Paint();
    const double checkerSize = 20.0;
    final cols = (size.width / checkerSize).ceil();
    final rows = (size.height / checkerSize).ceil();
    for (int y = 0; y < rows; y++) {
      for (int x = 0; x < cols; x++) {
        paint.color = ((x + y) % 2 == 0) ? c1 : c2;
        canvas.drawRect(Rect.fromLTWH(x * checkerSize, y * checkerSize, checkerSize, checkerSize), paint);
      }
    }
  }
  @override
  bool shouldRepaint(_BackgroundPainter old) => old.settings != settings;
}

class _SpritePainter extends CustomPainter {
  final ui.Image image;
  final Rect srcRect;
  _SpritePainter({required this.image, required this.srcRect});
  @override
  void paint(Canvas canvas, Size size) {
    canvas.drawImageRect(image, srcRect, Offset.zero & size, Paint()..filterQuality = FilterQuality.none);
  }
  @override
  bool shouldRepaint(_SpritePainter old) => old.image != image || old.srcRect != srcRect;
}

// FILE: lib/editor/plugins/texture_packer/widgets/slicing_app_bar.dart

import 'package:flutter/material.dart';

class SlicingAppBar extends StatelessWidget implements PreferredSizeWidget {
  final VoidCallback onExit;
  final bool hasSelection;
  final VoidCallback onConfirm;
  final VoidCallback onCancel;

  const SlicingAppBar({
    super.key,
    required this.onExit,
    required this.hasSelection,
    required this.onConfirm,
    required this.onCancel,
  });

  @override
  Widget build(BuildContext context) {
    return AppBar(
      leading: IconButton(
        icon: const Icon(Icons.arrow_back),
        tooltip: 'Exit Slicing Mode (Pan/Zoom)',
        onPressed: onExit,
      ),
      title: const Text('Select Sprite Area'),
      actions: [
        if (hasSelection) ...[
          IconButton(
            icon: const Icon(Icons.close),
            tooltip: 'Cancel Selection',
            onPressed: onCancel,
          ),
          const SizedBox(width: 8),
          FilledButton.icon(
            icon: const Icon(Icons.check),
            label: const Text('Create Sprite'),
            onPressed: onConfirm,
          ),
          const SizedBox(width: 16),
        ]
      ],
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}

// FILE: lib/editor/plugins/texture_packer/widgets/slicing_properties_dialog.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_editor_widget.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_models.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_notifier.dart';

class SlicingPropertiesDialog extends ConsumerStatefulWidget {
  final String tabId;
  final TexturePackerNotifier notifier;

  const SlicingPropertiesDialog({super.key, required this.tabId, required this.notifier});
  
  static Future<void> show(BuildContext context, String tabId, TexturePackerNotifier notifier) {
    return showDialog(
      context: context,
      builder: (_) => SlicingPropertiesDialog(tabId: tabId, notifier: notifier),
    );
  }

  @override
  ConsumerState<SlicingPropertiesDialog> createState() => _SlicingPropertiesDialogState();
}

class _SlicingPropertiesDialogState extends ConsumerState<SlicingPropertiesDialog> {
  late final TextEditingController _tileWidthController;
  late final TextEditingController _tileHeightController;
  late final TextEditingController _marginController;
  late final TextEditingController _paddingController;
  String? _activeId;

  @override
  void initState() {
    super.initState();
    _activeId = ref.read(activeSourceImageIdProvider);
    
    SlicingConfig config = const SlicingConfig();
    if (_activeId != null) {
      final sourceConfig = widget.notifier.findSourceImageConfig(_activeId!);
      if (sourceConfig != null) {
        config = sourceConfig.slicing;
      }
    }

    _tileWidthController = TextEditingController(text: config.tileWidth.toString());
    _tileHeightController = TextEditingController(text: config.tileHeight.toString());
    _marginController = TextEditingController(text: config.margin.toString());
    _paddingController = TextEditingController(text: config.padding.toString());
  }
  
  @override
  void dispose() {
    _tileWidthController.dispose();
    _tileHeightController.dispose();
    _marginController.dispose();
    _paddingController.dispose();
    super.dispose();
  }

  void _onConfirm() {
    if (_activeId == null) return;

    final newConfig = SlicingConfig(
      tileWidth: int.tryParse(_tileWidthController.text) ?? 16,
      tileHeight: int.tryParse(_tileHeightController.text) ?? 16,
      margin: int.tryParse(_marginController.text) ?? 0,
      padding: int.tryParse(_paddingController.text) ?? 0,
    );
    
    widget.notifier.updateSlicingConfig(_activeId!, newConfig);
    Navigator.of(context).pop();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Slicing Properties'),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(controller: _tileWidthController, decoration: const InputDecoration(labelText: 'Tile Width (px)'), keyboardType: TextInputType.number),
            TextField(controller: _tileHeightController, decoration: const InputDecoration(labelText: 'Tile Height (px)'), keyboardType: TextInputType.number),
            TextField(controller: _marginController, decoration: const InputDecoration(labelText: 'Margin (px)'), keyboardType: TextInputType.number),
            TextField(controller: _paddingController, decoration: const InputDecoration(labelText: 'Padding (px)'), keyboardType: TextInputType.number),
          ],
        ),
      ),
      actions: [
        TextButton(onPressed: () => Navigator.of(context).pop(), child: const Text('Cancel')),
        FilledButton(onPressed: _onConfirm, child: const Text('Apply')),
      ],
    );
  }
}

// FILE: lib/editor/plugins/texture_packer/widgets/slicing_view.dart

// FILE: lib/editor/plugins/texture_packer/widgets/slicing_view.dart

import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/asset_cache/asset_models.dart';
import 'package:machine/asset_cache/asset_providers.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_editor_widget.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_models.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_notifier.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_settings.dart';
import 'package:machine/settings/settings_notifier.dart';
import '../texture_packer_asset_resolver.dart';

class SlicingView extends ConsumerWidget {
  final String tabId;
  final TexturePackerNotifier notifier;
  final TransformationController transformationController;
  final GridRect? dragSelection;
  final bool isPanZoomMode;
  final Function(Offset localPosition) onGestureStart;
  final Function(Offset localPosition) onGestureUpdate;
  final VoidCallback onGestureEnd;

  const SlicingView({
    super.key,
    required this.tabId,
    required this.notifier,
    required this.transformationController,
    required this.dragSelection,
    required this.isPanZoomMode,
    required this.onGestureStart,
    required this.onGestureUpdate,
    required this.onGestureEnd,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final activeSourceId = ref.watch(activeSourceImageIdProvider);
    
    final settings = ref.watch(effectiveSettingsProvider
        .select((s) => s.pluginSettings[TexturePackerSettings] as TexturePackerSettings?)) 
        ?? TexturePackerSettings();

    if (activeSourceId == null) {
      return const Center(child: Text('Select a source image from the panel.'));
    }

    final sourceConfig = notifier.findSourceImageConfig(activeSourceId);
    if (sourceConfig == null) {
      return const Center(child: Text('Source image not found in hierarchy.'));
    }

    final resolverAsync = ref.watch(texturePackerAssetResolverProvider(tabId));

    return resolverAsync.when(
      data: (resolver) {
        final image = resolver.getImage(sourceConfig.path);
        
        if (image == null) {
           return Center(child: Text('Failed to load image: ${sourceConfig.path}'));
        }
        
        final imageSize = Size(image.width.toDouble(), image.height.toDouble());

        final selectedNodeId = ref.watch(selectedNodeIdProvider);
        GridRect? activeSelection;
        
        if (selectedNodeId != null) {
          final definition = notifier.project.definitions[selectedNodeId];
          if (definition is SpriteDefinition && definition.sourceImageId == activeSourceId) {
            activeSelection = definition.gridRect;
          }
        }

        return SizedBox.expand(
          child: GestureDetector(
            onPanStart: (details) => onGestureStart(details.localPosition),
            onPanUpdate: (details) => onGestureUpdate(details.localPosition),
            onPanEnd: (_) => onGestureEnd(),
            child: Listener(
              onPointerUp: (_) => onGestureEnd(),
              child: InteractiveViewer(
                transformationController: transformationController,
                boundaryMargin: const EdgeInsets.all(double.infinity),
                minScale: 0.1,
                maxScale: 16.0,
                panEnabled: isPanZoomMode,
                scaleEnabled: isPanZoomMode,
                constrained: false,
                child: SizedBox(
                  width: imageSize.width,
                  height: imageSize.height,
                  child: CustomPaint(
                    size: imageSize,
                    painter: _SlicingPainter(
                      image: image,
                      slicing: sourceConfig.slicing,
                      dragSelection: dragSelection,
                      activeSelection: activeSelection,
                      settings: settings,
                    ),
                  ),
                ),
              ),
            ),
          ),
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, stack) => Center(child: Text('Error loading assets: $err')),
    );
  }
}

class _SlicingPainter extends CustomPainter {
  final ui.Image image;
  final SlicingConfig slicing;
  final GridRect? dragSelection;
  final GridRect? activeSelection;
  final TexturePackerSettings settings;

  _SlicingPainter({
    required this.image,
    required this.slicing,
    this.dragSelection,
    this.activeSelection,
    required this.settings,
  });

  @override
  void paint(Canvas canvas, Size size) {
    _drawCheckerboard(canvas, size);

    final imagePaint = Paint()..filterQuality = FilterQuality.none;
    canvas.drawImage(image, Offset.zero, imagePaint);

    _drawGrid(canvas, size);

    if (activeSelection != null) {
      final paint = Paint()..color = Colors.green.withOpacity(0.5);
      _drawHighlight(canvas, activeSelection!, paint);
    }

    if (dragSelection != null) {
      final paint = Paint()..color = Colors.blue.withOpacity(0.5);
      _drawHighlight(canvas, dragSelection!, paint);
    }
  }
  
  void _drawHighlight(Canvas canvas, GridRect rect, Paint paint) {
    final pixelRect = _gridToPixelRect(rect);
    canvas.drawRect(pixelRect, paint);
    
    final stroke = Paint()
      ..color = paint.color.withOpacity(1.0)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.0;
    canvas.drawRect(pixelRect, stroke);
  }

  Rect _gridToPixelRect(GridRect rect) {
    final left = slicing.margin + rect.x * (slicing.tileWidth + slicing.padding);
    final top = slicing.margin + rect.y * (slicing.tileHeight + slicing.padding);
    final width = rect.width * slicing.tileWidth + (rect.width - 1) * slicing.padding;
    final height = rect.height * slicing.tileHeight + (rect.height - 1) * slicing.padding;
    return Rect.fromLTWH(left.toDouble(), top.toDouble(), width.toDouble(), height.toDouble());
  }

  void _drawGrid(Canvas canvas, Size size) {
    if (slicing.tileWidth <= 0 || slicing.tileHeight <= 0) return;

    final double periodX = (slicing.tileWidth + slicing.padding).toDouble();
    final double periodY = (slicing.tileHeight + slicing.padding).toDouble();
    final double thickness = settings.gridThickness;
    final Color gridColor = Color(settings.gridColor);

    if (periodX <= 0 || periodY <= 0) return;

    final paint = Paint()..style = PaintingStyle.fill;

    List<Color> buildColors() {
      final c = [gridColor, gridColor, Colors.transparent, Colors.transparent];
      if (slicing.padding > 0) {
        c.addAll([Colors.transparent, Colors.transparent, gridColor, gridColor, Colors.transparent, Colors.transparent]);
      }
      return c;
    }

    List<double> buildStops(double period, double tileDim) {
      final double r1 = (thickness / period).clamp(0.0, 1.0);
      final s = [0.0, r1, r1, 1.0];
      
      if (slicing.padding > 0) {
        final double r2Start = (tileDim / period).clamp(0.0, 1.0);
        final double r2End = ((tileDim + thickness) / period).clamp(0.0, 1.0);
        
        return [
          0.0, r1, 
          r1, r2Start, 
          r2Start, r2End, 
          r2End, 1.0
        ];
      }
      return s;
    }

    paint.shader = ui.Gradient.linear(
      Offset.zero,
      Offset(periodX, 0),
      buildColors(),
      buildStops(periodX, slicing.tileWidth.toDouble()),
      TileMode.repeated,
      Matrix4.translationValues(slicing.margin.toDouble(), 0, 0).storage,
    );
    canvas.drawRect(Offset.zero & size, paint);

    paint.shader = ui.Gradient.linear(
      Offset.zero,
      Offset(0, periodY),
      buildColors(),
      buildStops(periodY, slicing.tileHeight.toDouble()),
      TileMode.repeated,
      Matrix4.translationValues(0, slicing.margin.toDouble(), 0).storage,
    );
    canvas.drawRect(Offset.zero & size, paint);
  }

  void _drawCheckerboard(Canvas canvas, Size size) {
    final c1 = Color(settings.checkerBoardColor1);
    final c2 = Color(settings.checkerBoardColor2);

    canvas.drawColor(c1, BlendMode.src);

    final paint = Paint()..color = c2;
    const double checkerSize = 16.0;

    final path = Path();
    final cols = (size.width / checkerSize).ceil();
    final rows = (size.height / checkerSize).ceil();

    for (int y = 0; y < rows; y++) {
      for (int x = 0; x < cols; x++) {
        if ((x + y) % 2 == 1) {
          path.addRect(Rect.fromLTWH(
            x * checkerSize, 
            y * checkerSize, 
            checkerSize, 
            checkerSize
          ));
        }
      }
    }
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(_SlicingPainter oldDelegate) {
    return oldDelegate.image != image ||
        oldDelegate.slicing != slicing ||
        oldDelegate.dragSelection != dragSelection ||
        oldDelegate.activeSelection != activeSelection ||
        oldDelegate.settings != settings;
  }
}

// FILE: lib/editor/plugins/texture_packer/widgets/source_images_panel.dart


import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_editor_widget.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_models.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_notifier.dart';
import 'package:machine/widgets/dialogs/file_explorer_dialogs.dart';

enum _SourceDropPos { above, inside, below }

class _FlatSourceNode {
  final SourceImageNode node;
  final int depth;
  final String parentId;
  final int indexInParent;

  _FlatSourceNode({
    required this.node,
    required this.depth,
    required this.parentId,
    required this.indexInParent,
  });
}

class SourceImagesPanel extends ConsumerStatefulWidget {
  final TexturePackerNotifier notifier;
  final VoidCallback onAddImage;
  final VoidCallback onClose;

  const SourceImagesPanel({
    super.key,
    required this.notifier,
    required this.onAddImage,
    required this.onClose,
  });

  @override
  ConsumerState<SourceImagesPanel> createState() => _SourceImagesPanelState();
}

class _SourceImagesPanelState extends ConsumerState<SourceImagesPanel> {
  final Set<String> _expandedIds = {'root'};

  void _toggleExpansion(String id) {
    setState(() {
      if (_expandedIds.contains(id)) {
        _expandedIds.remove(id);
      } else {
        _expandedIds.add(id);
      }
    });
  }

  List<_FlatSourceNode> _buildFlatList() {
    final List<_FlatSourceNode> flatList = [];
    final root = widget.notifier.project.sourceImagesRoot;

    void traverse(SourceImageNode node, int depth, String parentId, int index) {
      if (node.id != 'root') {
        flatList.add(_FlatSourceNode(
          node: node,
          depth: depth,
          parentId: parentId,
          indexInParent: index,
        ));
      }

      if (node.id == 'root' || _expandedIds.contains(node.id)) {
        for (int i = 0; i < node.children.length; i++) {
          traverse(node.children[i], node.id == 'root' ? 0 : depth + 1, node.id, i);
        }
      }
    }

    traverse(root, 0, 'root', 0);
    return flatList;
  }

  Future<void> _createFolder(BuildContext context) async {
    final name = await showTextInputDialog(context, title: 'New Folder');
    if (name != null && name.trim().isNotEmpty) {
      widget.notifier.addSourceNode(
        name: name.trim(),
        type: SourceNodeType.folder,
        parentId: 'root',
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final flatList = _buildFlatList();

    return Material(
      elevation: 4,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 8, 8, 8),
            child: Row(
              children: [
                Text('Source Images', style: Theme.of(context).textTheme.titleMedium),
                const Spacer(),
                IconButton(icon: const Icon(Icons.close), onPressed: widget.onClose),
              ],
            ),
          ),
          const Divider(height: 1),

          Expanded(
            child: ListView.builder(
              itemCount: flatList.length + 1,
              itemBuilder: (context, index) {
                if (index == flatList.length) {
                  return _SourceRootDropZone(notifier: widget.notifier, rootNode: widget.notifier.project.sourceImagesRoot);
                }
                
                final item = flatList[index];
                return _SourceItemRow(
                  key: ValueKey(item.node.id),
                  flatNode: item,
                  isExpanded: _expandedIds.contains(item.node.id),
                  onToggleExpand: () => _toggleExpansion(item.node.id),
                  notifier: widget.notifier,
                );
              },
            ),
          ),

          const Divider(height: 1),
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: () => _createFolder(context),
                    icon: const Icon(Icons.create_new_folder_outlined),
                    label: const Text('Folder'),
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: widget.onAddImage,
                    icon: const Icon(Icons.add_photo_alternate_outlined),
                    label: const Text('Add Image'),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _SourceItemRow extends ConsumerStatefulWidget {
  final _FlatSourceNode flatNode;
  final bool isExpanded;
  final VoidCallback onToggleExpand;
  final TexturePackerNotifier notifier;

  const _SourceItemRow({
    super.key,
    required this.flatNode,
    required this.isExpanded,
    required this.onToggleExpand,
    required this.notifier,
  });

  @override
  ConsumerState<_SourceItemRow> createState() => _SourceItemRowState();
}

class _SourceItemRowState extends ConsumerState<_SourceItemRow> {
  _SourceDropPos? _dropPosition;

  bool get _isContainer => widget.flatNode.node.type == SourceNodeType.folder;

  @override
  Widget build(BuildContext context) {
    final node = widget.flatNode.node;
    final activeId = ref.watch(activeSourceImageIdProvider);
    final isSelected = node.id == activeId;
    final theme = Theme.of(context);

    Widget content = Container(
      height: 32,
      padding: EdgeInsets.only(left: widget.flatNode.depth * 16.0 + 8.0),
      color: isSelected ? theme.colorScheme.primaryContainer.withOpacity(0.3) : null,
      child: Row(
        children: [
          if (_isContainer)
            GestureDetector(
              onTap: widget.onToggleExpand,
              child: Icon(widget.isExpanded ? Icons.arrow_drop_down : Icons.arrow_right, size: 20),
            )
          else
            const SizedBox(width: 20),
          
          Icon(
            _isContainer ? (widget.isExpanded ? Icons.folder_open : Icons.folder) : Icons.image_outlined,
            size: 18,
            color: _isContainer ? Colors.yellow[700] : null,
          ),
          const SizedBox(width: 8),
          
          Expanded(
            child: Text(
              node.name,
              maxLines: 1, 
              overflow: TextOverflow.ellipsis,
              style: TextStyle(
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
              ),
            ),
          ),
          _buildContextMenu(),
        ],
      ),
    );

    if (_dropPosition != null) {
      content = CustomPaint(
        foregroundPainter: _SourceDropPainter(position: _dropPosition!, color: theme.colorScheme.primary),
        child: content,
      );
    }

    final draggable = LongPressDraggable<String>(
      data: node.id,
      feedback: Material(
        elevation: 4,
        child: Container(
          padding: const EdgeInsets.all(8),
          color: theme.cardColor,
          child: Row(children: [const Icon(Icons.photo_library), const SizedBox(width: 8), Text(node.name)]),
        ),
      ),
      childWhenDragging: Opacity(opacity: 0.5, child: content),
      child: content,
    );

    return DragTarget<String>(
      onWillAccept: (draggedId) {
        if (draggedId == null || draggedId == node.id) return false;
        return true;
      },
      onMove: (details) {
        final box = context.findRenderObject() as RenderBox;
        final localPos = box.globalToLocal(details.offset);
        final h = box.size.height;

        _SourceDropPos newPos;
        if (localPos.dy < h * 0.25) {
          newPos = _SourceDropPos.above;
        } else if (localPos.dy > h * 0.75) {
          newPos = _SourceDropPos.below;
        } else {
          newPos = _isContainer ? _SourceDropPos.inside : _SourceDropPos.below;
        }
        if (_dropPosition != newPos) setState(() => _dropPosition = newPos);
      },
      onLeave: (_) => setState(() => _dropPosition = null),
      onAccept: (draggedId) {
        if (_dropPosition == null) return;
        final pId = widget.flatNode.parentId;
        final idx = widget.flatNode.indexInParent;

        switch (_dropPosition!) {
          case _SourceDropPos.above:
            widget.notifier.moveSourceNode(draggedId, pId, idx);
            break;
          case _SourceDropPos.below:
            widget.notifier.moveSourceNode(draggedId, pId, idx + 1);
            break;
          case _SourceDropPos.inside:
            widget.notifier.moveSourceNode(draggedId, node.id, 0);
            if (!widget.isExpanded) widget.onToggleExpand();
            break;
        }
        setState(() => _dropPosition = null);
      },
      builder: (ctx, cand, rej) {
        return InkWell(
          onTap: () {
            if (!_isContainer) ref.read(activeSourceImageIdProvider.notifier).state = node.id;
          },
          child: draggable,
        );
      },
    );
  }

  Widget _buildContextMenu() {
    return PopupMenuButton<String>(
      icon: const Icon(Icons.more_vert, size: 16),
      onSelected: (val) async {
        if (val == 'delete') {
          final confirm = await showConfirmDialog(context, title: 'Remove?', content: 'Links will be broken.');
          if (confirm) widget.notifier.removeSourceNode(widget.flatNode.node.id);
        }
      },
      itemBuilder: (_) => [
        const PopupMenuItem(value: 'delete', child: Text('Remove', style: TextStyle(color: Colors.red))),
      ],
    );
  }
}

class _SourceRootDropZone extends StatefulWidget {
  final TexturePackerNotifier notifier;
  final SourceImageNode rootNode;
  const _SourceRootDropZone({required this.notifier, required this.rootNode});
  @override
  State<_SourceRootDropZone> createState() => _SourceRootDropZoneState();
}

class _SourceRootDropZoneState extends State<_SourceRootDropZone> {
  bool _hover = false;
  @override
  Widget build(BuildContext context) {
    return DragTarget<String>(
      onWillAccept: (d) {
        if (d != null) {
          setState(() => _hover = true);
          return true;
        }
        return false;
      },
      onLeave: (_) => setState(() => _hover = false),
      onAccept: (id) {
        setState(() => _hover = false);
        widget.notifier.moveSourceNode(id, 'root', widget.rootNode.children.length);
      },
      builder: (ctx, cand, rej) => Container(
        height: 80,
        color: _hover ? Theme.of(context).colorScheme.primary.withOpacity(0.1) : Colors.transparent,
        alignment: Alignment.center,
        child: _hover ? const Text("Move to Root") : null,
      ),
    );
  }
}



class _SourceDropPainter extends CustomPainter {
  final _SourceDropPos position;
  final Color color;
  _SourceDropPainter({required this.position, required this.color});

  @override
  void paint(Canvas canvas, Size size) {
    final p = Paint()..color = color..strokeWidth = 2..style = PaintingStyle.stroke;
    if (position == _SourceDropPos.above) canvas.drawLine(Offset(0,1), Offset(size.width,1), p);
    else if (position == _SourceDropPos.below) canvas.drawLine(Offset(0,size.height-1), Offset(size.width,size.height-1), p);
    else canvas.drawRect(Rect.fromLTWH(1,1,size.width-2,size.height-2), p);
  }
  @override
  bool shouldRepaint(_SourceDropPainter old) => old.position != position || old.color != color;
}

// FILE: lib/editor/plugins/texture_packer/widgets/texture_packer_export_dialog.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/app/app_notifier.dart';
import 'package:machine/data/repositories/project/project_repository.dart';
import 'package:machine/editor/plugins/texture_packer/services/pixi_export_service.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_notifier.dart';
import 'package:machine/utils/toast.dart';
import 'package:machine/widgets/dialogs/file_explorer_dialogs.dart';
import 'package:machine/asset_cache/asset_models.dart';
import 'package:machine/asset_cache/asset_providers.dart';
import '../../../../widgets/dialogs/folder_picker_dialog.dart';

class TexturePackerExportDialog extends ConsumerStatefulWidget {
  final String tabId;
  final TexturePackerNotifier notifier;

  const TexturePackerExportDialog({
    super.key,
    required this.tabId,
    required this.notifier,
  });

  @override
  ConsumerState<TexturePackerExportDialog> createState() => _TexturePackerExportDialogState();
}

class _TexturePackerExportDialogState extends ConsumerState<TexturePackerExportDialog> {
  final TextEditingController _nameController = TextEditingController(text: 'atlas');
  String? _destinationUri;
  String _destinationDisplay = 'Select destination...';
  bool _isExporting = false;

  @override
  void dispose() {
    _nameController.dispose();
    super.dispose();
  }

  Future<void> _pickDestination() async {
    final project = ref.read(appNotifierProvider).value?.currentProject;
    final repo = ref.read(projectRepositoryProvider);
    if (project == null || repo == null) return;

    // Use existing picker to select a folder (technically selects a file/folder, we take parent if file)
    final path = await showDialog<String>(
      context: context,
      builder: (_) => const FileOrFolderPickerDialog(),
    );

    if (path != null) {
      final file = await repo.fileHandler.resolvePath(project.rootUri, path);
      if (file != null) {
        setState(() {
          _destinationUri = file.isDirectory ? file.uri : repo.fileHandler.getParentUri(file.uri);
          _destinationDisplay = path;
        });
      }
    }
  }

  Future<void> _doExport() async {
    if (_destinationUri == null) {
      MachineToast.error('Please select a destination folder.');
      return;
    }
    if (_nameController.text.trim().isEmpty) {
      MachineToast.error('Please enter a filename.');
      return;
    }

    setState(() => _isExporting = true);

    try {
      final assetMapAsync = ref.read(assetMapProvider(widget.tabId));
      
      if (!assetMapAsync.hasValue) {
        throw Exception('Assets are not fully loaded. Please wait and try again.');
      }

      await ref.read(pixiExportServiceProvider).export(
        project: widget.notifier.project,
        assetDataMap: assetMapAsync.value!,
        destinationFolderUri: _destinationUri!,
        fileName: _nameController.text.trim(),
      );

      MachineToast.info('Export successful!');
      if (mounted) Navigator.of(context).pop();
    } catch (e) {
      MachineToast.error('Export failed: $e');
    } finally {
      if (mounted) setState(() => _isExporting = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Export Texture Atlas (PixiJS)'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('Destination Folder'),
          const SizedBox(height: 4),
          ListTile(
            contentPadding: EdgeInsets.zero,
            leading: const Icon(Icons.folder_open),
            title: Text(_destinationDisplay, overflow: TextOverflow.ellipsis),
            onTap: _pickDestination,
            shape: RoundedRectangleBorder(
              side: BorderSide(color: Theme.of(context).dividerColor),
              borderRadius: BorderRadius.circular(4),
            ),
          ),
          const SizedBox(height: 16),
          const Text('Filename (without extension)'),
          TextField(
            controller: _nameController,
            decoration: const InputDecoration(
              hintText: 'e.g. characters',
              suffixText: '.png / .json',
            ),
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: _isExporting ? null : () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        FilledButton(
          onPressed: _isExporting ? null : _doExport,
          child: _isExporting 
            ? const SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2))
            : const Text('Export'),
        ),
      ],
    );
  }
}

// FILE: lib/editor/plugins/texture_packer/widgets/texture_packer_file_dialog.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/app/app_notifier.dart';
import 'package:machine/data/file_handler/file_handler.dart';
import 'package:machine/data/repositories/project/project_repository.dart';
import 'package:machine/project/services/project_hierarchy_service.dart';

class TexturePackerImportResult {
  final List<ProjectDocumentFile> files;
  final bool asSprites;

  TexturePackerImportResult(this.files, this.asSprites);
}

final _tpFilePickerLastPathProvider = StateProvider<String?>((ref) => null);

class TexturePackerFilePickerDialog extends ConsumerStatefulWidget {
  final String projectRootUri;
  const TexturePackerFilePickerDialog({super.key, required this.projectRootUri});

  @override
  ConsumerState<TexturePackerFilePickerDialog> createState() => _TexturePackerFilePickerDialogState();
}

class _TexturePackerFilePickerDialogState extends ConsumerState<TexturePackerFilePickerDialog> {
  late String _currentPathUri;
  final Set<ProjectDocumentFile> _selectedFiles = {};
  bool _importAsSprites = false;

  @override
  void initState() {
    super.initState();
    _currentPathUri = ref.read(_tpFilePickerLastPathProvider) ?? widget.projectRootUri;
    
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        ref.read(projectHierarchyServiceProvider.notifier).loadDirectory(_currentPathUri);
      }
    });
  }

  void _setCurrentPath(String newPath) {
    ref.read(projectHierarchyServiceProvider.notifier).loadDirectory(newPath);
    ref.read(_tpFilePickerLastPathProvider.notifier).state = newPath;
    setState(() => _currentPathUri = newPath);
  }

  void _toggleFileSelection(ProjectDocumentFile file) {
    setState(() {
      if (_selectedFiles.contains(file)) {
        _selectedFiles.remove(file);
      } else {
        _selectedFiles.add(file);
      }
    });
  }

  Future<void> _onLongPressFolder(ProjectDocumentFile folder) async {
    final result = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text('Select all images in "${folder.name}"?'),
        actions: [
          TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('Cancel')),
          FilledButton(onPressed: () => Navigator.of(ctx).pop(true), child: const Text('Select All')),
        ],
      ),
    );

    if (result == true) {
      final files = await _gatherPngFiles(folder);
      setState(() {
        _selectedFiles.addAll(files);
      });
    }
  }

  Future<List<ProjectDocumentFile>> _gatherPngFiles(ProjectDocumentFile folder) async {
    final repo = ref.read(projectRepositoryProvider);
    if (repo == null) return [];
    
    try {
      final children = await repo.listDirectory(folder.uri);
      return children.where((f) => !f.isDirectory && f.name.toLowerCase().endsWith('.png')).toList();
    } catch (e) {
      return [];
    }
  }

  @override
  Widget build(BuildContext context) {
    final directoryState = ref.watch(directoryContentsProvider(_currentPathUri));
    final fileHandler = ref.watch(projectRepositoryProvider)?.fileHandler;

    return AlertDialog(
      title: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(_selectedFiles.isEmpty 
            ? 'Select Images' 
            : '${_selectedFiles.length} Selected'),
          if (_selectedFiles.isNotEmpty)
            IconButton(
              icon: const Icon(Icons.clear_all),
              tooltip: 'Clear Selection',
              onPressed: () => setState(() => _selectedFiles.clear()),
            ),
        ],
      ),
      content: SizedBox(
        width: double.maxFinite,
        height: 500,
        child: Column(
          children: [
            if (fileHandler != null)
              Row(
                children: [
                  IconButton(
                    icon: const Icon(Icons.arrow_upward),
                    onPressed: _currentPathUri == widget.projectRootUri
                        ? null
                        : () {
                            final parent = fileHandler.getParentUri(_currentPathUri);
                            _setCurrentPath(parent);
                          },
                  ),
                  Expanded(
                    child: Text(
                      fileHandler.getPathForDisplay(_currentPathUri, relativeTo: widget.projectRootUri).isEmpty
                          ? '/'
                          : fileHandler.getPathForDisplay(_currentPathUri, relativeTo: widget.projectRootUri),
                      style: Theme.of(context).textTheme.bodySmall,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
            const Divider(),
            // File List
            Expanded(
              child: directoryState == null
                  ? const Center(child: CircularProgressIndicator())
                  : directoryState.when(
                      data: (nodes) {
                        final sorted = List.of(nodes)..sort((a, b) {
                          if (a.file.isDirectory != b.file.isDirectory) {
                            return a.file.isDirectory ? -1 : 1;
                          }
                          return a.file.name.toLowerCase().compareTo(b.file.name.toLowerCase());
                        });

                        final filtered = sorted.where((n) {
                          return n.file.isDirectory || n.file.name.toLowerCase().endsWith('.png');
                        }).toList();

                        return ListView.builder(
                          itemCount: filtered.length,
                          itemBuilder: (context, index) {
                            final node = filtered[index];
                            final isSelected = _selectedFiles.contains(node.file);

                            if (node.file.isDirectory) {
                              return ListTile(
                                leading: const Icon(Icons.folder_outlined),
                                title: Text(node.file.name),
                                onTap: () => _setCurrentPath(node.file.uri),
                                onLongPress: () => _onLongPressFolder(node.file),
                              );
                            } else {
                              return ListTile(
                                leading: Checkbox(
                                  value: isSelected,
                                  onChanged: (_) => _toggleFileSelection(node.file),
                                ),
                                title: Text(node.file.name),
                                onTap: () => _toggleFileSelection(node.file),
                              );
                            }
                          },
                        );
                      },
                      loading: () => const Center(child: CircularProgressIndicator()),
                      error: (e, s) => Center(child: Text('Error: $e')),
                    ),
            ),
            const Divider(),
            CheckboxListTile(
              value: _importAsSprites,
              onChanged: (val) => setState(() => _importAsSprites = val ?? false),
              title: const Text('Import as Single Sprites / Frames'),
              subtitle: const Text('Automatically sets grid size to image size'),
              controlAffinity: ListTileControlAffinity.leading,
              contentPadding: EdgeInsets.zero,
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        FilledButton(
          onPressed: _selectedFiles.isEmpty
              ? null
              : () {
                  final sortedFiles = _selectedFiles.toList()
                    ..sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));
                  
                  Navigator.of(context).pop(TexturePackerImportResult(sortedFiles, _importAsSprites));
                },
          child: const Text('Import'),
        ),
      ],
    );
  }
}

// FILE: lib/editor/plugins/texture_packer/widgets/texture_packer_settings_widget.dart

import 'package:flex_color_picker/flex_color_picker.dart';
import 'package:flutter/material.dart';
import '../texture_packer_settings.dart';

class TexturePackerSettingsWidget extends StatelessWidget {
  final TexturePackerSettings settings;
  final void Function(TexturePackerSettings) onChanged;

  const TexturePackerSettingsWidget({
    super.key,
    required this.settings,
    required this.onChanged,
  });

  Future<void> _pickColor(BuildContext context, Color current, Function(Color) onSelect) async {
    final newColor = await showColorPickerDialog(
      context,
      current,
      enableOpacity: true,
      showColorCode: true,
    );
    onSelect(newColor);
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('Canvas Appearance', style: Theme.of(context).textTheme.titleMedium),
        const SizedBox(height: 8),
        ListTile(
          contentPadding: EdgeInsets.zero,
          title: const Text('Checkerboard Color 1'),
          trailing: ColorIndicator(
            color: Color(settings.checkerBoardColor1),
            onSelect: () => _pickColor(
              context, 
              Color(settings.checkerBoardColor1), 
              (c) => onChanged(settings.copyWith(checkerBoardColor1: c.value)),
            ),
          ),
        ),
        ListTile(
          contentPadding: EdgeInsets.zero,
          title: const Text('Checkerboard Color 2'),
          trailing: ColorIndicator(
            color: Color(settings.checkerBoardColor2),
            onSelect: () => _pickColor(
              context, 
              Color(settings.checkerBoardColor2), 
              (c) => onChanged(settings.copyWith(checkerBoardColor2: c.value)),
            ),
          ),
        ),
        ListTile(
          contentPadding: EdgeInsets.zero,
          title: const Text('Grid Color'),
          trailing: ColorIndicator(
            color: Color(settings.gridColor),
            onSelect: () => _pickColor(
              context, 
              Color(settings.gridColor), 
              (c) => onChanged(settings.copyWith(gridColor: c.value)),
            ),
          ),
        ),
        const SizedBox(height: 16),
        Text('Grid Thickness: ${settings.gridThickness.toStringAsFixed(1)}'),
        Slider(
          value: settings.gridThickness,
          min: 0.5,
          max: 5.0,
          divisions: 9,
          label: settings.gridThickness.toStringAsFixed(1),
          onChanged: (v) => onChanged(settings.copyWith(gridThickness: v)),
        ),
        const Divider(height: 32),
        Text('Defaults', style: Theme.of(context).textTheme.titleMedium),
        const SizedBox(height: 8),
        TextFormField(
          initialValue: settings.defaultAnimationSpeed.toString(),
          decoration: const InputDecoration(labelText: 'Default Animation Speed (FPS)'),
          keyboardType: TextInputType.number,
          onChanged: (v) {
            final val = double.tryParse(v);
            if (val != null) onChanged(settings.copyWith(defaultAnimationSpeed: val));
          },
        ),
      ],
    );
  }
}

// FILE: lib/editor/plugins/tiled_editor/image_load_result.dart

import 'dart:ui' as ui;

class ImageLoadResult {
  final ui.Image? image;
  final String? error;
  final String path;

  ImageLoadResult({this.image, this.error, required this.path});

  bool get hasError => error != null;
}

// FILE: lib/editor/plugins/tiled_editor/inspector/inspector_dialog.dart

// FILE: lib/editor/plugins/tiled_editor/inspector/inspector_dialog.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:tiled/tiled.dart' as tiled;
import 'package:path/path.dart' as p;

import 'property_descriptors.dart';
import 'tiled_reflectors.dart';
import 'property_widgets.dart';
import '../tiled_editor_widget.dart';
import '../tiled_map_notifier.dart';
import 'package:machine/asset_cache/asset_models.dart';
import '../tiled_asset_resolver.dart';

class InspectorDialog extends ConsumerStatefulWidget {
  final Object target;
  final String title;
  final TiledMapNotifier notifier;
  final GlobalKey<TiledEditorWidgetState> editorKey;
  
  final TiledAssetResolver resolver;

  const InspectorDialog({
    super.key,
    required this.target,
    required this.title,
    required this.notifier,
    required this.editorKey,
    required this.resolver,
  });

  @override
  ConsumerState<InspectorDialog> createState() => _InspectorDialogState();
}

class _InspectorDialogState extends ConsumerState<InspectorDialog> {
  late Object _beforeState;
  bool _hasChanges = false;

  @override
  void initState() {
    super.initState();
    _beforeState = _deepCopyTarget(widget.target);
  }

  @override
  void dispose() {
    if (_hasChanges) {
      final afterState = _deepCopyTarget(widget.target);
      widget.notifier.recordPropertyChange(_beforeState, afterState);
      widget.notifier.notifyListeners();
    }
    super.dispose();
  }

  Object _deepCopyTarget(Object target) {
    if (target is tiled.TiledObject) {
      return deepCopyTiledObject(target);
    }
    if (target is tiled.Layer) {
      return deepCopyLayer(target);
    }
    if (target is tiled.TiledMap) {
      final newMap = tiled.TiledMap(
        width: target.width,
        height: target.height,
        tileWidth: target.tileWidth,
        tileHeight: target.tileHeight,
      )
        ..backgroundColorHex = target.backgroundColorHex
        ..renderOrder = target.renderOrder;
      return newMap;
    }
    if (target is tiled.Tileset) {
      return deepCopyTileset(target);
    }
    return target;
  }

  void _onUpdate() {
    if (!mounted) return;
    setState(() {
      _hasChanges = true;
    });
    widget.notifier.notifyListeners();
  }

  @override
  Widget build(BuildContext context) {
    final descriptors = TiledReflector.getDescriptors(widget.target);

    return AlertDialog(
      title: Text(widget.title),
      content: SizedBox(
        width: double.maxFinite,
        child: ListView.builder(
          shrinkWrap: true,
          itemCount: descriptors.length,
          itemBuilder: (context, index) {
            final descriptor = descriptors[index];
            return _buildPropertyWidget(descriptor);
          },
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Close'),
        ),
      ],
    );
  }

  Widget _buildPropertyWidget(PropertyDescriptor descriptor, {PropertyDescriptor? parentDescriptor}) {
    if (descriptor is ImagePathPropertyDescriptor) {
      
      final rawPath = descriptor.currentValue;
      
      tiled.Tileset? contextTileset;
      Object? parentObject;

      if (parentDescriptor is ObjectPropertyDescriptor) {
         parentObject = parentDescriptor.target;
         if (parentObject is tiled.Tileset) {
           contextTileset = parentObject;
         }
      } else {
        if (widget.target is tiled.Tileset) {
          contextTileset = widget.target as tiled.Tileset;
          parentObject = widget.target;
        }
      }
      
      final image = widget.resolver.getImage(rawPath, tileset: contextTileset);
      final imageAsset = image != null ? ImageAssetData(image: image) : null;
      
      final actualParentObject = parentObject ?? widget.target;
      
      return PropertyImagePathInput(
        descriptor: descriptor,
        onUpdate: _onUpdate,
        imageAsset: imageAsset,
        editorKey: widget.editorKey,
        parentObject: actualParentObject,
      );
    }
    if (descriptor is FileListPropertyDescriptor) {
      return PropertyFileListEditor(
        descriptor: descriptor,
        onUpdate: _onUpdate,
        editorKey: widget.editorKey,
        contextPath: widget.resolver.tmxPath,
      );
    }
    if (descriptor is SpriteReferencePropertyDescriptor) {
      return PropertySpriteSelector(
        descriptor: descriptor,
        onUpdate: _onUpdate,
        assetDataMap: widget.resolver.rawAssets,
      );
    }
    if (descriptor is BoolPropertyDescriptor) {
      return PropertyBoolSwitch(descriptor: descriptor, onUpdate: _onUpdate);
    }
    if (descriptor is ColorPropertyDescriptor) {
      return PropertyColorInput(descriptor: descriptor, onUpdate: _onUpdate);
    }
    if (descriptor is IntPropertyDescriptor) {
      return PropertyIntInput(descriptor: descriptor, onUpdate: _onUpdate);
    }
    if (descriptor is DoublePropertyDescriptor) {
      return PropertyDoubleInput(descriptor: descriptor, onUpdate: _onUpdate);
    }
    if (descriptor is StringPropertyDescriptor) {
      // Check for file link convention (e.g. ends with .fg or specific property name)
      if (descriptor.currentValue.endsWith('.fg') || descriptor.name.contains('graph')) {
        return PropertyFileLinkWithAction(
          descriptor: descriptor,
          onUpdate: _onUpdate,
        );
      }
      return PropertyStringInput(descriptor: descriptor, onUpdate: _onUpdate);
    }
    if (descriptor is EnumPropertyDescriptor<tiled.RenderOrder>) {
      return PropertyEnumDropdown<tiled.RenderOrder>(descriptor: descriptor, onUpdate: _onUpdate);
    }
    if (descriptor is EnumPropertyDescriptor<tiled.DrawOrder>) {
      return PropertyEnumDropdown<tiled.DrawOrder>(descriptor: descriptor, onUpdate: _onUpdate);
    }
    if (descriptor is EnumPropertyDescriptor<tiled.ObjectAlignment>) {
      return PropertyEnumDropdown<tiled.ObjectAlignment>(descriptor: descriptor, onUpdate: _onUpdate);
    }
    if (descriptor is EnumPropertyDescriptor<tiled.HAlign>) {
      return PropertyEnumDropdown<tiled.HAlign>(descriptor: descriptor, onUpdate: _onUpdate);
    }
    if (descriptor is EnumPropertyDescriptor<tiled.VAlign>) {
      return PropertyEnumDropdown<tiled.VAlign>(descriptor: descriptor, onUpdate: _onUpdate);
    }
    if (descriptor is CustomPropertiesDescriptor) {
      return CustomPropertiesEditor(descriptor: descriptor, onUpdate: _onUpdate);
    }
    if (descriptor is ObjectPropertyDescriptor) {
      final nestedObject = descriptor.currentValue;
      if (nestedObject == null) return const SizedBox.shrink();

      if (nestedObject is tiled.TiledImage) {
        final imageDescriptors = nestedObject.getDescriptors(descriptor.target!);
        return ExpansionTile(
          title: Text(descriptor.label),
          children: imageDescriptors.map((childDesc) => _buildPropertyWidget(childDesc, parentDescriptor: descriptor)).toList(),
        );
      }
      return ListTile(title: Text('${descriptor.label}: Unsupported Type'));
    }

    return ListTile(title: Text('${descriptor.label}: ${descriptor.currentValue}'));
  }
}

// FILE: lib/editor/plugins/tiled_editor/inspector/property_descriptors.dart

import 'package:flutter/material.dart';
import 'package:tiled/tiled.dart' hide Image;

@immutable
abstract class PropertyDescriptor {
  final String name;
  final String label;
  final Object? target;
  final bool isReadOnly;

  const PropertyDescriptor({
    required this.name,
    required this.label,
    this.target,
    this.isReadOnly = false,
  });

  dynamic get currentValue;
  void updateValue(dynamic newValue);
}


class IntPropertyDescriptor extends PropertyDescriptor {
  final int Function() getter;
  final void Function(int) setter;

  const IntPropertyDescriptor({
    required super.name,
    required super.label,
    required this.getter,
    required this.setter,
    super.isReadOnly,
  });

  @override
  int get currentValue => getter();
  @override
  void updateValue(dynamic newValue) => setter(int.tryParse(newValue.toString()) ?? currentValue);
}

class DoublePropertyDescriptor extends PropertyDescriptor {
  final double Function() getter;
  final void Function(double) setter;

  const DoublePropertyDescriptor({
    required super.name,
    required super.label,
    required this.getter,
    required this.setter,
    super.isReadOnly,
  });

  @override
  double get currentValue => getter();
  @override
  void updateValue(dynamic newValue) => setter(double.tryParse(newValue.toString()) ?? currentValue);
}

class StringPropertyDescriptor extends PropertyDescriptor {
  final String Function() getter;
  final void Function(String) setter;

  const StringPropertyDescriptor({
    required super.name,
    required super.label,
    required this.getter,
    required this.setter,
    super.isReadOnly,
  });

  @override
  String get currentValue => getter();
  @override
  void updateValue(dynamic newValue) => setter(newValue.toString());
}

class BoolPropertyDescriptor extends PropertyDescriptor {
  final bool Function() getter;
  final void Function(bool) setter;

  const BoolPropertyDescriptor({
    required super.name,
    required super.label,
    required this.getter,
    required this.setter,
    super.isReadOnly,
  });

  @override
  bool get currentValue => getter();
  @override
  void updateValue(dynamic newValue) => setter(newValue as bool);
}

class ColorPropertyDescriptor extends PropertyDescriptor {
  final String? Function() getter;
  final void Function(String) setter;

  const ColorPropertyDescriptor({
    required super.name,
    required super.label,
    required this.getter,
    required this.setter,
    super.isReadOnly,
  });

  @override
  String? get currentValue => getter();
  @override
  void updateValue(dynamic newValue) => setter(newValue as String);
}

class ImagePathPropertyDescriptor extends StringPropertyDescriptor {
  const ImagePathPropertyDescriptor({
    required super.name,
    required super.label,
    required super.getter,
    required super.setter,
    super.isReadOnly,
  });
}

class ObjectPropertyDescriptor extends PropertyDescriptor {
  final Object? Function() getter;

  const ObjectPropertyDescriptor({
    required super.name,
    required super.label,
    required this.getter,
    super.target,
  }) : super(isReadOnly: true);

  @override
  Object? get currentValue => getter();
  @override
  void updateValue(dynamic newValue) {}
}

class EnumPropertyDescriptor<T extends Enum> extends PropertyDescriptor {
  final T Function() getter;
  final void Function(T) setter;
  final List<T> allValues;

  const EnumPropertyDescriptor({
    required super.name,
    required super.label,
    required this.getter,
    required this.setter,
    required this.allValues,
    super.isReadOnly,
  });

  @override
  T get currentValue => getter();
  
  @override
  void updateValue(dynamic newValue) {
    if (newValue is T) {
      setter(newValue);
    }
  }
}

class CustomPropertiesDescriptor extends PropertyDescriptor {
  final CustomProperties Function() getter;
  final void Function(CustomProperties) setter;

  const CustomPropertiesDescriptor({
    required super.name,
    required super.label,
    required this.getter,
    required this.setter,
    super.isReadOnly,
  });

  @override
  CustomProperties get currentValue => getter();

  @override
  void updateValue(dynamic newValue) {
    if (newValue is CustomProperties) {
      setter(newValue);
    }
  }
}

// A descriptor for a comma-separated list of file paths (used for tp_atlases)
class FileListPropertyDescriptor extends PropertyDescriptor {
  final List<String> Function() getter;
  final void Function(List<String>) setter;

  const FileListPropertyDescriptor({
    required super.name,
    required super.label,
    required this.getter,
    required this.setter,
    super.isReadOnly,
  });

  @override
  List<String> get currentValue => getter();
  
  @override
  void updateValue(dynamic newValue) {
    if (newValue is List<String>) setter(newValue);
  }
}

class SpriteReferencePropertyDescriptor extends StringPropertyDescriptor {
  const SpriteReferencePropertyDescriptor({
    required super.name,
    required super.label,
    required super.getter,
    required super.setter,
    super.isReadOnly,
  });
}

// FILE: lib/editor/plugins/tiled_editor/inspector/property_widgets.dart

import 'package:flutter/material.dart' hide ColorProperty;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flex_color_picker/flex_color_picker.dart';
import 'package:machine/asset_cache/asset_models.dart';
import 'package:path/path.dart' as p;

import 'property_descriptors.dart';
import '../tiled_editor_widget.dart';
import '../../../../widgets/dialogs/folder_picker_dialog.dart';
import '../image_load_result.dart';
import '../../../../utils/toast.dart';
import 'package:tiled/tiled.dart' hide Text;
import 'package:machine/editor/plugins/texture_packer/texture_packer_models.dart';
import 'package:machine/asset_cache/asset_models.dart';
import '../widgets/sprite_picker_dialog.dart'; // Import the new file
import 'package:machine/app/app_notifier.dart';
import '../../../services/editor_service.dart';

class PropertyFileListEditor extends StatelessWidget {
  final FileListPropertyDescriptor descriptor;
  final VoidCallback onUpdate;
  final GlobalKey<TiledEditorWidgetState> editorKey;
  final String contextPath;

  const PropertyFileListEditor({
    super.key,
    required this.descriptor,
    required this.onUpdate,
    required this.editorKey,
    required this.contextPath,
  });

  Future<void> _addFile(BuildContext context) async {
    final paths = List<String>.from(descriptor.currentValue);
    
    final newPath = await showDialog<String>(
      context: context,
      builder: (_) => const FileOrFolderPickerDialog(),
    );
    
    if (newPath != null) {
      // Calculate path relative to the TMX file (e.g. "../atlases/items.tpacker")
      final contextDir = p.dirname(contextPath);
      final relativePath = p.relative(newPath, from: contextDir).replaceAll(r'\', '/');

      paths.add(relativePath); 
      descriptor.updateValue(paths);
      onUpdate();
    }
  }

  void _removeFile(int index) {
    final paths = List<String>.from(descriptor.currentValue);
    paths.removeAt(index);
    descriptor.updateValue(paths);
    onUpdate();
  }

  @override
  Widget build(BuildContext context) {
    final files = descriptor.currentValue;
    
    return ExpansionTile(
      title: Text(descriptor.label),
      subtitle: Text('${files.length} linked'),
      children: [
        for (int i = 0; i < files.length; i++)
          ListTile(
            title: Text(files[i]),
            trailing: IconButton(
              icon: const Icon(Icons.close, size: 16),
              onPressed: () => _removeFile(i),
            ),
          ),
        ListTile(
          leading: const Icon(Icons.add),
          title: const Text('Link Texture Packer File'),
          onTap: () => _addFile(context),
        ),
      ],
    );
  }
}


class PropertyFileLinkWithAction extends ConsumerWidget {
  final StringPropertyDescriptor descriptor;
  final VoidCallback onUpdate;

  const PropertyFileLinkWithAction({
    super.key,
    required this.descriptor,
    required this.onUpdate,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final path = descriptor.currentValue;
    final isFlowGraph = path.endsWith('.fg');

    return ListTile(
      contentPadding: EdgeInsets.zero,
      title: Text(descriptor.label),
      subtitle: Text(path.isEmpty ? 'No file' : path),
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (isFlowGraph && path.isNotEmpty)
            IconButton(
              icon: const Icon(Icons.hub_outlined, color: Colors.orange),
              tooltip: 'Open Flow Graph',
              onPressed: () {
                // CORRECTED: Use EditorService to open the file by path
                ref.read(editorServiceProvider).openOrCreate(path);
              },
            ),
          IconButton(
            icon: const Icon(Icons.folder_open),
            onPressed: () async {
              final newPath = await showDialog<String>(
                context: context,
                builder: (_) => const FileOrFolderPickerDialog(),
              );
              if (newPath != null) {
                descriptor.updateValue(newPath);
                onUpdate();
              }
            },
          ),
        ],
      ),
    );
  }
}

class PropertySpriteSelector extends StatelessWidget {
  final SpriteReferencePropertyDescriptor descriptor;
  final VoidCallback onUpdate;
  final Map<String, AssetData> assetDataMap;

  const PropertySpriteSelector({
    super.key,
    required this.descriptor,
    required this.onUpdate,
    required this.assetDataMap,
  });

  @override
  Widget build(BuildContext context) {
    final Map<String, TexturePackerAssetData> availableAtlases = {};
    final List<String> allSpriteNames = [];

    assetDataMap.forEach((key, value) {
      if (value is TexturePackerAssetData) {
        availableAtlases[key] = value;
        allSpriteNames.addAll(value.frames.keys);
      }
    });
    
    allSpriteNames.sort();

    final currentVal = descriptor.currentValue;

    return ListTile(
      contentPadding: EdgeInsets.zero,
      title: Text(descriptor.label),
      subtitle: Text(currentVal.isEmpty ? 'None' : currentVal),
      trailing: const Icon(Icons.arrow_drop_down),
      onTap: () async {
        if (allSpriteNames.isEmpty) {
          MachineToast.info('No .tpacker files linked or loaded.');
          return;
        }

        final selected = await showDialog<String>(
          context: context,
          builder: (ctx) => SpritePickerDialog(spriteNames: allSpriteNames),
        );

        if (selected != null) {
          descriptor.updateValue(selected);
          onUpdate();
        }
      },
    );
  }
}

class _SpritePickerDialog extends StatefulWidget {
  final List<String> spriteNames;
  const _SpritePickerDialog({required this.spriteNames});

  @override
  State<_SpritePickerDialog> createState() => _SpritePickerDialogState();
}

class _SpritePickerDialogState extends State<_SpritePickerDialog> {
  late List<String> _filtered;
  final TextEditingController _searchCtrl = TextEditingController();

  @override
  void initState() {
    super.initState();
    _filtered = widget.spriteNames;
  }

  void _filter(String query) {
    setState(() {
      if (query.isEmpty) {
        _filtered = widget.spriteNames;
      } else {
        _filtered = widget.spriteNames
            .where((s) => s.toLowerCase().contains(query.toLowerCase()))
            .toList();
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Select Sprite'),
      content: SizedBox(
        width: double.maxFinite,
        height: 400,
        child: Column(
          children: [
            TextField(
              controller: _searchCtrl,
              decoration: const InputDecoration(
                hintText: 'Search...',
                prefixIcon: Icon(Icons.search),
              ),
              onChanged: _filter,
            ),
            const SizedBox(height: 8),
            Expanded(
              child: ListView.builder(
                itemCount: _filtered.length,
                itemBuilder: (context, index) {
                  final name = _filtered[index];
                  return ListTile(
                    title: Text(name),
                    onTap: () => Navigator.of(context).pop(name),
                  );
                },
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        TextButton(
          onPressed: () => Navigator.of(context).pop(''),
          child: const Text('Clear'),
        ),
      ],
    );
  }
}

class PropertyIntInput extends StatelessWidget {
  final IntPropertyDescriptor descriptor;
  final VoidCallback onUpdate;
  const PropertyIntInput({super.key, required this.descriptor, required this.onUpdate});

  @override
  Widget build(BuildContext context) {
    return TextFormField(
      initialValue: descriptor.currentValue.toString(),
      decoration: InputDecoration(labelText: descriptor.label),
      keyboardType: TextInputType.number,
      readOnly: descriptor.isReadOnly,
      onChanged: (value) {
        descriptor.updateValue(value);
        onUpdate();
      },
    );
  }
}

class PropertyDoubleInput extends StatelessWidget {
  final DoublePropertyDescriptor descriptor;
  final VoidCallback onUpdate;
  const PropertyDoubleInput({super.key, required this.descriptor, required this.onUpdate});

  @override
  Widget build(BuildContext context) {
    return TextFormField(
      initialValue: descriptor.currentValue.toString(),
      decoration: InputDecoration(labelText: descriptor.label),
      keyboardType: const TextInputType.numberWithOptions(decimal: true),
      readOnly: descriptor.isReadOnly,
      onChanged: (value) {
        descriptor.updateValue(value);
        onUpdate();
      },
    );
  }
}

class PropertyStringInput extends StatelessWidget {
  final StringPropertyDescriptor descriptor;
  final VoidCallback onUpdate;
  const PropertyStringInput({super.key, required this.descriptor, required this.onUpdate});

  @override
  Widget build(BuildContext context) {
    return TextFormField(
      initialValue: descriptor.currentValue,
      decoration: InputDecoration(labelText: descriptor.label),
      readOnly: descriptor.isReadOnly,
      onChanged: (value) {
        descriptor.updateValue(value);
        onUpdate();
      },
    );
  }
}

class PropertyBoolSwitch extends StatelessWidget {
  final BoolPropertyDescriptor descriptor;
  final VoidCallback onUpdate;
  const PropertyBoolSwitch({super.key, required this.descriptor, required this.onUpdate});

  @override
  Widget build(BuildContext context) {
    return SwitchListTile(
      title: Text(descriptor.label),
      value: descriptor.currentValue,
      onChanged: descriptor.isReadOnly ? null : (value) {
        descriptor.updateValue(value);
        onUpdate();
      },
    );
  }
}

class PropertyImagePathInput extends ConsumerWidget {
  final ImagePathPropertyDescriptor descriptor;
  final VoidCallback onUpdate;
  final AssetData? imageAsset;
  final GlobalKey<TiledEditorWidgetState> editorKey;
  final Object parentObject;

  const PropertyImagePathInput({
    super.key,
    required this.descriptor,
    required this.onUpdate,
    required this.imageAsset,
    required this.editorKey,
    required this.parentObject,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final hasError = imageAsset?.hasError ?? false; 
    final theme = Theme.of(context);

    return ListTile(
      contentPadding: EdgeInsets.zero,
      title: Text(descriptor.label),
      subtitle: Text(
        descriptor.currentValue,
        style: TextStyle(color: hasError ? theme.colorScheme.error : null),
        overflow: TextOverflow.ellipsis,
      ),
      trailing: Icon(hasError ? Icons.error_outline : Icons.folder_open_outlined),
      onTap: () async {
        final newPath = await showDialog<String>(
          context: context,
          builder: (_) => const FileOrFolderPickerDialog(),
        );
        if (newPath != null && newPath != descriptor.currentValue) {
          await editorKey.currentState?.reloadImageSource(
            parentObject: parentObject,
            oldSourcePath: descriptor.currentValue,
            newProjectPath: newPath,
          );
          onUpdate();
        }
      },
    );
  }
}

class PropertyColorInput extends StatelessWidget {
  final ColorPropertyDescriptor descriptor;
  final VoidCallback onUpdate;

  const PropertyColorInput({super.key, required this.descriptor, required this.onUpdate});

  Color _parseColor(String? hex) {
    if (hex == null || hex.isEmpty) {
      return const Color(0x00000000);
    }
    var source = hex.replaceAll('#', '');
    if (source.length == 6) {
      source = 'ff$source';
    }
    try {
      return Color(int.parse(source, radix: 16));
    } catch (e) {
      return Colors.pink;
    }
  }

  String _formatColor(Color color) {
    return '#${color.value.toRadixString(16).padLeft(8, '0')}';
  }

  Future<void> _showColorPickerDialog(BuildContext context) async {
    final initialColor = _parseColor(descriptor.currentValue);
    Color pickerColor = initialColor;

    final result = await showDialog<dynamic>(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text('Select Color for ${descriptor.label}'),
          content: SingleChildScrollView(
            child: ColorPicker(
              color: pickerColor,
              onColorChanged: (Color color) => pickerColor = color,
              width: 40,
              height: 40,
              spacing: 5,
              runSpacing: 5,
              borderRadius: 4,
              wheelDiameter: 165,
              enableOpacity: true,
              showColorCode: true,
              colorCodeHasColor: true,
              pickersEnabled: const <ColorPickerType, bool>{
                ColorPickerType.both: false,
                ColorPickerType.primary: true,
                ColorPickerType.accent: true,
                ColorPickerType.bw: false,
                ColorPickerType.custom: true,
                ColorPickerType.wheel: true,
              },
            ),
          ),
          actions: <Widget>[
            TextButton(
              child: const Text('Clear'),
              onPressed: () => Navigator.of(context).pop('clear'),
            ),
            TextButton(
              child: const Text('Cancel'),
              onPressed: () => Navigator.of(context).pop(),
            ),
            FilledButton(
              child: const Text('OK'),
              onPressed: () => Navigator.of(context).pop(pickerColor),
            ),
          ],
        );
      },
    );

    if (result is Color) {
      descriptor.updateValue(_formatColor(result));
      onUpdate();
    } else if (result == 'clear') {
      descriptor.updateValue('');
      onUpdate();
    }
  }

  @override
  Widget build(BuildContext context) {
    final currentColor = _parseColor(descriptor.currentValue);
    final isNotSet = currentColor.alpha == 0 && descriptor.currentValue != '#00000000';

    return ListTile(
      contentPadding: EdgeInsets.zero,
      title: Text(descriptor.label),
      subtitle: isNotSet ? const Text('Not set') : null,
      trailing: Container(
        width: 40,
        height: 40,
        decoration: BoxDecoration(
          color: isNotSet ? Theme.of(context).scaffoldBackgroundColor : currentColor,
          shape: BoxShape.circle,
          border: Border.all(color: Theme.of(context).dividerColor),
        ),
        child: isNotSet 
            ? Center(child: Icon(Icons.close, size: 20, color: Theme.of(context).disabledColor))
            : null,
      ),
      onTap: descriptor.isReadOnly ? null : () => _showColorPickerDialog(context),
    );
  }
}

class PropertyEnumDropdown<T extends Enum> extends StatelessWidget {
  final EnumPropertyDescriptor<T> descriptor;
  final VoidCallback onUpdate;

  const PropertyEnumDropdown({super.key, required this.descriptor, required this.onUpdate});

  @override
  Widget build(BuildContext context) {
    return DropdownButtonFormField<T>(
      decoration: InputDecoration(labelText: descriptor.label),
      value: descriptor.currentValue,
      items: descriptor.allValues.map((T value) {
        return DropdownMenuItem<T>(
          value: value,
          child: Text(value.name),
        );
      }).toList(),
      onChanged: descriptor.isReadOnly ? null : (T? newValue) {
        if (newValue != null) {
          descriptor.updateValue(newValue);
          onUpdate();
        }
      },
    );
  }
}

class CustomPropertiesEditor extends StatefulWidget {
  final CustomPropertiesDescriptor descriptor;
  final VoidCallback onUpdate;

  const CustomPropertiesEditor({
    super.key,
    required this.descriptor,
    required this.onUpdate,
  });

  @override
  State<CustomPropertiesEditor> createState() => _CustomPropertiesEditorState();
}

class _CustomPropertiesEditorState extends State<CustomPropertiesEditor> {
  void _updateOrAddProperty(Map<String, dynamic> data) {
    final String name = data['name'];
    final PropertyType type = data['type'];
    final dynamic value = data['value'];

    Property<Object> newProperty;
    switch (type) {
      case PropertyType.bool:
        newProperty = BoolProperty(name: name, value: value as bool);
        break;
      case PropertyType.int:
        newProperty = IntProperty(name: name, value: value as int);
        break;
      case PropertyType.float:
        newProperty = FloatProperty(name: name, value: value as double);
        break;
      case PropertyType.color:
        final hexValue = value as String;
        newProperty = ColorProperty(
          name: name,
          value: colorDataFromHex(hexValue),
          hexValue: hexValue,
        );
        break;
      case PropertyType.string:
      default:
        newProperty = StringProperty(name: name, value: value as String);
        break;
    }

    final newPropertiesMap = Map<String, Property<Object>>.from(widget.descriptor.currentValue.byName);
    newPropertiesMap[name] = newProperty;
    widget.descriptor.updateValue(CustomProperties(newPropertiesMap));
    widget.onUpdate();
  }
  
  void _addProperty() async {
    final result = await showDialog<Map<String, dynamic>>(
      context: context,
      builder: (_) => const _AddPropertyDialog(),
    );

    if (result != null) {
      final String name = result['name'];
      if (widget.descriptor.currentValue.byName[name] == null) {
        _updateOrAddProperty(result);
      } else {
        MachineToast.error('A property with that name already exists.');
      }
    }
  }

  void _editProperty(Property property) async {
    final result = await showDialog<Map<String, dynamic>>(
      context: context,
      builder: (_) => _AddPropertyDialog(existingProperty: property),
    );

    if (result != null) {
      _updateOrAddProperty(result);
    }
  }

  void _removeProperty(String name) {
    final newPropertiesMap = Map<String, Property<Object>>.from(widget.descriptor.currentValue.byName);
    newPropertiesMap.remove(name);
    widget.descriptor.updateValue(CustomProperties(newPropertiesMap));
    widget.onUpdate();
  }

  @override
  Widget build(BuildContext context) {
    final properties = widget.descriptor.currentValue.toList();

    return ExpansionTile(
      title: Text(widget.descriptor.label),
      initiallyExpanded: false,
      children: [
        for (final prop in properties)
          ListTile(
            title: Text(prop.name),
            subtitle: Text('${prop.value} (${prop.type.name})'),
            trailing: IconButton(
              icon: const Icon(Icons.delete_outline, color: Colors.redAccent),
              onPressed: () => _removeProperty(prop.name),
            ),
            onTap: () => _editProperty(prop),
          ),
        ListTile(
          leading: const Icon(Icons.add),
          title: const Text('Add Property'),
          onTap: _addProperty,
        ),
      ],
    );
  }
}

class _AddPropertyDialog extends StatefulWidget {
  final Property? existingProperty;
  const _AddPropertyDialog({this.existingProperty});

  @override
  State<_AddPropertyDialog> createState() => _AddPropertyDialogState();
}

class _AddPropertyDialogState extends State<_AddPropertyDialog> {
  final _formKey = GlobalKey<FormState>();
  String _name = '';
  PropertyType _type = PropertyType.string;
  dynamic _value;
  bool get _isEditMode => widget.existingProperty != null;

  @override
  void initState() {
    super.initState();
    if (_isEditMode) {
      final prop = widget.existingProperty!;
      _name = prop.name;
      _type = prop.type;
      _value = prop is ColorProperty ? prop.hexValue : prop.value;
    } else {
      _value = _getDefaultValueForType(_type);
    }
  }

  dynamic _getDefaultValueForType(PropertyType type) {
    switch (type) {
      case PropertyType.bool:
        return false;
      case PropertyType.int:
        return 0;
      case PropertyType.float:
        return 0.0;
      case PropertyType.color:
        return '#FFFFFFFF';
      case PropertyType.string:
      default:
        return '';
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Add New Property'),
      content: Form(
        key: _formKey,
        child: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextFormField(
                initialValue: _name,
                decoration: const InputDecoration(labelText: 'Name'),
                autofocus: !_isEditMode,
                readOnly: _isEditMode,
                validator: (value) => value == null || value.isEmpty ? 'Name cannot be empty' : null,
                onSaved: (value) => _name = value!,
              ),
              DropdownButtonFormField<PropertyType>(
                value: _type,
                decoration: const InputDecoration(labelText: 'Type'),
                items: PropertyType.values
                    .where((t) => t != PropertyType.file && t != PropertyType.object)
                    .map((t) => DropdownMenuItem(value: t, child: Text(t.name)))
                    .toList(),
                onChanged: _isEditMode ? null : (value) {
                  if (value != null) {
                    setState(() {
                      _type = value;
                      _value = _getDefaultValueForType(value);
                    });
                  }
                },
              ),
              _buildValueEditor(),
            ],
          ),
        ),
      ),
      actions: [
        TextButton(onPressed: () => Navigator.pop(context), child: const Text('Cancel')),
        FilledButton(
          onPressed: () {
            if (_formKey.currentState!.validate()) {
              _formKey.currentState!.save();
              Navigator.pop(context, {'name': _name, 'type': _type, 'value': _value});
            }
          },
          child: const Text('Add'),
        ),
      ],
    );
  }

  Widget _buildValueEditor() {
    switch (_type) {
      case PropertyType.bool:
        return SwitchListTile(
          title: const Text('Value'),
          value: _value as bool,
          onChanged: (val) => setState(() => _value = val),
        );
      case PropertyType.int:
        return TextFormField(
          decoration: const InputDecoration(labelText: 'Value'),
          initialValue: _value.toString(),
          keyboardType: TextInputType.number,
          onSaved: (val) => _value = int.tryParse(val ?? '0') ?? 0,
        );
      case PropertyType.float:
        return TextFormField(
          decoration: const InputDecoration(labelText: 'Value'),
          initialValue: _value.toString(),
          keyboardType: const TextInputType.numberWithOptions(decimal: true),
          onSaved: (val) => _value = double.tryParse(val ?? '0.0') ?? 0.0,
        );
      case PropertyType.color:
      case PropertyType.string:
        return TextFormField(
          decoration: const InputDecoration(labelText: 'Value'),
          initialValue: _value.toString(),
          onSaved: (val) => _value = val ?? '',
        );
      default:
        return const SizedBox.shrink();
    }
  }
}

ColorData colorDataFromHex(String hex) {
  var source = hex.replaceAll('#', '');
  if (source.length == 6) {
    source = 'ff$source';
  }
  if (source.length == 8) {
    final val = int.parse(source, radix: 16);
    return ColorData.hex(val);
  }
  return const ColorData.argb(255, 0, 0, 0);
}

// FILE: lib/editor/plugins/tiled_editor/inspector/tiled_reflectors.dart

import 'package:tiled/tiled.dart';
import 'property_descriptors.dart';

ColorData colorDataFromHex(String hex) {
  var source = hex.replaceAll('#', '');
  if (source.length == 6) {
    source = 'ff$source';
  }
  if (source.length == 8) {
    final val = int.parse(source, radix: 16);
    return ColorData.hex(val);
  }
  return const ColorData.argb(255, 0, 0, 0);
}

extension on ColorData {
  String toHex({String prefix = '#', bool includeAlpha = true}) {
    final r = red.toRadixString(16).padLeft(2, '0');
    final g = green.toRadixString(16).padLeft(2, '0');
    final b = blue.toRadixString(16).padLeft(2, '0');
    if (includeAlpha) {
      final a = alpha.toRadixString(16).padLeft(2, '0');
      return '$prefix$a$r$g$b';
    }
    return '$prefix$r$g$b';
  }
}

class TiledReflector {
  static List<PropertyDescriptor> getDescriptors(Object? obj) {
    if (obj == null) return [];
    
    if (obj is TiledMap) return obj.getDescriptors();
    if (obj is Layer) return obj.getDescriptors(); 
    if (obj is Tileset) return obj.getDescriptors();
    if (obj is TiledObject) return obj.getDescriptors();
    if (obj is TiledImage) return obj.getDescriptors(null);

    return [];
  }
}


extension TiledMapReflector on TiledMap {
  List<PropertyDescriptor> getDescriptors() {
    return [
      EnumPropertyDescriptor<RenderOrder>(name: 'renderOrder', label: 'Render Order', getter: () => renderOrder, setter: (v) => renderOrder = v, allValues: RenderOrder.values),
      IntPropertyDescriptor(name: 'width', label: 'Width (tiles)', getter: () => width, setter: (v) => width = v),
      IntPropertyDescriptor(name: 'height', label: 'Height (tiles)', getter: () => height, setter: (v) => height = v),
      IntPropertyDescriptor(name: 'tileWidth', label: 'Tile Width (px)', getter: () => tileWidth, setter: (v) => tileWidth = v),
      IntPropertyDescriptor(name: 'tileHeight', label: 'Tile Height (px)', getter: () => tileHeight, setter: (v) => tileHeight = v),
      ColorPropertyDescriptor(name: 'backgroundColor', label: 'Background Color', getter: () => backgroundColorHex, setter: (v) => backgroundColorHex = v),
      
      FileListPropertyDescriptor(
        name: 'tp_atlases', 
        label: 'Linked Atlases (.tpacker)', 
        getter: () {
          final prop = properties['tp_atlases'];
          if (prop is StringProperty) {
            return prop.value.split(',').map((e) => e.trim()).where((e) => e.isNotEmpty).toList();
          }
          return [];
        }, 
        setter: (List<String> files) {
          properties.byName['tp_atlases'] = StringProperty(name: 'tp_atlases', value: files.join(','));
        }
      ),

      CustomPropertiesDescriptor(name: 'properties', label: 'Custom Properties', getter: () => properties, setter: (v) => properties = v),
    ];
  }
}

extension LayerReflector on Layer {
  List<PropertyDescriptor> getDescriptors() {
    final common = [
      IntPropertyDescriptor(name: 'id', label: 'ID', getter: () => id ?? 0, setter: (v) {}, isReadOnly: true),
      StringPropertyDescriptor(name: 'name', label: 'Name', getter: () => name, setter: (v) => name = v),
      StringPropertyDescriptor(name: 'class', label: 'Class', getter: () => class_ ?? '', setter: (v) => class_ = v),
      DoublePropertyDescriptor(name: 'offsetX', label: 'Offset X', getter: () => offsetX, setter: (v) => offsetX = v),
      DoublePropertyDescriptor(name: 'offsetY', label: 'Offset Y', getter: () => offsetY, setter: (v) => offsetY = v),
      DoublePropertyDescriptor(name: 'opacity', label: 'Opacity', getter: () => opacity, setter: (v) => opacity = v.clamp(0.0, 1.0)),
      BoolPropertyDescriptor(name: 'visible', label: 'Visible', getter: () => visible, setter: (v) => visible = v),
      ColorPropertyDescriptor(name: 'tintColor', label: 'Tint Color', getter: () => tintColorHex, setter: (v) => tintColorHex = v),
      DoublePropertyDescriptor(name: 'parallaxX', label: 'Parallax X', getter: () => parallaxX, setter: (v) => parallaxX = v),
      DoublePropertyDescriptor(name: 'parallaxY', label: 'Parallax Y', getter: () => parallaxY, setter: (v) => parallaxY = v),
    ];

    final layer = this;
    if (layer is ObjectGroup) {
      common.addAll([
        EnumPropertyDescriptor<DrawOrder>(name: 'drawOrder', label: 'Draw Order', getter: () => layer.drawOrder ?? DrawOrder.topDown, setter: (v) => layer.drawOrder = v, allValues: DrawOrder.values),
        ColorPropertyDescriptor(name: 'color', label: 'Display Color', getter: () => layer.color?.toHex(prefix: '#', includeAlpha: true), setter: (v) => layer.color = colorDataFromHex(v)),
      ]);
    } else if (layer is ImageLayer) {
      common.addAll([
        BoolPropertyDescriptor(name: 'repeatX', label: 'Repeat X', getter: () => layer.repeatX, setter: (v) => layer.repeatX = v),
        BoolPropertyDescriptor(name: 'repeatY', label: 'Repeat Y', getter: () => layer.repeatY, setter: (v) => layer.repeatY = v),
        ObjectPropertyDescriptor(name: 'image', label: 'Image', getter: () => layer.image, target: layer),
      ]);
    }
    
    common.add(CustomPropertiesDescriptor(name: 'properties', label: 'Custom Properties', getter: () => properties, setter: (v) => properties = v));
    return common;
  }
}

extension TilesetReflector on Tileset {
  List<PropertyDescriptor> getDescriptors() {
    return [
      StringPropertyDescriptor(name: 'name', label: 'Name', getter: () => name ?? '', setter: (v) => name = v),
      IntPropertyDescriptor(name: 'tileWidth', label: 'Tile Width', getter: () => tileWidth ?? 0, setter: (v) => tileWidth = v),
      IntPropertyDescriptor(name: 'tileHeight', label: 'Tile Height', getter: () => tileHeight ?? 0, setter: (v) => tileHeight = v),
      IntPropertyDescriptor(name: 'spacing', label: 'Spacing', getter: () => spacing, setter: (v) => spacing = v),
      IntPropertyDescriptor(name: 'margin', label: 'Margin', getter: () => margin, setter: (v) => margin = v),
      EnumPropertyDescriptor<ObjectAlignment>(name: 'objectAlignment', label: 'Object Alignment', getter: () => objectAlignment, setter: (v) => objectAlignment = v, allValues: ObjectAlignment.values),
      ObjectPropertyDescriptor(name: 'image', label: 'Image', getter: () => image, target: this),
      CustomPropertiesDescriptor(name: 'properties', label: 'Custom Properties', getter: () => properties, setter: (v) => properties = v),
    ];
  }
}

extension TiledObjectReflector on TiledObject {
  List<PropertyDescriptor> getDescriptors() {
    final descriptors = <PropertyDescriptor>[
      IntPropertyDescriptor(name: 'id', label: 'ID', getter: () => id, setter: (v) {}, isReadOnly: true),
      StringPropertyDescriptor(name: 'name', label: 'Name', getter: () => name, setter: (v) => name = v),
      StringPropertyDescriptor(name: 'type', label: 'Type', getter: () => type, setter: (v) => type = v),
      StringPropertyDescriptor(name: 'class', label: 'Class', getter: () => class_, setter: (v) {}, isReadOnly: true),
      BoolPropertyDescriptor(name: 'visible', label: 'Visible', getter: () => visible, setter: (v) => visible = v),
      DoublePropertyDescriptor(name: 'x', label: 'X', getter: () => x, setter: (v) => x = v),
      DoublePropertyDescriptor(name: 'y', label: 'Y', getter: () => y, setter: (v) => y = v),
      DoublePropertyDescriptor(name: 'width', label: 'Width', getter: () => width, setter: (v) => width = v),
      DoublePropertyDescriptor(name: 'height', label: 'Height', getter: () => height, setter: (v) => height = v),
      DoublePropertyDescriptor(name: 'rotation', label: 'Rotation', getter: () => rotation, setter: (v) => rotation = v),
      IntPropertyDescriptor(name: 'gid', label: 'GID (Tile)', getter: () => gid ?? 0, setter: (v) => gid = v > 0 ? v : null),
      
      SpriteReferencePropertyDescriptor(
        name: 'tp_sprite',
        label: 'Texture Packer Sprite',
        getter: () {
          final prop = properties['tp_sprite'];
          return (prop is StringProperty) ? prop.value : '';
        },
        setter: (val) {
          if (val.isEmpty) {
            properties.byName.remove('tp_sprite');
          } else {
            properties.byName['tp_sprite'] = StringProperty(name: 'tp_sprite', value: val);
          }
        },
      ),

      CustomPropertiesDescriptor(name: 'properties', label: 'Custom Properties', getter: () => properties, setter: (v) => properties = v),
    ];

    if (isPolygon) {
      descriptors.add(StringPropertyDescriptor(name: 'polygon', label: 'Polygon Points', getter: () => polygon.map((p) => '${p.x},${p.y}').join(' '), setter: (v) {}, isReadOnly: true));
    }
    if (isPolyline) {
      descriptors.add(StringPropertyDescriptor(name: 'polyline', label: 'Polyline Points', getter: () => polyline.map((p) => '${p.x},${p.y}').join(' '), setter: (v) {}, isReadOnly: true));
    }

    if (text != null) {
      final txt = text!;
      descriptors.addAll([
        StringPropertyDescriptor(name: 'text_content', label: 'Text Content', getter: () => txt.text, setter: (v) => txt.text = v),
        StringPropertyDescriptor(name: 'fontfamily', label: 'Font Family', getter: () => txt.fontFamily, setter: (v) => txt.fontFamily = v),
        IntPropertyDescriptor(name: 'pixelsize', label: 'Pixel Size', getter: () => txt.pixelSize, setter: (v) => txt.pixelSize = v),
        ColorPropertyDescriptor(name: 'color', label: 'Text Color', getter: () => txt.color, setter: (v) => txt.color = v),
        BoolPropertyDescriptor(name: 'wrap', label: 'Word Wrap', getter: () => txt.wrap, setter: (v) => txt.wrap = v),
        BoolPropertyDescriptor(name: 'bold', label: 'Bold', getter: () => txt.bold, setter: (v) => txt.bold = v),
        BoolPropertyDescriptor(name: 'italic', label: 'Italic', getter: () => txt.italic, setter: (v) => txt.italic = v),
        BoolPropertyDescriptor(name: 'underline', label: 'Underline', getter: () => txt.underline, setter: (v) => txt.underline = v),
        BoolPropertyDescriptor(name: 'strikeout', label: 'Strikeout', getter: () => txt.strikeout, setter: (v) => txt.strikeout = v),
        BoolPropertyDescriptor(name: 'kerning', label: 'Kerning', getter: () => txt.kerning, setter: (v) => txt.kerning = v),
        EnumPropertyDescriptor<HAlign>(name: 'halign', label: 'Horizontal Align', getter: () => txt.hAlign, setter: (v) => txt.hAlign = v, allValues: HAlign.values),
        EnumPropertyDescriptor<VAlign>(name: 'valign', label: 'Vertical Align', getter: () => txt.vAlign, setter: (v) => txt.vAlign = v, allValues: VAlign.values),
      ]);
    }
    
    return descriptors;
  }
}

extension TiledImageReflector on TiledImage {
  List<PropertyDescriptor> getDescriptors(Object? parent) {
     return [
      ImagePathPropertyDescriptor(
        name: 'source',
        label: 'Source',
        getter: () => source ?? '',
        setter: (v) {},
      ),
      IntPropertyDescriptor(name: 'width', label: 'Width', getter: () => width ?? 0, setter: (v) {}, isReadOnly: true),
      IntPropertyDescriptor(name: 'height', label: 'Height', getter: () => height ?? 0, setter: (v) {}, isReadOnly: true),
    ];
  }
}

// FILE: lib/editor/plugins/tiled_editor/project_tsx_provider.dart

import 'dart:async';
import 'package:tiled/tiled.dart' hide Text;
import 'package:xml/xml.dart';

import '../../../data/repositories/project/project_repository.dart';

class ProjectTsxProvider extends TsxProvider {
  final ProjectRepository repo;
  final String parentUri;
  final Map<String, Parser> _cache = {};

  @override
  final String filename;

  ProjectTsxProvider(this.repo, this.parentUri, [this.filename = '']);

  @override
  Future<TsxProvider> getProvider(String path) async {
    final tsxFile = await repo.fileHandler.resolvePath(parentUri, path);
    if (tsxFile == null) {
      throw Exception(
        'External tileset not found: $path (relative to $parentUri)',
      );
    }

    final newParentUri = repo.fileHandler.getParentUri(tsxFile.uri);
    final content = await repo.readFile(tsxFile.uri);

    final newProvider = ProjectTsxProvider(repo, newParentUri, tsxFile.name);
    newProvider._cache[tsxFile.name] = XmlParser(
      XmlDocument.parse(content).rootElement,
    );

    return newProvider;
  }

  @override
  Parser? getCachedSource() => _cache[filename];

  @override
  Parser getSource(String filename) {
    if (_cache.containsKey(filename)) {
      return _cache[filename]!;
    }
    throw Exception('TSX source was not pre-loaded: $filename');
  }

  static Future<List<TsxProvider>> parseFromTmx(
    String tmxString,
    Future<TsxProvider> Function(String key) tsxProviderFunction,
  ) async {
    final tsxSourcePaths = XmlDocument.parse(tmxString).rootElement.children
        .whereType<XmlElement>()
        .where((element) => element.name.local == 'tileset')
        .map((e) => e.getAttribute('source'));

    return await Future.wait(
      tsxSourcePaths
          .where((key) => key != null)
          .map((key) async => tsxProviderFunction(key!)),
    );
  }
}


// FILE: lib/editor/plugins/tiled_editor/tiled_asset_resolver.dart

// FILE: lib/editor/plugins/tiled_editor/tiled_asset_resolver.dart

import 'dart:ui' as ui;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:tiled/tiled.dart';
import 'package:machine/asset_cache/asset_models.dart';
import 'package:machine/asset_cache/asset_providers.dart';
import 'package:machine/data/repositories/project/project_repository.dart';
import 'package:machine/editor/tab_metadata_notifier.dart';
import 'package:machine/app/app_notifier.dart';
import '../../../project/project_settings_notifier.dart';

class TiledAssetResolver {
  final Map<String, AssetData> _assets;
  final ProjectRepository _repo;
  final String _tmxPath;

  TiledAssetResolver(this._assets, this._repo, this._tmxPath);

  Map<String, AssetData> get rawAssets => _assets;
  
  /// Exposes the path of the current TMX file.
  String get tmxPath => _tmxPath;

  ProjectRepository get repo => _repo;

  /// to the map (embedded tileset) or an external TSX file.
  ui.Image? getImage(String? source, {Tileset? tileset}) {
    if (source == null || source.isEmpty) return null;

    String contextPath = _tmxPath;

    // to that TSX file, not the TMX.
    if (tileset?.source != null) {
      contextPath = _repo.resolveRelativePath(_tmxPath, tileset!.source!);
    }

    final canonicalKey = _repo.resolveRelativePath(contextPath, source);
    final asset = _assets[canonicalKey];

    if (asset is ImageAssetData) {
      return asset.image;
    }
    return null;
  }

  AssetData? getAsset(String canonicalKey) => _assets[canonicalKey];
}

final tiledAssetResolverProvider = Provider.family.autoDispose<AsyncValue<TiledAssetResolver>, String>((ref, tabId) {
  final assetMapAsync = ref.watch(assetMapProvider(tabId));
  final repo = ref.watch(projectRepositoryProvider);
  final project = ref.watch(currentProjectProvider);
  final metadata = ref.watch(tabMetadataProvider)[tabId];

  return assetMapAsync.whenData((assetMap) {
    if (repo == null || project == null || metadata == null) {
      throw Exception("Project context not available");
    }
    
    final tmxPath = repo.fileHandler.getPathForDisplay(metadata.file.uri, relativeTo: project.rootUri);
    return TiledAssetResolver(assetMap, repo, tmxPath);
  });
});

// FILE: lib/editor/plugins/tiled_editor/tiled_command_context.dart


import 'package:flutter/material.dart';

import '../../models/editor_command_context.dart';
import 'package:meta/meta.dart';
import 'tiled_paint_tools.dart';

@immutable
class TiledEditorCommandContext extends CommandContext {
  final TiledEditorMode mode;
  final bool isGridVisible;
  final bool canUndo;
  final bool canRedo;
  final bool isSnapToGridEnabled;
  final bool isPaletteVisible;
  final bool isLayersPanelVisible;

  final TiledPaintMode paintMode;
  final ObjectTool activeObjectTool;
  final bool hasPolygonPoints;
  final bool isObjectSelected;
  final bool hasFloatingTileSelection;

  const TiledEditorCommandContext({
    required this.mode,
    required this.isGridVisible,
    required this.canUndo,
    required this.canRedo,
    required this.isSnapToGridEnabled,
    required this.isPaletteVisible,
    required this.isLayersPanelVisible,
    required this.paintMode,
    required this.activeObjectTool,
    required this.hasPolygonPoints,
    required this.isObjectSelected,
    required this.hasFloatingTileSelection,
    super.appBarOverride,
    super.appBarOverrideKey,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      super == other &&
          other is TiledEditorCommandContext &&
          runtimeType == other.runtimeType &&
          mode == other.mode &&
          isGridVisible == other.isGridVisible &&
          canUndo == other.canUndo &&
          canRedo == other.canRedo &&
          isSnapToGridEnabled == other.isSnapToGridEnabled &&
          isPaletteVisible == other.isPaletteVisible &&
          isLayersPanelVisible == other.isLayersPanelVisible &&
          paintMode == other.paintMode &&
          activeObjectTool == other.activeObjectTool &&
          hasPolygonPoints == other.hasPolygonPoints &&
          isObjectSelected == other.isObjectSelected &&
          hasFloatingTileSelection == other.hasFloatingTileSelection;

  @override
  int get hashCode =>
      super.hashCode ^
      mode.hashCode ^
      isGridVisible.hashCode ^
      canUndo.hashCode ^
      canRedo.hashCode ^
      isSnapToGridEnabled.hashCode ^
      isPaletteVisible.hashCode ^
      isLayersPanelVisible.hashCode ^
      paintMode.hashCode ^
      activeObjectTool.hashCode ^
      hasPolygonPoints.hashCode ^
      isObjectSelected.hashCode ^
      hasFloatingTileSelection.hashCode;
}

// FILE: lib/editor/plugins/tiled_editor/tiled_editor_models.dart


import 'package:flutter/material.dart';
import '../../models/editor_tab_models.dart';
import 'tiled_editor_widget.dart';

@immutable
class TiledEditorTab extends EditorTab {
  @override
  final GlobalKey<TiledEditorWidgetState> editorKey;

  final String initialTmxContent;
  final String initialBaseContentHash;

  TiledEditorTab({
    required super.plugin,
    required this.initialTmxContent,
    required this.initialBaseContentHash,
    super.id,
    super.onReadyCompleter,
  }) : editorKey = GlobalKey<TiledEditorWidgetState>();

  @override
  void dispose() {
  }
}


// FILE: lib/editor/plugins/tiled_editor/tiled_editor_plugin.dart

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../app/app_notifier.dart';
import '../../../command/command_models.dart';
import '../../../data/cache/type_adapters.dart';
import '../../../data/file_handler/file_handler.dart';
import '../../models/editor_command_context.dart';
import '../../models/editor_plugin_models.dart';
import '../../models/editor_tab_models.dart';
import '../../services/editor_service.dart';
import '../../tab_metadata_notifier.dart';

import 'tiled_command_context.dart';
import 'tiled_editor_models.dart';
import 'tiled_editor_widget.dart';
import '../../../command/command_widgets.dart';
import 'tiled_paint_tools.dart';
import 'widgets/tiled_editor_settings_widget.dart';
import 'tiled_editor_settings_model.dart';
import 'widgets/export_dialog.dart';
import '../../../logs/logs_provider.dart';

class TiledEditorPlugin extends EditorPlugin {
  static const String pluginId = 'com.machine.tiled_editor';

  static const tiledFloatingToolbar = CommandPosition(
    id: 'tiled_floating_toolbar',
    label: 'Tiled Floating Toolbar',
    icon: Icons.grid_on_outlined,
  );

  static const paintToolsToolbar = CommandPosition(
    id: 'tiled_paint_tools',
    label: 'Tiled Paint Tools',
    icon: Icons.brush,
  );

  static const objectToolsToolbar = CommandPosition(
    id: 'tiled_object_tools',
    label: 'Tiled Object Tools',
    icon: Icons.category_outlined,
  );
  
  @override
  String get id => pluginId;

  @override
  String get name => 'Tiled Map Editor';

  @override
  Widget get icon => const Icon(Icons.grid_on_outlined);

  @override
  int get priority => 5;

  @override
  PluginDataRequirement get dataRequirement => PluginDataRequirement.string;

  @override
  bool supportsFile(DocumentFile file) {
    return file.name.toLowerCase().endsWith('.tmx');
  }
  
  @override
  PluginSettings? get settings => TiledEditorSettings();

  @override
  Widget buildSettingsUI(
    PluginSettings settings,
    void Function(PluginSettings) onChanged,
  ) =>
      TiledEditorSettingsWidget(settings: settings as TiledEditorSettings, onChanged: onChanged);

  @override
  Future<EditorTab> createTab(
    DocumentFile file,
    EditorInitData initData, {
    String? id,
    Completer<EditorWidgetState>? onReadyCompleter,
  }) async {
    var tmxContent = (initData.initialContent as EditorContentString).content;
    var baseContentHash = initData.baseContentHash;
    if (tmxContent.trim().isEmpty) {
      tmxContent = _createDefaultTmx();
      baseContentHash = "new_map";
    }
    return TiledEditorTab(
      plugin: this,
      initialTmxContent: tmxContent,
      initialBaseContentHash: baseContentHash,
      id: id,
      onReadyCompleter: onReadyCompleter,
    );
  }

  String _createDefaultTmx() {
    return '''
<?xml version="1.0" encoding="UTF-8"?>
<map version="1.10" tiledversion="1.10.2" orientation="orthogonal" renderorder="right-down" width="10" height="10" tilewidth="16" tileheight="16" infinite="0" nextlayerid="2" nextobjectid="1">
</map>
''';
  }

  @override
  EditorWidget buildEditor(EditorTab tab, WidgetRef ref) {
    return TiledEditorWidget(key: (tab as TiledEditorTab).editorKey, tab: tab);
  }

  @override
  Widget buildToolbar(WidgetRef ref) {
    return const BottomToolbar();
  }

  @override
  List<CommandPosition> getCommandPositions() =>
      [tiledFloatingToolbar, paintToolsToolbar, objectToolsToolbar];

  TiledEditorWidgetState? _getEditorState(WidgetRef ref) {
    final tab =
        ref.read(appNotifierProvider).value?.currentProject?.session.currentTab;
    if (tab is TiledEditorTab) {
      return tab.editorKey.currentState as TiledEditorWidgetState?;
    }
    return null;
  }
  
    List<CommandGroup> getCommandGroups() {
    const objectToolIcons = {
      ObjectTool.select: Icons.touch_app_outlined,
      ObjectTool.move: Icons.open_with_outlined,
      ObjectTool.addRectangle: Icons.rectangle_outlined,
      ObjectTool.addEllipse: Icons.circle_outlined,
      ObjectTool.addPoint: Icons.add_location_alt_outlined,
      ObjectTool.addPolygon: Icons.pentagon_outlined,
      ObjectTool.addPolyline: Icons.polyline_outlined,
      ObjectTool.addText: Icons.text_fields_outlined,
      ObjectTool.addSprite: Icons.image_search,
    };

    return [
      CommandGroup(
        id: 'tiled_object_tools_group',
        label: 'Object Tools',
        showLabels: false, 
        defaultPositions: [objectToolsToolbar], 
        icon: Consumer(
          builder: (context, ref, _) {
            final ctx = ref.watch(activeCommandContextProvider);
            
            var activeToolIcon = objectToolIcons[ObjectTool.select]!;

            if (ctx is TiledEditorCommandContext && ctx.mode == TiledEditorMode.object) {
              activeToolIcon = objectToolIcons[ctx.activeObjectTool] ?? activeToolIcon;
            }
            
            return Icon(activeToolIcon);
          },
        ),
commandIds: ObjectTool.values
            .where((e) => e != ObjectTool.select)
            .where((e) => e != ObjectTool.move)
            .map((tool) => 'tiled_object_tool_${tool.name}')
            .toList(),
        isDeletable: false,
        sourcePlugin: id,
      ),
    ];
  }

  @override
  List<Command> getCommands(){
    const objectToolIcons = {
      ObjectTool.select: Icons.touch_app_outlined,
      ObjectTool.move: Icons.open_with_outlined,
      ObjectTool.addRectangle: Icons.rectangle_outlined,
      ObjectTool.addEllipse: Icons.circle_outlined,
      ObjectTool.addPoint: Icons.add_location_alt_outlined,
      ObjectTool.addPolygon: Icons.pentagon_outlined,
      ObjectTool.addPolyline: Icons.polyline_outlined,
      ObjectTool.addText: Icons.text_fields_outlined,
       ObjectTool.addSprite: Icons.image_search,
    };
    
    const objectToolLabels = {
      ObjectTool.select: 'Select',
      ObjectTool.move: 'Move',
      ObjectTool.addRectangle: 'Add Rectangle',
      ObjectTool.addEllipse: 'Add Ellipse',
      ObjectTool.addPoint: 'Add Point',
      ObjectTool.addPolygon: 'Add Polygon',
      ObjectTool.addPolyline: 'Add Polyline',
      ObjectTool.addText: 'Add Text',      
      ObjectTool.addSprite: 'Add Sprite',
    };


    final objectToolCommands = ObjectTool.values.map((tool) {
      return BaseCommand(
        id: 'tiled_object_tool_${tool.name}',
        label: objectToolLabels[tool] ?? tool.name,
        icon: Consumer(builder: (context, ref, _) {
          final ctx = ref.watch(activeCommandContextProvider);
          final isActive =
              ctx is TiledEditorCommandContext && ctx.activeObjectTool == tool;
          return Icon(objectToolIcons[tool],
              color: isActive ? Theme.of(context).colorScheme.primary : null);
        }),
        defaultPositions: [objectToolsToolbar],
        sourcePlugin: id,
        execute: (ref) async => _getEditorState(ref)?.setActiveObjectTool(tool),
          canExecute: (ref) {
            final ctx = ref.watch(activeCommandContextProvider);
            return ctx is TiledEditorCommandContext && ctx.mode == TiledEditorMode.object;
          },
      );
    }).toList();

    return [
      ...objectToolCommands,
        BaseCommand(
          id: 'tiled_toggle_pan_zoom_mode',
          label: 'Pan/Zoom',
          icon: Consumer(builder: (context, ref, _) {
            final ctx = ref.watch(activeCommandContextProvider);
            final isActive = ctx is TiledEditorCommandContext &&
                ctx.mode == TiledEditorMode.panZoom;
            return Icon(Icons.pan_tool_outlined,
                color:
                    isActive ? Theme.of(context).colorScheme.primary : null);
          }),
          defaultPositions: [tiledFloatingToolbar],
          sourcePlugin: id,
          execute: (ref) async =>
              _getEditorState(ref)?.setMode(TiledEditorMode.panZoom),
        ),
        BaseCommand(
          id: 'tiled_toggle_paint_mode',
          label: 'Paint Mode',
          icon: Consumer(builder: (context, ref, _) {
            final ctx = ref.watch(activeCommandContextProvider);
            final isActive = ctx is TiledEditorCommandContext &&
                ctx.mode == TiledEditorMode.paint;
            return Icon(Icons.brush,
                color:
                    isActive ? Theme.of(context).colorScheme.primary : null);
          }),
          defaultPositions: [tiledFloatingToolbar],
          sourcePlugin: id,
          execute: (ref) async =>
              _getEditorState(ref)?.setMode(TiledEditorMode.paint),
        ),
        BaseCommand(
          id: 'tiled_toggle_object_mode',
          label: 'Object Mode',
          icon: Consumer(builder: (context, ref, _) {
            final ctx = ref.watch(activeCommandContextProvider);
            final isActive = ctx is TiledEditorCommandContext &&
                ctx.mode == TiledEditorMode.object;
            return Icon(Icons.category_outlined,
                color:
                    isActive ? Theme.of(context).colorScheme.primary : null);
          }),
          defaultPositions: [tiledFloatingToolbar],
          sourcePlugin: id,
          execute: (ref) async =>
              _getEditorState(ref)?.setMode(TiledEditorMode.object),
        ),
        BaseCommand(
          id: 'tiled_undo',
          label: 'Undo',
          icon: const Icon(Icons.undo),
          defaultPositions: [AppCommandPositions.pluginToolbar],
          sourcePlugin: id,
          execute: (ref) async => _getEditorState(ref)?.undo(),
          canExecute: (ref) {
            final ctx = ref.watch(activeCommandContextProvider);
            return ctx is TiledEditorCommandContext && ctx.canUndo;
          },
        ),
        BaseCommand(
          id: 'tiled_redo',
          label: 'Redo',
          icon: const Icon(Icons.redo),
          defaultPositions: [AppCommandPositions.pluginToolbar],
          sourcePlugin: id,
          execute: (ref) async => _getEditorState(ref)?.redo(),
          canExecute: (ref) {
            final ctx = ref.watch(activeCommandContextProvider);
            return ctx is TiledEditorCommandContext && ctx.canRedo;
          },
        ),
        BaseCommand(
          id: 'tiled_map_properties',
          label: 'Map Properties',
          icon: const Icon(Icons.settings_overscan),
          defaultPositions: [AppCommandPositions.pluginToolbar],
          sourcePlugin: id,
          execute: (ref) async => _getEditorState(ref)?.inspectMapProperties(),
        ),
        BaseCommand(
          id: 'tiled_toggle_layers_panel',
          label: 'Toggle Layers',
          icon: Consumer(
            builder: (context, ref, _) {
              final ctx = ref.watch(activeCommandContextProvider);
              final isActive =
                  ctx is TiledEditorCommandContext && ctx.isLayersPanelVisible;
              return Icon(
                Icons.layers_outlined,
                color: isActive ? Theme.of(context).colorScheme.primary : null,
              );
            },
          ),
          defaultPositions: [AppCommandPositions.pluginToolbar],
          sourcePlugin: id,
          execute: (ref) async => _getEditorState(ref)?.toggleLayersPanel(),
        ),
        BaseCommand(
          id: 'tiled_toggle_grid',
          label: 'Toggle Grid',
          icon: Consumer(
            builder: (context, ref, _) {
              final ctx = ref.watch(activeCommandContextProvider);
              final isActive =
                  ctx is TiledEditorCommandContext && ctx.isGridVisible;
              return Icon(
                Icons.grid_on,
                color: isActive ? Theme.of(context).colorScheme.primary : null,
              );
            },
          ),
          defaultPositions: [tiledFloatingToolbar],
          sourcePlugin: id,
          execute: (ref) async => _getEditorState(ref)?.toggleGrid(),
        ),
        BaseCommand(
          id: 'tiled_subtool_paint',
          label: 'Paint Brush',
          icon: Consumer(
            builder: (context, ref, _) {
              final ctx = ref.watch(activeCommandContextProvider);
              final isActive = ctx is TiledEditorCommandContext &&
                  ctx.paintMode == TiledPaintMode.paint;
              return Icon(
                Icons.brush,
                color: isActive ? Theme.of(context).colorScheme.primary : null,
              );
            },
          ),
          defaultPositions: [paintToolsToolbar],
          sourcePlugin: id,
          execute: (ref) async =>
              _getEditorState(ref)?.setPaintMode(TiledPaintMode.paint),
          canExecute: (ref) {
            final ctx = ref.watch(activeCommandContextProvider);
            return ctx is TiledEditorCommandContext && ctx.mode == TiledEditorMode.paint;
          },
        ),
        BaseCommand(
          id: 'tiled_subtool_fill',
          label: 'Bucket Fill',
          icon: Consumer(
            builder: (context, ref, _) {
              final ctx = ref.watch(activeCommandContextProvider);
              final isActive = ctx is TiledEditorCommandContext &&
                  ctx.paintMode == TiledPaintMode.fill;
              return Icon(
                Icons.format_color_fill,
                color: isActive ? Theme.of(context).colorScheme.primary : null,
              );
            },
          ),
          defaultPositions: [paintToolsToolbar],
          sourcePlugin: id,
          execute: (ref) async =>
              _getEditorState(ref)?.setPaintMode(TiledPaintMode.fill),
          canExecute: (ref) {
            final ctx = ref.watch(activeCommandContextProvider);
            return ctx is TiledEditorCommandContext && ctx.mode == TiledEditorMode.paint;
          },
        ),
        BaseCommand(
          id: 'tiled_subtool_erase',
          label: 'Erase',
          icon: Consumer(
            builder: (context, ref, _) {
              final ctx = ref.watch(activeCommandContextProvider);
              final isActive = ctx is TiledEditorCommandContext &&
                  ctx.paintMode == TiledPaintMode.erase;
              return Icon(
                Icons.rectangle_outlined,
                color: isActive ? Theme.of(context).colorScheme.primary : null,
              );
            },
          ),
          defaultPositions: [paintToolsToolbar],
          sourcePlugin: id,
          execute: (ref) async =>
              _getEditorState(ref)?.setPaintMode(TiledPaintMode.erase),
          canExecute: (ref) {
            final ctx = ref.watch(activeCommandContextProvider);
            return ctx is TiledEditorCommandContext && ctx.mode == TiledEditorMode.paint;
          },
        ),
        BaseCommand(
          id: 'tiled_subtool_select',
          label: 'Select Tiles',
          icon: Consumer(
            builder: (context, ref, _) {
              final ctx = ref.watch(activeCommandContextProvider);
              final isActive = ctx is TiledEditorCommandContext &&
                  ctx.paintMode == TiledPaintMode.select;
              return Icon(
                Icons.select_all,
                color: isActive ? Theme.of(context).colorScheme.primary : null,
              );
            },
          ),
          defaultPositions: [paintToolsToolbar],
          sourcePlugin: id,
          execute: (ref) async =>
              _getEditorState(ref)?.setPaintMode(TiledPaintMode.select),
          canExecute: (ref) {
            final ctx = ref.watch(activeCommandContextProvider);
            return ctx is TiledEditorCommandContext && ctx.mode == TiledEditorMode.paint;
          },
        ),
        BaseCommand(
          id: 'tiled_subtool_move_selection',
          label: 'Move Selection',
          icon: Consumer(
            builder: (context, ref, _) {
              final ctx = ref.watch(activeCommandContextProvider);
              final isActive = ctx is TiledEditorCommandContext &&
                  ctx.paintMode == TiledPaintMode.move;
              return Icon(
                Icons.open_with,
                color: isActive ? Theme.of(context).colorScheme.primary : null,
              );
            },
          ),
          defaultPositions: [paintToolsToolbar],
          sourcePlugin: id,
          execute: (ref) async =>
              _getEditorState(ref)?.setPaintMode(TiledPaintMode.move),
          canExecute: (ref) {
            final ctx = ref.watch(activeCommandContextProvider);
            return ctx is TiledEditorCommandContext &&
                ctx.mode == TiledEditorMode.paint &&
                ctx.hasFloatingTileSelection;
          },
        ),
        BaseCommand(
          id: 'tiled_delete_selection',
          label: 'Delete Selection',
          icon: const Icon(Icons.delete_outline, color: Colors.redAccent),
          defaultPositions: [paintToolsToolbar],
          sourcePlugin: id,
          execute: (ref) async {
            _getEditorState(ref)?.notifier?.deleteFloatingSelection();
          },
          canExecute: (ref) {
            final ctx = ref.watch(activeCommandContextProvider);
            return ctx is TiledEditorCommandContext && ctx.hasFloatingTileSelection;
          },
        ),
        BaseCommand(
          id: 'tiled_reset_view',
          label: 'Reset View',
          icon: const Icon(Icons.filter_center_focus),
          defaultPositions: [tiledFloatingToolbar],
          sourcePlugin: id,
          execute: (ref) async => _getEditorState(ref)?.resetView(),
        ),
        BaseCommand(
          id: 'tiled_toggle_palette',
          label: 'Toggle Palette',
          icon: Consumer(
            builder: (context, ref, _) {
              final ctx = ref.watch(activeCommandContextProvider);
              final isActive =
                  ctx is TiledEditorCommandContext && ctx.isPaletteVisible;
              return Icon(
                Icons.palette_outlined,
                color: isActive ? Theme.of(context).colorScheme.primary : null,
              );
            },
          ),
          defaultPositions: [AppCommandPositions.pluginToolbar],
          sourcePlugin: id,
          execute: (ref) async => _getEditorState(ref)?.togglePalette(),
        ),
        BaseCommand(
          id: 'save_tmx',
          label: 'Save Map',
          icon: const Icon(Icons.save),
          defaultPositions: [AppCommandPositions.appBar],
          sourcePlugin: id,
          execute: (ref) async => ref.read(editorServiceProvider).saveCurrentTab(),
          canExecute: (ref) {
            final tabId = ref.watch(
              appNotifierProvider.select(
                (s) => s.value?.currentProject?.session.currentTab?.id,
              ),
            );
            if (tabId == null) return false;
            return ref
                    .watch(tabMetadataProvider.select((m) => m[tabId]))
                    ?.isDirty ??
                false;
          },
        ),
        BaseCommand(
          id: 'save_tmx_as',
          label: 'Save As...',
          icon: const Icon(Icons.save_as),
          defaultPositions: [AppCommandPositions.appBar],
          sourcePlugin: id,
          execute: (ref) async =>
              ref.read(editorServiceProvider).saveCurrentTabAs(),
        ),
        BaseCommand(
          id: 'export_map',
          label: 'Export Map...',
          icon: const Icon(Icons.output_outlined),
          defaultPositions: [AppCommandPositions.appBar],
          sourcePlugin: id,
          execute: (ref) async {
            final editor = _getEditorState(ref);
            editor?.showExportDialog();
          },
        ),
      ];
  }

  @override
  String? get hotStateDtoType => null;
  @override
  Type? get hotStateDtoRuntimeType => null;
  @override
  TypeAdapter<TabHotStateDto>? get hotStateAdapter => null;
}


// FILE: lib/editor/plugins/tiled_editor/tiled_editor_settings_model.dart

import 'package:flutter/material.dart';
import 'package:machine/editor/plugins/editor_plugin_registry.dart';

class TiledEditorSettings extends PluginSettings {
  int gridColorValue;
  double gridThickness;

  TiledEditorSettings({
    this.gridColorValue = 0x33FFFFFF,
    this.gridThickness = 1.0,
  });

  @override
  void fromJson(Map<String, dynamic> json) {
    gridColorValue = json['gridColorValue'] ?? 0x33FFFFFF;
    gridThickness = json['gridThickness'] ?? 1.0;
  }

  @override
  Map<String, dynamic> toJson() => {
        'gridColorValue': gridColorValue,
        'gridThickness': gridThickness,
      };

  TiledEditorSettings copyWith({
    int? gridColorValue,
    double? gridThickness,
  }) {
    return TiledEditorSettings(
      gridColorValue: gridColorValue ?? this.gridColorValue,
      gridThickness: gridThickness ?? this.gridThickness,
    );
  }

  @override
  TiledEditorSettings clone() {
    return TiledEditorSettings(
      gridColorValue: gridColorValue,
      gridThickness: gridThickness,
    );
  }
}

// FILE: lib/editor/plugins/tiled_editor/tiled_editor_widget.dart

import 'dart:async';
import 'dart:ui' as ui;
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:tiled/tiled.dart' hide Text;
import 'package:tiled/tiled.dart' as tiled show Text;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:xml/xml.dart';
import 'package:collection/collection.dart';
import '../../../app/app_notifier.dart';
import '../../../widgets/dialogs/folder_picker_dialog.dart';
import '../../../data/repositories/project/project_repository.dart';
import '../../models/editor_tab_models.dart';
import '../../services/editor_service.dart';
import '../../tab_metadata_notifier.dart';
import '../../../logs/logs_provider.dart';
import '../../../utils/toast.dart';

import 'tiled_command_context.dart';
import 'tiled_editor_models.dart';
import 'tiled_editor_plugin.dart';
import 'tiled_map_notifier.dart';
import 'tmx_writer.dart';
import '../../../command/command_widgets.dart';
import '../../models/editor_command_context.dart';
import 'widgets/layers_panel.dart';
import 'widgets/tile_palette.dart';
import 'tiled_paint_tools.dart';
import '../../../widgets/dialogs/file_explorer_dialogs.dart';
import 'widgets/map_properties_dialog.dart';
import 'widgets/new_layer_dialog.dart';
import 'widgets/new_tileset_dialog.dart';
import 'project_tsx_provider.dart';

import 'tiled_map_painter.dart';
import 'inspector/inspector_dialog.dart';
import 'widgets/object_editor_app_bar.dart';
import 'widgets/paint_editor_app_bar.dart';
import 'package:machine/settings/settings_notifier.dart';
import 'tiled_editor_settings_model.dart';
import 'package:machine/asset_cache/asset_models.dart';
import 'package:machine/asset_cache/asset_providers.dart';
import 'widgets/export_dialog.dart';

import 'widgets/sprite_picker_dialog.dart';
import 'package:machine/editor/plugins/texture_packer/texture_packer_models.dart';
import 'tiled_asset_resolver.dart';

class TiledEditorWidget extends EditorWidget {
  @override
  final TiledEditorTab tab;

  const TiledEditorWidget({required super.key, required this.tab})
    : super(tab: tab);

  @override
  TiledEditorWidgetState createState() => TiledEditorWidgetState();
}

class TiledEditorWidgetState extends EditorWidgetState<TiledEditorWidget> {
  TiledMapNotifier? get notifier => _notifier;
  TiledMapNotifier? _notifier;

  int _selectedLayerId = -1;
  Tileset? _selectedTileset;
  Rect? _selectedTileRect;

  String? _baseContentHash;
  
  bool _isLoading = true;
  Object? _loadingError;

  bool _showGrid = true;
  bool _isPaletteVisible = false;
  bool _isLayersPanelVisible = false;
  TiledEditorMode _mode = TiledEditorMode.panZoom;
  
  bool get isZoomMode => (_mode == TiledEditorMode.panZoom);
  TiledPaintMode _paintMode = TiledPaintMode.paint;
  Rect? _tileMarqueeSelection;
  Offset? _dragStartOffsetInSelection;
  
  ObjectTool _activeObjectTool = ObjectTool.select;
  bool _isSnapToGridEnabled = true;
  Offset? _dragStartMapPosition;
  Map<int, Point>? _initialObjectPositions;

  List<Point> _inProgressPoints = [];
  Rect? _previewShape;
  Rect? _marqueeSelection;

  static const double _kMinPaletteHeight = 150.0;
  static const double _kDefaultPaletteHeight = 200.0;
  double _paletteHeight = _kDefaultPaletteHeight;

  late final TransformationController _transformationController;
  String? _lastTilesetParentUri;

  void editMapProperties() => _editMapProperties();
  void addTileset() => _addTileset();
  void addLayer() => _addLayer();
  void toggleGrid() {
    setState(() => _showGrid = !_showGrid);
    syncCommandContext();
  }

  void _handlePaletteResize(DragUpdateDetails details) {
    setState(() {
      final newHeight = _paletteHeight - details.delta.dy;
      _paletteHeight = newHeight.clamp(
        _kMinPaletteHeight,
        MediaQuery.of(context).size.height * 0.8,
      );
    });
  }
  
  TiledEditorMode getMode() => _mode;
  
  void setMode(TiledEditorMode newMode) {
    if (_mode == newMode) {
      setState(() => _mode = TiledEditorMode.panZoom);
    } else {
      setState(() => _mode = newMode);
    }
    syncCommandContext();
  }

  void exitObjectMode() {
    setMode(TiledEditorMode.panZoom);
  }

  void exitPaintMode() {
    setMode(TiledEditorMode.panZoom);
  }

  void resetView() => _transformationController.value = Matrix4.identity();
  void togglePalette() {
    setState(() => _isPaletteVisible = !_isPaletteVisible);
    syncCommandContext();
  }

  void toggleLayersPanel() {
    setState(() => _isLayersPanelVisible = !_isLayersPanelVisible);
    syncCommandContext();
  }
  
  void setActiveObjectTool(ObjectTool tool) {
    setState(() => _activeObjectTool = tool);
    syncCommandContext();
  }

  void setPaintMode(TiledPaintMode mode) {
    setState(() => _paintMode = mode);
    syncCommandContext();
  }

  @override
  void syncCommandContext() {
    final isPolyToolActive = _activeObjectTool == ObjectTool.addPolygon ||
        _activeObjectTool == ObjectTool.addPolyline;

    Widget? appBarOverride;
    switch (_mode) {
      case TiledEditorMode.paint:
        appBarOverride = PaintEditorAppBar(onExit: exitPaintMode);
        break;
      case TiledEditorMode.object:
        appBarOverride = ObjectEditorAppBar(
          onExit: exitObjectMode,
          isSnapToGridEnabled: _isSnapToGridEnabled,
          onToggleSnapToGrid: () {
            setState(() => _isSnapToGridEnabled = !_isSnapToGridEnabled);
            syncCommandContext();
          },
          isObjectSelected: _notifier?.selectedObjects.isNotEmpty ?? false,
          onInspectObject: _inspectSelectedObject,
          onDeleteObject: _deleteSelectedObject,
          showFinishShapeButton: isPolyToolActive && _inProgressPoints.isNotEmpty,
          onFinishShape: _finalizePolygon,
        );
        break;
      case TiledEditorMode.panZoom:
        appBarOverride = null;
        break;
    }

    ref.read(commandContextProvider(widget.tab.id).notifier).state =
        TiledEditorCommandContext(
      mode: _mode,
      isGridVisible: _showGrid,
      canUndo: _notifier?.canUndo ?? false,
      canRedo: _notifier?.canRedo ?? false,
      isSnapToGridEnabled: _isSnapToGridEnabled,
      isPaletteVisible: _isPaletteVisible,
      isLayersPanelVisible: _isLayersPanelVisible,
      paintMode: _paintMode,
      activeObjectTool: _activeObjectTool,
      hasPolygonPoints: _inProgressPoints.isNotEmpty,
      isObjectSelected: _notifier?.selectedObjects.isNotEmpty ?? false,
      hasFloatingTileSelection: _notifier?.hasFloatingSelection ?? false,
      appBarOverride: appBarOverride,
    );
  }

  @override
  void init() {
    _baseContentHash = widget.tab.initialBaseContentHash;
    _transformationController = TransformationController();
    _transformationController.addListener(() => setState(() {}));
  }

  @override
  void onFirstFrameReady() {
    if (mounted && !widget.tab.onReady.isCompleted) {
      widget.tab.onReady.complete(this);
    }
    if (_baseContentHash == "new_map") {
      ref.read(editorServiceProvider).markCurrentTabDirty();
    }
    _initializeAndLoadMap();
    syncCommandContext();
  }

  @override
  void dispose() {
    _transformationController.dispose();
    _notifier?.removeListener(_onMapChanged);
    _notifier?.dispose();
    super.dispose();
  }

  String _getTmxProjectRelativePath() {
    final repo = ref.read(projectRepositoryProvider)!;
    final project = ref.read(currentProjectProvider)!;
    final tmxFile = ref.read(tabMetadataProvider)[widget.tab.id]!.file;
    return repo.fileHandler.getPathForDisplay(tmxFile.uri, relativeTo: project.rootUri);
  }

  Future<void> _initializeAndLoadMap() async {
    try {
      final repo = ref.read(projectRepositoryProvider)!;
      final tmxFileUri = ref.read(tabMetadataProvider)[widget.tab.id]!.file.uri;
      final tmxParentUri = repo.fileHandler.getParentUri(tmxFileUri);
      
      final tsxProvider = ProjectTsxProvider(repo, tmxParentUri);
      final tsxProviders = await ProjectTsxProvider.parseFromTmx(
        widget.tab.initialTmxContent,
        tsxProvider.getProvider,
      );
      
      final map = TileMapParser.parseTmx(
        widget.tab.initialTmxContent,
        tsxList: tsxProviders,
      );
      _fixupParsedMap(map, widget.tab.initialTmxContent);

      final uris = await _collectAssetUris(map);
      
      final queries = uris.map((uri) => AssetQuery(path: uri)).toSet();
      final assetDataMap = await ref.read(assetMapProvider(widget.tab.id).notifier).updateUris(queries);

      _fixupTilesetsAfterImageLoad(map, assetDataMap);

      if (!mounted) return;
      setState(() {
        _notifier = TiledMapNotifier(map);
        _notifier!.addListener(_onMapChanged);

        _selectedLayerId = map.layers.whereType<TileLayer>().firstOrNull?.id ?? -1;
        _selectedTileset = map.tilesets.firstOrNull;
        _isLoading = false;
      });
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _onMapChanged();
      });
    } catch (e, st) {
      ref.read(talkerProvider).handle(e, st, 'Failed to load TMX map');
      if (mounted) {
        setState(() {
          _loadingError = e;
          _isLoading = false;
        });
      }
    }
  }
  
  String _determineTilesetContext(String tmxPath, Tileset tileset, ProjectRepository repo) {
    if (tileset.source != null) {
      final tsxPath = repo.resolveRelativePath(tmxPath, tileset.source!);
      return tsxPath;
    } else {
      return tmxPath;
    }
  }

  Future<Set<String>> _collectAssetUris(TiledMap map) async {
    final uris = <String>{};
    final repo = ref.read(projectRepositoryProvider)!;
    final tmxPath = _getTmxProjectRelativePath();

    for (final tileset in map.tilesets) {
      final contextPath = _determineTilesetContext(tmxPath, tileset, repo);

      if (tileset.image?.source != null) {
        final assetUri = repo.resolveRelativePath(contextPath, tileset.image!.source!);
        uris.add(assetUri);
      }
    }

    for (final layer in map.layers) {
      if (layer is ImageLayer && layer.image.source != null) {
        final assetUri = repo.resolveRelativePath(tmxPath, layer.image.source!);
        uris.add(assetUri);
      }
    }

    if (map.properties.byName.containsKey('tp_atlases')) {
      final prop = map.properties.byName['tp_atlases'];
      if (prop is StringProperty && prop.value.isNotEmpty) {
        final paths = prop.value.split(',').map((e) => e.trim()).where((e) => e.isNotEmpty);
        for (final path in paths) {
          uris.add(repo.resolveRelativePath(tmxPath, path));
        }
      }
    }
    
    return uris;
  }
  
  Future<void> _rebuildAssetUriSet() async {
    if (_notifier == null) return;
    final uris = await _collectAssetUris(_notifier!.map);
    final queries = uris.map((uri) => AssetQuery(path: uri)).toSet();
    ref.read(assetMapProvider(widget.tab.id).notifier).updateUris(queries);
  }
  
  Future<void> reloadImageSource({
    required Object parentObject,
    required String oldSourcePath,
    required String newProjectPath,
  }) async {
    if (_notifier == null) return;
        
    try {
      final repo = ref.read(projectRepositoryProvider)!;
      final tmxPath = _getTmxProjectRelativePath();

      final assetData = await ref.read(assetDataProvider(newProjectPath).future);
      if (assetData is! ImageAssetData) {
        throw (assetData as ErrorAssetData).error;
      }
      final newImage = assetData.image;

      String contextPath;
      if (parentObject is Tileset) {
        contextPath = _determineTilesetContext(tmxPath, parentObject, repo);
      } else {
        contextPath = tmxPath;
      }

      final newRelativePath = repo.calculateRelativePath(contextPath, newProjectPath);

      _notifier!.updateImageSource(
        parentObject: parentObject,
        newSourcePath: newRelativePath,
        newWidth: newImage.width,
        newHeight: newImage.height,
      );
      
      await _rebuildAssetUriSet();
      
      MachineToast.info('Image source updated successfully.');
    } catch (e, st) {
      ref.read(talkerProvider).handle(e, st, 'Failed to reload image source');
      MachineToast.error('Failed to reload image: $e');
    }
  }
  
  void _fixupParsedMap(TiledMap map, String tmxContent) {
    final xmlDocument = XmlDocument.parse(tmxContent);
    final layerElements = xmlDocument.rootElement.findAllElements('layer');
    final objectGroupElements = xmlDocument.rootElement.findAllElements('objectgroup');

    for (final layerElement in layerElements) {
      final layerId = int.tryParse(layerElement.getAttribute('id') ?? '');
      if (layerId == null) continue;
      
      final layer = map.layers.firstWhereOrNull((l) => l.id == layerId) as TileLayer?;
      if (layer != null && (layer.tileData == null || layer.tileData!.isEmpty)) {
        final dataElement = layerElement.findElements('data').firstOrNull;
        if (dataElement != null && dataElement.getAttribute('encoding') == null) {
          final tileElements = dataElement.findElements('tile');
          final gids = tileElements.map((t) => int.tryParse(t.getAttribute('gid') ?? '0') ?? 0).toList();
          if(gids.isNotEmpty) {
            layer.tileData = Gid.generate(gids, layer.width, layer.height);
          }
        }
      }
    }

    for (final objectGroupElement in objectGroupElements) {
      final layerId = int.tryParse(objectGroupElement.getAttribute('id') ?? '');
      if (layerId == null) continue;

      final objectGroup = map.layers.firstWhereOrNull((l) => l.id == layerId) as ObjectGroup?;
      if (objectGroup == null) continue;

      final objectElements = objectGroupElement.findAllElements('object');
      for (final objectElement in objectElements) {
        final objectId = int.tryParse(objectElement.getAttribute('id') ?? '');
        if (objectId == null) continue;

        final tiledObject = objectGroup.objects.firstWhereOrNull((o) => o.id == objectId);
        if (tiledObject != null) {
          final hasEllipse = objectElement.findElements('ellipse').isNotEmpty;
          final hasPoint = objectElement.findElements('point').isNotEmpty;
          
          if (hasEllipse) {
            tiledObject.ellipse = true;
            tiledObject.rectangle = false;
            tiledObject.point = false;
          } else if (hasPoint) {
            tiledObject.point = true;
            tiledObject.rectangle = false;
            tiledObject.ellipse = false;
          }
        }
      }
    }

    var nextAvailableId = map.nextLayerId;

    int findMaxId(List<Layer> layers) {
      var maxId = 0;
      for (final layer in layers) {
        if (layer.id != null) {
          maxId = max(maxId, layer.id!);
        }
        if (layer is Group) {
          maxId = max(maxId, findMaxId(layer.layers));
        }
      }
      return maxId;
    }

    if (nextAvailableId == null) {
      final maxLayerId = findMaxId(map.layers);
      nextAvailableId = maxLayerId + 1;
    }

    void assignIds(List<Layer> layers) {
      for (final layer in layers) {
        if (layer.id == null) {
          layer.id = nextAvailableId;
          nextAvailableId = nextAvailableId! + 1;
        }
        if (layer is Group) {
          assignIds(layer.layers);
        }
      }
    }

    assignIds(map.layers);
    
    map.nextLayerId = nextAvailableId;
  }
  
  void _fixupTilesetsAfterImageLoad(TiledMap map, Map<String, AssetData> assetDataMap) {
    final repo = ref.read(projectRepositoryProvider)!;
    final tmxPath = _getTmxProjectRelativePath();

    for (final tileset in map.tilesets) {
      if (tileset.tiles.isEmpty && tileset.image?.source != null) {
        final rawSource = tileset.image!.source!;
        
        final contextPath = _determineTilesetContext(tmxPath, tileset, repo);
        final canonicalKey = repo.resolveRelativePath(contextPath, rawSource);
        
        final asset = assetDataMap[canonicalKey];
        if (asset is ImageAssetData) {
          final loadedImage = asset.image;
          final currentTiledImage = tileset.image!;

          if (currentTiledImage.width == null || currentTiledImage.height == null) {
            tileset.image = TiledImage(
              source: currentTiledImage.source,
              width: loadedImage.width,
              height: loadedImage.height,
            );
          }

          final tileWidth = tileset.tileWidth;
          final tileHeight = tileset.tileHeight;
          final imageWidth = tileset.image!.width!;
          final imageHeight = tileset.image!.height!;

          if (tileWidth != null && tileHeight != null && tileWidth > 0 && tileHeight > 0) {
            final columns = (imageWidth - tileset.margin * 2 + tileset.spacing) ~/ (tileWidth + tileset.spacing);
            final rows = (imageHeight - tileset.margin * 2 + tileset.spacing) ~/ (tileHeight + tileset.spacing);
            final tileCount = columns * rows;
            
            tileset.columns = columns;
            tileset.tileCount = tileCount;
            tileset.tiles = [for (var i = 0; i < tileCount; ++i) Tile(localId: i)];
          }
        }
      }
    }
  }

  void _onMapChanged() {
    ref.read(editorServiceProvider).markCurrentTabDirty();
    
    _rebuildAssetUriSet().then((_) {
      if (mounted) setState(() {});
    });
    
    syncCommandContext();
    setState(() {});
  }

  void _editMapProperties() async {
    final result = await showDialog<Map<String, int>>(
      context: context,
      builder: (_) => MapPropertiesDialog(map: _notifier!.map),
    );
    if (result != null) {
      _notifier!.updateMapProperties(
        width: result['width']!,
        height: result['height']!,
        tileWidth: result['tileWidth']!,
        tileHeight: result['tileHeight']!,
      );
    }
  }
  
  Map<String, AssetData>? _getAssetDataMap() {
    final assetMapAsync = ref.read(assetMapProvider(widget.tab.id));
    final assetMap = assetMapAsync.valueOrNull;
    if (assetMap == null) {
      MachineToast.info("Assets are still loading, please wait.");
      return null;
    }
    return assetMap;
  }
  
  void showExportDialog() {
    final assetMap = _getAssetDataMap();
    if (_notifier == null || assetMap == null) return;

    showDialog(
      context: context,
      builder: (_) => ExportDialog(
        notifier: _notifier!,
        talker: ref.read(talkerProvider),
        assetDataMap: assetMap,
      ),
    );
  }  

  void inspectMapProperties() {
    final resolverState = ref.read(tiledAssetResolverProvider(widget.tab.id));
    final resolver = resolverState.valueOrNull;
    
    if (_notifier == null || resolver == null) return;

    showDialog(
      context: context,
      builder: (_) => InspectorDialog(
        target: _notifier!.map,
        title: 'Map Properties',
        notifier: _notifier!,
        editorKey: widget.tab.editorKey,
        resolver: resolver,
      ),
    );
  }

  Future<void> _addTileset() async {
    final relativeImagePath = await showDialog<String>(
      context: context,
      builder: (_) => FileOrFolderPickerDialog(initialUri: _lastTilesetParentUri),
    );
    if (relativeImagePath == null || !mounted) return;

    final result = await showDialog<Map<String, dynamic>>(
      context: context,
      builder: (_) => NewTilesetDialog(imagePath: relativeImagePath),
    );
    if (result == null || !mounted) return;

    try {
      final repo = ref.read(projectRepositoryProvider)!;
      final project = ref.read(currentProjectProvider)!;
      
      final imageFile = await repo.fileHandler.resolvePath(project.rootUri, relativeImagePath);
      if (imageFile != null) {
        _lastTilesetParentUri = repo.fileHandler.getParentUri(imageFile.uri);
      }

      final tmxPath = _getTmxProjectRelativePath();
      final imagePathRelativeToTmx = repo.calculateRelativePath(tmxPath, relativeImagePath);

      final assetData = await ref.read(assetDataProvider(relativeImagePath).future);
      if (assetData is! ImageAssetData) throw Exception("Failed to load image asset");
      final image = assetData.image;

      final tileWidth = result['tileWidth'] as int;
      final tileHeight = result['tileHeight'] as int;
      final columns = (image.width) ~/ tileWidth;
      final tileCount = columns * (image.height ~/ tileHeight);

      int nextGid = 1;
      if (_notifier!.map.tilesets.isNotEmpty) {
        final last = _notifier!.map.tilesets.last;
        nextGid = (last.firstGid ?? 0) + (last.tileCount ?? 0);
      }

      final newTileset = Tileset(
        name: result['name'],
        firstGid: nextGid,
        tileWidth: tileWidth,
        tileHeight: tileHeight,
        tileCount: tileCount,
        columns: columns,
        image: TiledImage(
          source: imagePathRelativeToTmx,
          width: image.width,
          height: image.height,
        ),
      );

      await _notifier!.addTileset(newTileset);
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _onMapChanged();
      });

    } catch (e, st) {
      MachineToast.error('Failed to add tileset: $e');
      ref.read(talkerProvider).handle(e, st, 'Failed to add tileset');
    }
  }
  
  void _deleteSelectedTileset() async {
    if (_notifier == null || _selectedTileset == null) return;

    final tilesetToDelete = _selectedTileset!;
    final confirm = await showConfirmDialog(
      context,
      title: 'Delete Tileset "${tilesetToDelete.name}"?',
      content:
          'Are you sure you want to delete this tileset? Tiles using it may disappear. This action can be undone.',
    );

    if (confirm) {
      _notifier!.deleteTileset(tilesetToDelete);
      setState(() {
        _selectedTileset = null;
        _selectedTileRect = null;
      });
    }
  }
  
    void _clearUnusedTilesets() async {
    if (_notifier == null) return;
    
    final unused = _notifier!.findUnusedTilesets();

    if (unused.isEmpty) {
      MachineToast.info("No unused tilesets found.");
      return;
    }

    final confirm = await showConfirmDialog(
      context,
      title: 'Clear Unused Tilesets?',
      content:
          'This will remove ${unused.length} tileset(s) that are not currently used by any layers. This action can be undone.',
    );

    if (confirm) {
      final selectedIsUnused = unused.any((ts) => ts.name == _selectedTileset?.name);
      
      _notifier!.removeTilesets(unused);
      
      if (selectedIsUnused) {
        setState(() {
          _selectedTileset = null;
          _selectedTileRect = null;
        });
      }

      MachineToast.info("Removed ${unused.length} tileset(s).");
    }
  }

  void _inspectSelectedTileset() {
    final resolverState = ref.read(tiledAssetResolverProvider(widget.tab.id));
    final resolver = resolverState.valueOrNull;
    if (_notifier == null || _selectedTileset == null || resolver == null) return;
    
    showDialog(
      context: context,
      builder: (_) => InspectorDialog(
        target: _selectedTileset!,
        title: '${_selectedTileset!.name ?? 'Tileset'} Properties',
        notifier: _notifier!,
        editorKey: widget.tab.editorKey,
        resolver: resolver,
      ),
    );
  }

  void _addLayer() async {
    final result = await showDialog<Map<String, dynamic>>(
      context: context,
      builder: (_) => const NewLayerDialog(),
    );
    if (result != null) {
      _notifier!.addLayer(name: result['name'], type: result['type']);
    }
  }
  

  void _deleteLayer(int layerId) async {
    if (_notifier == null) return;
    final layerToDelete =
        _notifier!.map.layers.firstWhereOrNull((l) => l.id == layerId);
    if (layerToDelete == null) return;

    final confirm = await showConfirmDialog(
      context,
      title: 'Delete Layer "${layerToDelete.name}"?',
      content: 'Are you sure you want to delete this layer? This can be undone.',
    );

    if (confirm) {
      final oldIndex = _notifier!.map.layers.indexWhere((l) => l.id == layerId);
      _notifier!.deleteLayer(layerId);
      if (_selectedLayerId == layerId) {
        final newIndex = (oldIndex - 1).clamp(0, _notifier!.map.layers.length - 1);
        final newSelectedLayer =
            _notifier!.map.layers.isEmpty ? null : _notifier!.map.layers[newIndex];
        _onLayerSelect(newSelectedLayer?.id ?? -1);
      }
    }
  }
  
  void _onLayerSelect(int id) {
    final layer = notifier?.map.layers.firstWhereOrNull((l) => l.id == id);
    if (layer == null) return;

    var newMode = _mode;
    if (_mode == TiledEditorMode.paint && layer is! TileLayer) {
      newMode = TiledEditorMode.panZoom;
      MachineToast.info("Switched to Pan/Zoom mode. Selected layer is not a Tile Layer.");
    } else if (_mode == TiledEditorMode.object && layer is! ObjectGroup) {
      newMode = TiledEditorMode.panZoom;
      MachineToast.info("Switched to Pan/Zoom mode. Selected layer is not an Object Layer.");
    }

    setState(() {
      _selectedLayerId = id;
      _mode = newMode;
    });
    syncCommandContext();
  }

  void _showLayerInspector(Layer layer, TiledAssetResolver resolver) {
    if (_notifier == null) return;
    
    showDialog(
      context: context,
      builder: (_) => InspectorDialog(
        target: layer,
        title: '${layer.name} Properties',
        notifier: _notifier!,
        editorKey: widget.tab.editorKey,
        resolver: resolver,
      ),
    );
  }
  
  void _inspectObject(TiledObject object, TiledAssetResolver resolver) {
    if (_notifier == null) return;
    
    showDialog(
      context: context,
      builder: (_) => InspectorDialog(
        target: object,
        title: '${object.name.isNotEmpty ? object.name : 'Object'} Properties',
        notifier: _notifier!,
        editorKey: widget.tab.editorKey,
        resolver: resolver,
      ),
    );
  }
  
  void _inspectSelectedObject() {
    final resolverState = ref.read(tiledAssetResolverProvider(widget.tab.id));
    final resolver = resolverState.valueOrNull;
    if(resolver==null) return;
    if (_notifier == null) return;
    final selection = _notifier!.selectedObjects;
    if (selection.length != 1) return;

    final target = selection.first;
    showDialog(
      context: context,
      builder: (_) => InspectorDialog(
        target: target,
        title: '${target.name.isNotEmpty ? target.name : 'Object'} Properties',
        notifier: _notifier!,
        editorKey: widget.tab.editorKey,
        resolver: resolver,
      ),
    );
  }
  
    void _deleteSelectedObject() async {
    if (_notifier == null || _notifier!.selectedObjects.isEmpty) return;

    final count = _notifier!.selectedObjects.length;
    final confirm = await showConfirmDialog(
      context,
      title: 'Delete Object${count > 1 ? 's' : ''}?',
      content:
          'Are you sure you want to delete the selected ${count > 1 ? '$count objects' : 'object'}? This action can be undone.',
    );

    if (confirm) {
      _notifier!.deleteSelectedObjects(_selectedLayerId);
    }
  }
  
  void _onInteractionUpdate(Offset localPosition, {bool isStart = false}) {
    switch (_mode) {
      case TiledEditorMode.paint:
        if (isStart) notifier?.beginTileStroke(_selectedLayerId);
        _handlePaintInteraction(localPosition, isStart: isStart);
        break;
      case TiledEditorMode.object:
        _handleObjectInteraction(localPosition, isStart: isStart);
        break;
      case TiledEditorMode.panZoom:
        break;
    }
  }
  

  void _onInteractionCancel() {
    switch (_mode) {
      case TiledEditorMode.paint:
        notifier?.endTileStroke(_selectedLayerId);
        break;

      case TiledEditorMode.object:
        if (_initialObjectPositions != null && notifier != null) {
          notifier!.beginObjectChange(_selectedLayerId);
          for (final obj in notifier!.selectedObjects) {
            final initialPos = _initialObjectPositions![obj.id];
            if (initialPos != null) {
              obj.x = initialPos.x;
              obj.y = initialPos.y;
            }
          }
          notifier!.endObjectChange(_selectedLayerId);
          _initialObjectPositions = null;
        }

        if (_activeObjectTool == ObjectTool.addPolygon ||
            _activeObjectTool == ObjectTool.addPolyline) {
          if (_inProgressPoints.isNotEmpty) {
            _inProgressPoints.removeLast();
            if (_inProgressPoints.isEmpty) {
              notifier?.endObjectChange(_selectedLayerId);
            }
          }
        }
        break;

      case TiledEditorMode.panZoom:
        break;
    }

    setState(() {
      _dragStartMapPosition = null;
      _previewShape = null;
      _marqueeSelection = null;
      _initialObjectPositions = null;
    });
    syncCommandContext();
  }

  void _onInteractionEnd() {
    switch (_mode) {
      case TiledEditorMode.paint:
        _handlePaintInteractionEnd();
        break;
      case TiledEditorMode.object:
        _handleObjectInteractionEnd();
        break;
      case TiledEditorMode.panZoom:
        break;
    }
    syncCommandContext();
  }

  void _handlePaintInteraction(Offset localPosition, {bool isStart = false}) {
    if (isZoomMode || _selectedLayerId == -1) return;
    final layer = notifier?.map.layers.firstWhereOrNull((l) => l.id == _selectedLayerId);
    if (layer is! TileLayer) {
      if(isStart) {
        MachineToast.info("Select a Tile Layer.");
      }
      return;
    }

    final inverseMatrix = _transformationController.value.clone()..invert();
    final mapPosition = MatrixUtils.transformPoint(
      inverseMatrix,
      localPosition,
    );

    final tileWidth = notifier!.map.tileWidth;
    final tileHeight = notifier!.map.tileHeight;
    final mapX = (mapPosition.dx / tileWidth).floor();
    final mapY = (mapPosition.dy / tileHeight).floor();

    switch (_paintMode) {
      case TiledPaintMode.paint:
        if (_selectedTileset != null && _selectedTileRect != null) {
          notifier!.setStamp(
            mapX,
            mapY,
            _selectedLayerId,
            _selectedTileset!,
            _selectedTileRect!,
          );
        }
        break;
      case TiledPaintMode.erase:
        notifier!.eraseTiles(
          mapX,
          mapY,
          _selectedLayerId,
          const Rect.fromLTWH(0, 0, 1, 1),
        );
        break;
      case TiledPaintMode.fill:
        if (_selectedTileset != null && _selectedTileRect != null) {
          notifier!.bucketFill(
            mapX,
            mapY,
            _selectedLayerId,
            _selectedTileset!,
            _selectedTileRect!,
          );
        } else {
          MachineToast.info(
            "Select a tile or stamp from the palette to use for filling.",
          );
        }
        break;
      case TiledPaintMode.select:
        _handleTileSelect(localPosition, isStart: isStart);
        break;
      case TiledPaintMode.move:
        _handleTileMove(localPosition, isStart: isStart);
        break;
    }
  }
  
  void _paintStamp(Offset localPosition) {
    if (isZoomMode ||
        _selectedTileset == null ||
        _selectedTileRect == null ||
        _selectedLayerId == -1)
      return;

    final inverseMatrix = _transformationController.value.clone()..invert();
    final mapPosition = MatrixUtils.transformPoint(
      inverseMatrix,
      localPosition,
    );

    final tileWidth = notifier!.map.tileWidth;
    final tileHeight = notifier!.map.tileHeight;
    final startX = (mapPosition.dx / tileWidth).floor();
    final startY = (mapPosition.dy / tileHeight).floor();

    notifier!.setStamp(
      startX,
      startY,
      _selectedLayerId,
      _selectedTileset!,
      _selectedTileRect!,
    );
  }
  
  void _handleTileSelect(Offset localPosition, {required bool isStart}) {
    final mapPosition = _getMapPosition(localPosition);
    if (isStart) {
      _dragStartMapPosition = mapPosition;
      notifier?.setTileSelection(null, _selectedLayerId);
    } else {
      if (_dragStartMapPosition == null) return;
      setState(() {
        _tileMarqueeSelection = Rect.fromPoints(_dragStartMapPosition!, mapPosition);
      });
    }
  }
  
  void _handleTileMove(Offset localPosition, {required bool isStart}) {
    if (notifier?.hasFloatingSelection != true) return;
    final mapPosition = _getMapPosition(localPosition);

    if (isStart) {
      final selectionPos = notifier!.floatingSelectionPosition!;
      final selectionPixelX = selectionPos.x * notifier!.map.tileWidth;
      final selectionPixelY = selectionPos.y * notifier!.map.tileHeight;
      _dragStartOffsetInSelection = Offset(
        mapPosition.dx - selectionPixelX,
        mapPosition.dy - selectionPixelY,
      );
    } else {
      if (_dragStartOffsetInSelection == null) return;

      final newTopLeftPixelX = mapPosition.dx - _dragStartOffsetInSelection!.dx;
      final newTopLeftPixelY = mapPosition.dy - _dragStartOffsetInSelection!.dy;

      final tileX = (newTopLeftPixelX / notifier!.map.tileWidth).floor();
      final tileY = (newTopLeftPixelY / notifier!.map.tileHeight).floor();

      notifier!.updateFloatingSelectionPosition(Point(x: tileX.toDouble(), y: tileY.toDouble()));
    }
  }
  

  void _handlePaintInteractionEnd() {
    if (_paintMode == TiledPaintMode.select && _tileMarqueeSelection != null) {
      final rect = _tileMarqueeSelection!;
      final tileWidth = notifier!.map.tileWidth;
      final tileHeight = notifier!.map.tileHeight;

      final startTileX = (rect.left / tileWidth).floor();
      final startTileY = (rect.top / tileHeight).floor();
      final endTileX = (rect.right / tileWidth).floor();
      final endTileY = (rect.bottom / tileHeight).floor();

      final selection = Rect.fromLTWH(
        min(startTileX, endTileX).toDouble(),
        min(startTileY, endTileY).toDouble(),
        (startTileX - endTileX).abs() + 1,
        (startTileY - endTileY).abs() + 1,
      );
      
      notifier?.setTileSelection(selection, _selectedLayerId);
      notifier?.cutSelection(_selectedLayerId);      
    } else if (notifier?.hasFloatingSelection == true && _paintMode != TiledPaintMode.move) {
      notifier?.stampFloatingSelection(_selectedLayerId);
    }
    notifier?.endTileStroke(_selectedLayerId);
    setState(() {
      _dragStartMapPosition = null;
      _tileMarqueeSelection = null;
      _dragStartOffsetInSelection = null;
    });
    
  }

  Offset _getMapPosition(Offset localPosition) {
    final inverseMatrix = _transformationController.value.clone()..invert();
    return MatrixUtils.transformPoint(inverseMatrix, localPosition);
  }

  Offset _snapOffsetToGrid(Offset offset) {
    if (!_isSnapToGridEnabled || notifier == null) return offset;
    final tileWidth = notifier!.map.tileWidth.toDouble();
    final tileHeight = notifier!.map.tileHeight.toDouble();
    return Offset(
      (offset.dx / tileWidth).round() * tileWidth,
      (offset.dy / tileHeight).round() * tileHeight,
    );
  }
  
  TexturePackerSpriteData? _findSpriteDataInAssets(String spriteName) {
    final assetMap = _getAssetDataMap();
    if (assetMap == null) return null;

    for (final asset in assetMap.values) {
      if (asset is TexturePackerAssetData) {
        if (asset.frames.containsKey(spriteName)) {
          return asset.frames[spriteName];
        }
        if (asset.animations.containsKey(spriteName)) {
          final firstFrame = asset.animations[spriteName]!.firstOrNull;
          if (firstFrame != null && asset.frames.containsKey(firstFrame)) {
            return asset.frames[firstFrame];
          }
        }
      }
    }
    return null;
  }
  
  Future<void> _createSpriteObjectFromTap() async {
    final layer = notifier?.map.layers.firstWhereOrNull((l) => l.id == _selectedLayerId);
    if (layer is! ObjectGroup || _dragStartMapPosition == null) return;

    final assetMap = _getAssetDataMap();
    if (assetMap == null) return;

    final List<String> allSpriteNames = [];
    assetMap.forEach((key, value) {
      if (value is TexturePackerAssetData) {
        allSpriteNames.addAll(value.frames.keys);
        allSpriteNames.addAll(value.animations.keys);
      }
    });
    
    if (allSpriteNames.isEmpty) {
      MachineToast.info("No sprites available. Link a .tpacker file in Map Properties.");
      return;
    }
    allSpriteNames.sort();

    final selectedSprite = await showDialog<String>(
      context: context,
      builder: (ctx) => SpritePickerDialog(spriteNames: allSpriteNames),
    );

    if (selectedSprite == null) return;

    final spriteData = _findSpriteDataInAssets(selectedSprite);
    if (spriteData == null) return;

    notifier?.beginObjectChange(_selectedLayerId);

    final newId = notifier!.map.nextObjectId ?? 1;
    final width = spriteData.sourceRect.width;
    final height = spriteData.sourceRect.height;

    final x = _dragStartMapPosition!.dx;
    final y = _dragStartMapPosition!.dy;

    final newObject = TiledObject(
      id: newId,
      name: selectedSprite,
      x: x,
      y: y,
      width: width,
      height: height,
      properties: CustomProperties({
        'tp_sprite': Property(name: 'tp_sprite', type: PropertyType.string, value: selectedSprite)
      }),
    );

    layer.objects.add(newObject);
    notifier!.map.nextObjectId = newId + 1;
    notifier!.endObjectChange(_selectedLayerId);
    notifier!.selectObject(newObject);
    
    setState(() {});
  }

  void _handleObjectInteraction(Offset localPosition, {bool isStart = false}) {
    final layer = notifier?.map.layers.firstWhereOrNull((l) => l.id == _selectedLayerId);
    if (layer is! ObjectGroup) {
      if(isStart) {
        MachineToast.info("Select an Object Layer to edit objects.");
      }
      return;
    }

    final mapPosition = _getMapPosition(localPosition);

    switch (_activeObjectTool) {
      case ObjectTool.select:
        _handleSelectTool(mapPosition, isStart: isStart);
        break;
      case ObjectTool.move:
        _handleMoveTool(mapPosition, isStart: isStart);
        break;
      case ObjectTool.addRectangle:
      case ObjectTool.addEllipse:
      case ObjectTool.addPoint:
      case ObjectTool.addText:
        _handleCreateTool(mapPosition, isStart: isStart);
        break;
      case ObjectTool.addPolygon:
      case ObjectTool.addPolyline:
          _handlePolygonTool(mapPosition, isStart: isStart);
        break;
      case ObjectTool.addSprite:
        if (isStart) {
           setState(() => _dragStartMapPosition = _snapOffsetToGrid(mapPosition));
        }
        break;
     }
  }

  void _handleObjectInteractionEnd() {
    final dragThreshold = 4.0;
    final didDrag = _dragStartMapPosition != null &&
        (_getMapPosition(Offset.zero) - _dragStartMapPosition!).distance >
            dragThreshold;

    if (_activeObjectTool == ObjectTool.select && _marqueeSelection != null) {
      _selectObjectsInMarquee();
    } else if (_dragStartMapPosition != null) {
      switch (_activeObjectTool) {
        case ObjectTool.addRectangle:
        case ObjectTool.addEllipse:
        case ObjectTool.addPoint:
        case ObjectTool.addText:
          if (didDrag && _previewShape != null) {
            _createShapeFromPreview();
          } else {
            _createShapeFromTap();
          }
          break;
        case ObjectTool.addSprite:
          if (!didDrag) {
            _createSpriteObjectFromTap();
          }
          break;
        case ObjectTool.addPolygon:
        case ObjectTool.addPolyline:
          break;
        default:
          break;
      }
    }

    if (_initialObjectPositions != null) {
      notifier?.endObjectChange(_selectedLayerId);
    }

    setState(() {
      _dragStartMapPosition = null;
      _previewShape = null;
      _marqueeSelection = null;
      _initialObjectPositions = null;
    });
  }

  TiledObject? _getObjectAt(Offset mapPosition, int layerId) {
    final layer =
        notifier?.map.layers.firstWhereOrNull((l) => l.id == layerId);
    if (layer is! ObjectGroup) return null;

    for (final obj in layer.objects.reversed) {
      final rect = Rect.fromLTWH(obj.x, obj.y, obj.width, obj.height);
      if (rect.contains(mapPosition)) {
        return obj;
      }
    }
    return null;
  }

  void _handleSelectTool(Offset mapPosition, {required bool isStart}) {
    if (isStart) {
      final hitObject = _getObjectAt(mapPosition, _selectedLayerId);
      if (hitObject != null) {
        notifier?.selectObject(hitObject);
      } else {
        notifier?.clearSelection();
        setState(() {
          _dragStartMapPosition = mapPosition;
        });
      }
    } else {
      if (_dragStartMapPosition == null) return;
      setState(() {
        _marqueeSelection = Rect.fromPoints(_dragStartMapPosition!, mapPosition);
      });
    }
  }
  
    void _selectObjectsInMarquee() {
    final layer = notifier?.map.layers.firstWhereOrNull((l) => l.id == _selectedLayerId);
    if (layer is! ObjectGroup || _marqueeSelection == null) return;
    
    final selectionRect = _marqueeSelection!;
    final selected = <TiledObject>[];
    for (final obj in layer.objects) {
      final objRect = Rect.fromLTWH(obj.x, obj.y, obj.width, obj.height);
      if (selectionRect.overlaps(objRect)) {
        selected.add(obj);
      }
    }
    
    if (selected.isNotEmpty) {
      notifier?.selectObject(selected.first);
      for (var i = 1; i < selected.length; i++) {
        notifier?.addSelection(selected[i]);
      }
    }
  }

  void _handleMoveTool(Offset mapPosition, {required bool isStart}) {
    if (isStart) {
      if (notifier?.selectedObjects.isEmpty ?? true) return;
      
      notifier?.beginObjectChange(_selectedLayerId);
      setState(() {
        _dragStartMapPosition = mapPosition;
        _initialObjectPositions = {
          for (var obj in notifier!.selectedObjects)
            obj.id: Point(x:obj.x, y:obj.y)
        };
      });
    } else {
      if (_dragStartMapPosition == null || _initialObjectPositions == null) return;
      
      var delta = mapPosition - _dragStartMapPosition!;
      if (_isSnapToGridEnabled) {
        delta = _snapOffsetToGrid(delta) - _snapOffsetToGrid(Offset.zero);
      }

      for (final obj in notifier!.selectedObjects) {
        final initialPos = _initialObjectPositions![obj.id];
        if (initialPos != null) {
          obj.x = initialPos.x + delta.dx;
          obj.y = initialPos.y + delta.dy;
        }
      }
      setState(() {});
    }
  }

  void _handleCreateTool(Offset mapPosition, {required bool isStart}) {
    final snappedPos = _snapOffsetToGrid(mapPosition);
    if (isStart) {
      notifier?.beginObjectChange(_selectedLayerId);
      setState(() => _dragStartMapPosition = snappedPos);
    } else {
      if (_dragStartMapPosition == null) return;
      setState(() => _previewShape = Rect.fromPoints(_dragStartMapPosition!, snappedPos));
    }
  }

  void _createShapeFromTap() {
    final layer =
        notifier?.map.layers.firstWhereOrNull((l) => l.id == _selectedLayerId);
    if (layer is! ObjectGroup || _dragStartMapPosition == null) return;

    notifier?.beginObjectChange(_selectedLayerId);

    final defaultSize = _isSnapToGridEnabled
        ? Size(notifier!.map.tileWidth.toDouble(),
            notifier!.map.tileHeight.toDouble())
        : const Size(16, 16);
    
    final newId = notifier!.map.nextObjectId ?? 1;

    final newObject = TiledObject(
      id: newId,
      x: _dragStartMapPosition!.dx,
      y: _dragStartMapPosition!.dy,
      width: defaultSize.width,
      height: defaultSize.height,
    );

    _configureObjectShape(newObject);
    
    layer.objects.add(newObject);
    notifier!.map.nextObjectId = newId + 1;
    notifier!.endObjectChange(_selectedLayerId);
    notifier!.selectObject(newObject);
    
    setState(() {});
  }
  
  void _createShapeFromPreview() {
    final layer =
        notifier?.map.layers.firstWhereOrNull((l) => l.id == _selectedLayerId);
    if (layer is! ObjectGroup || _previewShape == null) return;

    
    final rect = _previewShape!;
    final newId = notifier!.map.nextObjectId ?? 1;

    final newObject = TiledObject(
      id: newId,
      x: rect.left,
      y: rect.top,
      width: rect.width.abs(),
      height: rect.height.abs(),
    );

    _configureObjectShape(newObject);
    
    layer.objects.add(newObject);
    notifier!.map.nextObjectId = newId + 1;
    notifier!.endObjectChange(_selectedLayerId);
    notifier!.selectObject(newObject);
    
    setState(() {});
  }

  void _configureObjectShape(TiledObject newObject) {
     switch (_activeObjectTool) {
      case ObjectTool.addRectangle:
        newObject.rectangle = true;
        break;
      case ObjectTool.addEllipse:
        newObject.ellipse = true;
        break;
      case ObjectTool.addText:
        newObject.text = tiled.Text(text: 'New Text');
        newObject.rectangle = true;
        break;
      case ObjectTool.addPoint:
        newObject.point = true;
        break;
      default:
        break;
    }
  }

  void _handlePolygonTool(Offset mapPosition, {required bool isStart}) {
    final snappedPos = _snapOffsetToGrid(mapPosition);
    final point = Point(x: snappedPos.dx, y: snappedPos.dy);
    
    if (isStart) {
      if (_inProgressPoints.isEmpty) {
        notifier?.beginObjectChange(_selectedLayerId);
      }
      setState(() {
        _inProgressPoints.add(point);
      });
    } else {
      if (_inProgressPoints.isNotEmpty) {
        setState(() {
          _inProgressPoints[_inProgressPoints.length - 1] = point;
        });
      }
    }
    syncCommandContext();
  }

  void _finalizePolygon() {
    final layer =
        notifier?.map.layers.firstWhereOrNull((l) => l.id == _selectedLayerId);
    if (layer is! ObjectGroup || _inProgressPoints.length < 2) {
      setState(() {
        if (_inProgressPoints.isNotEmpty) {
          _inProgressPoints.clear();
        }
      });
      syncCommandContext();
      return;
    }


    final newId = notifier!.map.nextObjectId ?? 1;
    final minX = _inProgressPoints.map((p) => p.x).reduce(min);
    final minY = _inProgressPoints.map((p) => p.y).reduce(min);
    final maxX = _inProgressPoints.map((p) => p.x).reduce(max);
    final maxY = _inProgressPoints.map((p) => p.y).reduce(max);

    final relativePoints = _inProgressPoints
        .map((p) => Point(x: p.x - minX, y: p.y - minY))
        .toList();

    final newObject = TiledObject(
      id: newId,
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY,
    );

    if (_activeObjectTool == ObjectTool.addPolygon) {
      newObject.polygon = relativePoints;
    } else {
      newObject.polyline = relativePoints;
    }

    layer.objects.add(newObject);
    notifier!.map.nextObjectId = newId + 1;
    notifier!.endObjectChange(_selectedLayerId);
    notifier!.selectObject(newObject);

    setState(() => _inProgressPoints.clear());
    syncCommandContext();
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) return const Center(child: CircularProgressIndicator());
    if (_loadingError != null)
      return Center(child: Text('Error loading map: $_loadingError'));
    if (notifier == null)
      return const Center(child: Text('Could not load map.'));
    final tiledSettings = ref.watch(effectiveSettingsProvider.select((s) => s.pluginSettings[TiledEditorSettings] as TiledEditorSettings?)) ?? TiledEditorSettings();

    final map = notifier!.map;
    final mapPixelWidth = (map.width * map.tileWidth).toDouble();
    final mapPixelHeight = (map.height * map.tileHeight).toDouble();

    final resolverAsync = ref.watch(tiledAssetResolverProvider(widget.tab.id));

    return resolverAsync.when(
      skipLoadingOnReload: true,
      data: (resolver) {
        final editorContent = GestureDetector(
          onTapDown: (details) =>
              _onInteractionUpdate(details.localPosition, isStart: true),
          onPanStart: (details) =>
              _onInteractionUpdate(details.localPosition, isStart: true),
          onPanUpdate: (details) => _onInteractionUpdate(details.localPosition),
          onPanEnd: (details) => _onInteractionEnd(),
          onTapUp: (details) => _onInteractionEnd(),
          onTapCancel: _onInteractionCancel,
          child: InteractiveViewer(
            clipBehavior: Clip.none,
            transformationController: _transformationController,
            boundaryMargin: const EdgeInsets.all(double.infinity),
            minScale: 0.1,
            maxScale: 16.0,
            panEnabled: isZoomMode,
            scaleEnabled: isZoomMode,
            child: CustomPaint(
              size: Size(mapPixelWidth, mapPixelHeight),
              painter: TiledMapPainter(
                map: map,
                resolver: resolver,
                showGrid: _showGrid,
                transform: _transformationController.value,
                selectedObjects: notifier!.selectedObjects,
                previewShape: _previewShape,
                inProgressPoints: _inProgressPoints,
                marqueeSelection: _mode == TiledEditorMode.paint ? _tileMarqueeSelection : _marqueeSelection,
                settings: tiledSettings,
                floatingSelection: notifier!.floatingSelection,
                floatingSelectionPosition: notifier!.floatingSelectionPosition,
              ),
            ),
          ),
        );
    
        return Stack(
          fit: StackFit.expand,
          children: [
            editorContent,
            Positioned(
              top: 8,
              right: 8,
              child: Card(
                child: SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Padding(
                    padding: const EdgeInsets.all(4.0),
                    child: const CommandToolbar(
                      position: TiledEditorPlugin.tiledFloatingToolbar,
                    ),
                  ),
                ),
              ),
            ),
            AnimatedPositioned(
              duration: const Duration(milliseconds: 250),
              curve: Curves.easeInOut,
              bottom: _isPaletteVisible ? 0 : -_paletteHeight,
              left: 0,
              right: 0,
              child: SizedBox(
                height: _paletteHeight,
                child: TilePalette(
                  map: notifier!.map,
                  resolver: resolver,
                  selectedTileset: _selectedTileset,
                  selectedTileRect: _selectedTileRect,
                  onTilesetChanged: (ts) => setState(() => _selectedTileset = ts),
                  onTileSelectionChanged:
                      (rect) => setState(() => _selectedTileRect = rect),
                  onAddTileset: _addTileset,
                  onResize: _handlePaletteResize,
                  onInspectSelectedTileset: _inspectSelectedTileset,
                  onDeleteSelectedTileset: _deleteSelectedTileset,
                  onClearUnusedTilesets: _clearUnusedTilesets,
                ),
              ),
            ),
            AnimatedPositioned(
              duration: const Duration(milliseconds: 250),
              curve: Curves.easeInOut,
              top: 0,
              bottom: 0,
              left: _isLayersPanelVisible ? 0 : -320,
              width: 320,
              child: LayersPanel(
                layers: notifier!.map.layers,
                selectedLayerId: _selectedLayerId,
                selectedObjects: notifier!.selectedObjects,
                onLayerSelected: _onLayerSelect,
                onObjectSelected: (obj) {
                  setState(() {
                    _mode = TiledEditorMode.object;
                  });
                  notifier!.selectObject(obj);
                  syncCommandContext();
                },
                onLayerVisibilityChanged: (id) => notifier!.toggleLayerVisibility(id),
                onObjectVisibilityChanged: (layerId, objectId) => 
                    notifier!.toggleObjectVisibility(layerId, objectId),
                
                onLayerReorder: (oldIndex, newIndex) {
                  notifier!.reorderLayer(oldIndex, newIndex);
                },
                onObjectReorder: (layerId, oldIndex, newIndex) {
                  notifier!.reorderObject(layerId, oldIndex, newIndex);
                },
                
                onAddLayer: _addLayer,
                
                onLayerDelete: _deleteLayer,
                onObjectDelete: (layerId, objectId) {
                  notifier!.deleteObject(layerId, objectId);
                },
                
                onLayerInspect: (layer) => _showLayerInspector(layer, resolver),
                onObjectInspect: (obj) => _inspectObject(obj, resolver),
              ),
            ),
          ],
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, stack) => Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Text('Error loading assets:\n$err', textAlign: TextAlign.center),
        ),
      ),
    );
  }

  @override
  void undo() {
    _notifier?.undo();
    syncCommandContext();
  }

  @override
  void redo() {
    _notifier?.redo();
    syncCommandContext();
  }

  @override
  Future<EditorContent> getContent() async {
    if (notifier == null) throw Exception("Map is not loaded");
    final writer = TmxWriter(notifier!.map);
    final newTmxContent = writer.toTmx();
    return EditorContentString(newTmxContent);
  }

  @override
  void onSaveSuccess(String newHash) {
    if (mounted) setState(() => _baseContentHash = newHash);
  }

  @override
  Future<TabHotStateDto?> serializeHotState() async => null;
}

// FILE: lib/editor/plugins/tiled_editor/tiled_export_service.dart

import 'dart:async';
import 'dart:typed_data';
import 'dart:ui' as ui;
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/app/app_notifier.dart';
import 'package:machine/data/file_handler/file_handler.dart';
import 'package:machine/data/repositories/project/project_repository.dart';
import 'package:machine/editor/plugins/tiled_editor/tiled_editor_plugin.dart';
import 'package:machine/editor/plugins/tiled_editor/tmj_writer.dart';
import 'package:machine/editor/plugins/tiled_editor/tmx_writer.dart';
import 'package:machine/editor/tab_metadata_notifier.dart';
import 'package:machine/logs/logs_provider.dart';
import 'package:tiled/tiled.dart';
import 'package:machine/editor/plugins/tiled_editor/image_load_result.dart';
import 'package:machine/asset_cache/asset_models.dart';

import 'tiled_map_notifier.dart';
import '../../../data/repositories/project/project_repository.dart';

final tiledExportServiceProvider = Provider<TiledExportService>((ref) {
  return TiledExportService(ref);
});


class _TileSourceInfo {
  final int oldGid;
  final Tile tile;
  final Tileset tileset;
  _TileSourceInfo(this.oldGid, this.tile, this.tileset);
}

class _PackAtlasResult {
  final TiledMap modifiedMap;
  final Uint8List atlasImageBytes;
  final String atlasImageName;
  _PackAtlasResult(this.modifiedMap, this.atlasImageBytes, this.atlasImageName);
}

class TiledExportService {
  final Ref _ref;
  TiledExportService(this._ref);

  Future<void> exportMap({
    required TiledMap map,
    required Map<String, AssetData> assetDataMap,
    required String destinationFolderUri,
    required String mapFileName,
    required String atlasFileName,
    required bool removeUnused,
    required bool asJson,
    required bool packInAtlas,
  }) async {
    final talker = _ref.read(talkerProvider);
    talker.info('Starting map export...');
    final repo = _ref.read(projectRepositoryProvider)!;
    final project = _ref.read(appNotifierProvider).value!.currentProject!;

    TiledMap mapToExport = _deepCopyMap(map);
    Uint8List? atlasImageBytes;
    String? finalAtlasImageName;

    if (removeUnused) {
      final usedGids = _findUsedGids(mapToExport);
      mapToExport.tilesets.removeWhere((tileset) {
        final firstGid = tileset.firstGid ?? 0;
        final lastGid = firstGid + (tileset.tileCount ?? 0) - 1;
        final isUsed = usedGids.any((gid) => gid >= firstGid && gid <= lastGid);
        if (!isUsed) {
          talker.info('Removing unused tileset: ${tileset.name}');
        }
        return !isUsed;
      });
    }
    
    if (packInAtlas) {
      final result = await _packAtlas(mapToExport, assetDataMap, atlasFileName);
      mapToExport = result.modifiedMap;
      atlasImageBytes = result.atlasImageBytes;
      finalAtlasImageName = result.atlasImageName;
    }

    final sourceMapFile = _ref.read(tabMetadataProvider)[_ref.read(appNotifierProvider).value!.currentProject!.session.currentTab!.id]!.file;
    final sourceMapFolderUri = repo.fileHandler.getParentUri(sourceMapFile.uri);

    final assetsToCopy = <String>{};
    if (packInAtlas) {
      for (final layer in mapToExport.layers) {
        if (layer is ImageLayer && layer.image.source != null) {
          assetsToCopy.add(layer.image.source!);
        }
      }
    } else {
      for (final tileset in mapToExport.tilesets) {
        if (tileset.image?.source != null) {
          assetsToCopy.add(tileset.image!.source!);
        }
      }
      for (final layer in mapToExport.layers) {
        if (layer is ImageLayer && layer.image.source != null) {
          assetsToCopy.add(layer.image.source!);
        }
      }
    }
    
    talker.info('Found ${assetsToCopy.length} external assets to copy.');

    for (final relativeAssetPath in assetsToCopy) {
      try {
        // in the TMX is relative to the TMX file itself.
        final assetFile = await repo.fileHandler.resolvePath(sourceMapFolderUri, relativeAssetPath);
        
        if (assetFile != null) {
          talker.info('Copying asset: ${assetFile.name}');
          await repo.copyDocumentFile(assetFile, destinationFolderUri);
        } else {
          talker.warning('Could not find asset to copy: $relativeAssetPath');
        }
      } catch (e, st) {
        talker.handle(e, st, 'Failed to copy asset: $relativeAssetPath');
      }
    }


    // 4. Generate the map file content.
    String fileContent;
    String fileExtension;
    if (asJson) {
      fileContent = TmjWriter(mapToExport).toTmj();
      fileExtension = 'json';
    } else {
      fileContent = TmxWriter(mapToExport).toTmx();
      fileExtension = 'tmx';
    }
    
    final finalMapFileName = '$mapFileName.$fileExtension';

    if (atlasImageBytes != null && finalAtlasImageName != null) {
      final atlasFile = await repo.createDocumentFile(
        destinationFolderUri,
        finalAtlasImageName!,
        initialBytes: atlasImageBytes,
        overwrite: true,
      );

    }
    
    final mapFile = await repo.createDocumentFile(
      destinationFolderUri,
      finalMapFileName,
      initialContent: fileContent,
      overwrite: true,
    );
    


    talker.info('Export complete: $mapFileName');
  }

  Future<_PackAtlasResult> _packAtlas(TiledMap map, Map<String, AssetData> assetDataMap, String atlasBaseName) async {
    _ref.read(talkerProvider).info('Starting atlas packing...');
    final usedGids = _findUsedGids(map);
    final uniqueTileSources = <int, _TileSourceInfo>{};

    for (final gid in usedGids) {
      if (uniqueTileSources.containsKey(gid)) continue;
      final tile = map.tileByGid(gid);
      if (tile != null && !tile.isEmpty) {
        final tileset = map.tilesetByTileGId(gid);
        uniqueTileSources[gid] = _TileSourceInfo(gid, tile, tileset);
      }
    }
    final sortedTiles = uniqueTileSources.values.toList();

    final int atlasWidth = 1024;
    final Map<int, ui.Rect> packedLayout = {};
    int currentX = 0;
    int currentY = 0;
    int maxYinRow = 0;
    for (final source in sortedTiles) {
      final tileWidth = source.tileset.tileWidth ?? map.tileWidth;
      final tileHeight = source.tileset.tileHeight ?? map.tileHeight;

      if (currentX + tileWidth > atlasWidth) {
        currentX = 0;
        currentY += maxYinRow;
        maxYinRow = 0;
      }
      packedLayout[source.oldGid] = ui.Rect.fromLTWH(
          currentX.toDouble(), currentY.toDouble(), tileWidth.toDouble(), tileHeight.toDouble());

      currentX += tileWidth;
      maxYinRow = max(maxYinRow, tileHeight);
    }
    final int atlasHeight = currentY + maxYinRow;
    
    final recorder = ui.PictureRecorder();
    final canvas = ui.Canvas(recorder);
    final paint = ui.Paint()..filterQuality = ui.FilterQuality.none;

    final allSourceImages = sortedTiles.map((e) => e.tileset.image?.source).toSet();
    
    for (final source in sortedTiles) {
      final destRect = packedLayout[source.oldGid]!;
      final tiledRect = source.tileset.computeDrawRect(source.tile);
      final sourceRect = ui.Rect.fromLTWH(
        tiledRect.left.toDouble(),
        tiledRect.top.toDouble(),
        tiledRect.width.toDouble(),
        tiledRect.height.toDouble(),
      );      
      final asset = assetDataMap[source.tileset.image!.source!];
      final sourceImage = asset is ImageAssetData ? asset.image : null;

      if (sourceImage != null) {
        canvas.drawImageRect(sourceImage, sourceRect, destRect, paint);
      }
    }
    
    final picture = recorder.endRecording();
    final image = await picture.toImage(atlasWidth, atlasHeight);
    final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
    final atlasImageBytes = byteData!.buffer.asUint8List();

    final atlasName = atlasBaseName;
    final atlasFileName = '$atlasName.png';
    final Map<int, int> gidRemapTable = {};
    int newLocalId = 0;

    final atlasTileset = Tileset(
      name: atlasName,
      firstGid: 1,
      tileWidth: map.tileWidth,
      tileHeight: map.tileHeight,
      tileCount: sortedTiles.length,
      columns: atlasWidth ~/ map.tileWidth,
      image: TiledImage(source: atlasFileName, width: atlasWidth, height: atlasHeight),
    );

    for (final source in sortedTiles) {
      gidRemapTable[source.oldGid] = atlasTileset.firstGid! + newLocalId;
      newLocalId++;
    }

    for (final layer in map.layers) {
      if (layer is TileLayer) {
        for (int y = 0; y < layer.height; y++) {
          for (int x = 0; x < layer.width; x++) {
            final oldGid = layer.tileData![y][x];
            if (oldGid.tile != 0) {
              final newGidTile = gidRemapTable[oldGid.tile];
              if (newGidTile != null) {
                layer.tileData![y][x] = Gid(newGidTile, oldGid.flips);
              }
            }
          }
        }
      } else if (layer is ObjectGroup) {
        for (final object in layer.objects) {
          if (object.gid != null) {
            final newGid = gidRemapTable[object.gid];
            if (newGid != null) {
              object.gid = newGid;
            }
          }
        }
      }
    }
    
    map.tilesets..clear()..add(atlasTileset);

    _ref.read(talkerProvider).info('Atlas packing complete.');
    return _PackAtlasResult(map, atlasImageBytes, atlasFileName);
  }

  Set<int> _findUsedGids(TiledMap map) {
    final usedGids = <int>{};
    for (final layer in map.layers) {
      if (layer is TileLayer && layer.tileData != null) {
        for (final row in layer.tileData!) {
          for (final gid in row) {
            if (gid.tile != 0) usedGids.add(gid.tile);
          }
        }
      } else if (layer is ObjectGroup) {
        for (final object in layer.objects) {
          if (object.gid != null) usedGids.add(object.gid!);
        }
      }
    }
    return usedGids;
  }
  
  TiledMap _deepCopyMap(TiledMap original) {
    final writer = TmxWriter(original);
    final tmxString = writer.toTmx();
    return TileMapParser.parseTmx(tmxString);
  }
}


extension TiledMapNameExtension on TiledMap {
  String? get name {
    return 'map';
  }
}

// FILE: lib/editor/plugins/tiled_editor/tiled_map_notifier.dart

import 'dart:math';
import 'dart:ui' as ui;
import 'package:flutter/material.dart' hide Text;
import 'package:tiled/tiled.dart';
import 'package:collection/collection.dart';
import '../../../asset_cache/asset_models.dart';

abstract class _HistoryAction {
  void undo(TiledMap map);
  void redo(TiledMap map);
}

class _WrapperAction implements _HistoryAction {
  final VoidCallback onUndo;
  final VoidCallback onRedo;
  _WrapperAction({required this.onUndo, required this.onRedo});

  @override
  void undo(TiledMap map) => onUndo();
  
  @override
  void redo(TiledMap map) => onRedo();
}

class _ObjectReorderHistoryAction implements _HistoryAction {
  final int layerId;
  final int oldIndex;
  final int newIndex;

  _ObjectReorderHistoryAction({
    required this.layerId,
    required this.oldIndex,
    required this.newIndex,
  });

  @override
  void undo(TiledMap map) {
    final layer = map.layers.firstWhereOrNull((l) => l.id == layerId);
    if (layer is ObjectGroup) {
      final item = layer.objects.removeAt(newIndex);
      layer.objects.insert(oldIndex, item);
    }
  }

  @override
  void redo(TiledMap map) {
    final layer = map.layers.firstWhereOrNull((l) => l.id == layerId);
    if (layer is ObjectGroup) {
      final item = layer.objects.removeAt(oldIndex);
      layer.objects.insert(newIndex, item);
    }
  }
}

class _TileSelectionHistoryAction implements _HistoryAction {
  final int layerId;
  final List<List<Gid>> beforeData;
  final List<List<Gid>> afterData;
  final Rect selectionRect;

  _TileSelectionHistoryAction({
    required this.layerId,
    required this.beforeData,
    required this.afterData,
    required this.selectionRect,
  });

  @override
  void undo(TiledMap map) {
    _applyState(map, beforeData);
  }

  @override
  void redo(TiledMap map) {
    _applyState(map, afterData);
  }

  void _applyState(TiledMap map, List<List<Gid>> data) {
    final layer =
        map.layers.firstWhereOrNull((l) => l.id == layerId) as TileLayer?;
    if (layer != null) {
      layer.tileData = data.map((row) => List<Gid>.from(row)).toList();
    }
  }
}

class _BulkTilesetRemovalHistoryAction implements _HistoryAction {
  final List<Tileset> removedTilesets;
  final List<int> originalIndices;

  _BulkTilesetRemovalHistoryAction({
    required this.removedTilesets,
    required this.originalIndices,
  });

  @override
  void undo(TiledMap map) {
    final items = IterableZip([originalIndices, removedTilesets]);
    final sortedItems = items.sorted((a, b) => (a[0] as int).compareTo(a[1] as int));
    for (final item in sortedItems) {
      map.tilesets.insert(item[0] as int, deepCopyTileset(item[1] as Tileset));
    }
  }

  @override
  void redo(TiledMap map) {
    final namesToRemove = removedTilesets.map((ts) => ts.name).toSet();
    map.tilesets.removeWhere((ts) => namesToRemove.contains(ts.name));
  }
}

class _LayerStructureHistoryAction implements _HistoryAction {
  final Layer layer;
  final int index;

  _LayerStructureHistoryAction({required this.layer, required this.index});

  @override
  void undo(TiledMap map) {
    map.layers.insert(index, layer);
  }

  @override
  void redo(TiledMap map) {
    map.layers.removeAt(index);
  }
}

class _LayerAddHistoryAction implements _HistoryAction {
  final Layer layer;
  final int index;

  _LayerAddHistoryAction({required this.layer, required this.index});

  @override
  void undo(TiledMap map) {
    map.layers.removeAt(index);
  }

  @override
  void redo(TiledMap map) {
    map.layers.insert(index, deepCopyLayer(layer));
  }
}

class _LayerReorderHistoryAction implements _HistoryAction {
  final int oldIndex;
  final int newIndex;

  _LayerReorderHistoryAction({required this.oldIndex, required this.newIndex});

  @override
  void undo(TiledMap map) {
    final item = map.layers.removeAt(newIndex);
    map.layers.insert(oldIndex, item);
  }

  @override
  void redo(TiledMap map) {
    final item = map.layers.removeAt(oldIndex);
    map.layers.insert(newIndex, item);
  }
}

class _ObjectGroupHistoryAction implements _HistoryAction {
  final int layerId;
  final List<TiledObject> beforeObjects;
  final List<TiledObject> afterObjects;

  _ObjectGroupHistoryAction(this.layerId, this.beforeObjects, this.afterObjects);

  @override
  void undo(TiledMap map) {
    final layer =
        map.layers.firstWhereOrNull((l) => l.id == layerId) as ObjectGroup?;
    if (layer != null) {
      layer.objects = beforeObjects.map(deepCopyTiledObject).toList();
    }
  }

  @override
  void redo(TiledMap map) {
    final layer =
        map.layers.firstWhereOrNull((l) => l.id == layerId) as ObjectGroup?;
    if (layer != null) {
      layer.objects = afterObjects.map(deepCopyTiledObject).toList();
    }
  }
}

class _PropertyChangeHistoryAction implements _HistoryAction {
  final Object beforeState;
  final Object afterState;

  _PropertyChangeHistoryAction(this.beforeState, this.afterState);

  @override
  void undo(TiledMap map) {
    _applyState(map, beforeState);
  }

  @override
  void redo(TiledMap map) {
    _applyState(map, afterState);
  }

void _applyState(TiledMap map, Object state) {
    if (state is TiledMap) {
      map.backgroundColorHex = state.backgroundColorHex;
      map.renderOrder = state.renderOrder;
    } else if (state is Layer) {
      final index = map.layers.indexWhere((l) => l.id == state.id);
      if (index != -1) {
        map.layers[index] = deepCopyLayer(state);
      }
    } else if (state is TiledObject) {
      for (final layer in map.layers) {
        if (layer is ObjectGroup) {
          final objIndex = layer.objects.indexWhere((o) => o.id == state.id);
          if (objIndex != -1) {
            layer.objects[objIndex] = deepCopyTiledObject(state);
            return;
          }
        }
      }
    } else if (state is Tileset) {
      final index = map.tilesets.indexWhere((ts) => ts.name == state.name);
      if (index != -1) {
        map.tilesets[index] = deepCopyTileset(state);
      }
    }
  }
}

class _TileLayerHistoryAction implements _HistoryAction {
  final int layerId;
  final List<List<Gid>> beforeData;
  final List<List<Gid>> afterData;
  _TileLayerHistoryAction(this.layerId, this.beforeData, this.afterData);

  @override
  void undo(TiledMap map) {
    final layer =
        map.layers.firstWhereOrNull((l) => l.id == layerId) as TileLayer?;
    if (layer != null) {
      layer.tileData = beforeData.map((row) => List<Gid>.from(row)).toList();
    }
  }

  @override
  void redo(TiledMap map) {
    final layer =
        map.layers.firstWhereOrNull((l) => l.id == layerId) as TileLayer?;
    if (layer != null) {
      layer.tileData = afterData.map((row) => List<Gid>.from(row)).toList();
    }
  }
}

class _TilesetHistoryAction implements _HistoryAction {
  final Tileset tileset;
  final int index;
  final bool wasAddOperation;

  _TilesetHistoryAction({
    required this.tileset,
    required this.index,
    required this.wasAddOperation,
  });

  @override
  void undo(TiledMap map) {
    if (wasAddOperation) {
      map.tilesets.removeAt(index);
    } else {
      map.tilesets.insert(index, deepCopyTileset(tileset));
    }
  }

  @override
  void redo(TiledMap map) {
    if (wasAddOperation) {
      map.tilesets.insert(index, deepCopyTileset(tileset));
    } else {
      map.tilesets.removeAt(index);
    }
  }
}

class TiledMapNotifier extends ChangeNotifier {
  TiledMap _map;

  final _undoStack = <_HistoryAction>[];
  final _redoStack = <_HistoryAction>[];
  static const _maxHistorySize = 30;

  List<List<Gid>>? _tileStrokeBeforeData;
  List<TiledObject>? _objectStrokeBeforeData;

  final List<TiledObject> _selectedObjects = [];
  Rect? _tileSelectionRect;
  List<List<Gid>>? _floatingSelection;
  Point? _floatingSelectionPosition;


  TiledMapNotifier(this._map);
  TiledMap get map => _map;
  bool get canUndo => _undoStack.isNotEmpty;
  bool get canRedo => _redoStack.isNotEmpty;
  List<TiledObject> get selectedObjects => List.unmodifiable(_selectedObjects);
  
  Rect? get tileSelectionRect => _tileSelectionRect;
  List<List<Gid>>? get floatingSelection => _floatingSelection;
  bool get hasFloatingSelection => _floatingSelection != null;
  Point? get floatingSelectionPosition => _floatingSelectionPosition;

  void selectObject(TiledObject obj, {bool clearExisting = true}) {
    if (clearExisting) {
      _selectedObjects.clear();
    }
    if (!_selectedObjects.contains(obj)) {
      _selectedObjects.add(obj);
    }
    notifyListeners();
  }

  void addSelection(TiledObject obj) {
    if (!_selectedObjects.contains(obj)) {
      _selectedObjects.add(obj);
      notifyListeners();
    }
  }

  void deselectObject(TiledObject obj) {
    if (_selectedObjects.remove(obj)) {
      notifyListeners();
    }
  }

  void clearSelection() {
    if (_selectedObjects.isNotEmpty) {
      _selectedObjects.clear();
      notifyListeners();
    }
  }

  void updateImageSource({
    required Object parentObject,
    required String newSourcePath,
    required int newWidth,
    required int newHeight,
  }) {
    final newTiledImage = TiledImage(
      source: newSourcePath,
      width: newWidth,
      height: newHeight,
    );

    Object? beforeState;
    Object? afterState;

    if (parentObject is Tileset) {
      final tilesetInMap = _map.tilesets.firstWhereOrNull((ts) => ts == parentObject);
      if (tilesetInMap != null) {
        beforeState = deepCopyTileset(tilesetInMap);
        tilesetInMap.image = newTiledImage;
        afterState = deepCopyTileset(tilesetInMap);
      }
    } else if (parentObject is ImageLayer) {
      final layerInMap = _map.layers.firstWhereOrNull((l) => l == parentObject) as ImageLayer?;
      if (layerInMap != null) {
        beforeState = deepCopyLayer(layerInMap);
        layerInMap.image = newTiledImage;
        afterState = deepCopyLayer(layerInMap);
      }
    }

    if (beforeState != null && afterState != null) {
      recordPropertyChange(beforeState, afterState);
    }
    
    notifyListeners();
  }


    void beginTileStroke(int layerId) {
    if (_tileStrokeBeforeData != null) return;
    final layer =
        _map.layers.firstWhereOrNull((l) => l.id == layerId) as TileLayer?;
    if (layer?.tileData == null) return;

    _tileStrokeBeforeData =
        layer!.tileData!.map((row) => List<Gid>.from(row)).toList();
  }

  void endTileStroke(int layerId) {
    if (_tileStrokeBeforeData == null) return;
    final layer =
        _map.layers.firstWhereOrNull((l) => l.id == layerId) as TileLayer?;
    if (layer?.tileData == null) return;

    final afterData =
        layer!.tileData!.map((row) => List<Gid>.from(row)).toList();
    _pushHistory(
        _TileLayerHistoryAction(layerId, _tileStrokeBeforeData!, afterData));
    _tileStrokeBeforeData = null;
  }

  void beginObjectChange(int layerId) {
    if (_objectStrokeBeforeData != null) return;
    final layer =
        _map.layers.firstWhereOrNull((l) => l.id == layerId) as ObjectGroup?;
    if (layer == null) return;
    _objectStrokeBeforeData =
        layer.objects.map(deepCopyTiledObject).toList();
  }

  void endObjectChange(int layerId) {
    if (_objectStrokeBeforeData == null) return;
    final layer =
        _map.layers.firstWhereOrNull((l) => l.id == layerId) as ObjectGroup?;
    if (layer == null) return;

    final afterObjects =
        layer.objects.map(deepCopyTiledObject).toList();
    _pushHistory(_ObjectGroupHistoryAction(
        layerId, _objectStrokeBeforeData!, afterObjects));
    _objectStrokeBeforeData = null;
  }

  void _pushHistory(_HistoryAction action) {
    _redoStack.clear();
    _undoStack.add(action);
    if (_undoStack.length > _maxHistorySize) {
      _undoStack.removeAt(0);
    }
    notifyListeners();
  }

  void undo() {
    if (!canUndo) return;
    final lastAction = _undoStack.removeLast();
    lastAction.undo(_map);
    _redoStack.add(lastAction);
    notifyListeners();
  }

  void redo() {
    if (!canRedo) return;
    final nextAction = _redoStack.removeLast();
    nextAction.redo(_map);
    _undoStack.add(nextAction);
    notifyListeners();
  }

  void setStamp(
    int startX,
    int startY,
    int layerId,
    Tileset tileset,
    Rect rect,
  ) {
    final layer = _map.layers.firstWhereOrNull((l) => l.id == layerId) as TileLayer?;
    if (layer == null || layer.tileData == null) return;

    for (int y = 0; y < rect.height; y++) {
      for (int x = 0; x < rect.width; x++) {
        final mapX = startX + x;
        final mapY = startY + y;
        if (mapX < 0 || mapX >= _map.width || mapY < 0 || mapY >= _map.height) continue;

        final tileX = (rect.left + x).toInt();
        final tileY = (rect.top + y).toInt();
        final columns = tileset.columns ?? 1;
        final tileIndex = tileY * columns + tileX;

        if (tileIndex >= (tileset.tileCount ?? 0)) continue;
        final newGid = Gid.fromInt((tileset.firstGid ?? 0) + tileIndex);
        layer.tileData![mapY][mapX] = newGid;
      }
    }

    notifyListeners();
  }

  void eraseTiles(int startX, int startY, int layerId, Rect rect) {
    final layer = _map.layers.firstWhereOrNull((l) => l.id == layerId) as TileLayer?;
    if (layer == null || layer.tileData == null) return;

    for (int y = 0; y < rect.height; y++) {
      for (int x = 0; x < rect.width; x++) {
        final mapX = startX + x;
        final mapY = startY + y;
        if (mapX < 0 || mapX >= _map.width || mapY < 0 || mapY >= _map.height) continue;
        layer.tileData![mapY][mapX] = Gid.fromInt(0);
      }
    }

    notifyListeners();
  }

  void bucketFill(
    int x,
    int y,
    int layerId,
    Tileset tileset,
    Rect selectionRect,
  ) {
    final layer = _map.layers.firstWhereOrNull((l) => l.id == layerId) as TileLayer?;
    if (layer == null || layer.tileData == null) return;
    if (x < 0 || x >= _map.width || y < 0 || y >= _map.height) return;

    final List<Gid> fillGids = [];
    for (int ty = 0; ty < selectionRect.height; ty++) {
      for (int tx = 0; tx < selectionRect.width; tx++) {
        final tileX = (selectionRect.left + tx).toInt();
        final tileY = (selectionRect.top + ty).toInt();
        final columns = tileset.columns ?? 1;
        final tileIndex = tileY * columns + tileX;
        if (tileIndex < (tileset.tileCount ?? 0)) {
          fillGids.add(Gid.fromInt((tileset.firstGid ?? 0) + tileIndex));
        }
      }
    }
    if (fillGids.isEmpty) return;

    final targetGid = layer.tileData![y][x];
    if (fillGids.any((g) => g.tile == targetGid.tile)) return;

    final random = Random();
    final queue = <(int, int)>[(x, y)];
    final visited = <(int, int)>{(x, y)};

    while (queue.isNotEmpty) {
      final (cx, cy) = queue.removeAt(0);
      layer.tileData![cy][cx] = fillGids[random.nextInt(fillGids.length)];

      const directions = [(-1, 0), (1, 0), (0, -1), (0, 1)];
      for (final (dx, dy) in directions) {
        final nx = cx + dx;
        final ny = cy + dy;

        if (nx >= 0 &&
            nx < _map.width &&
            ny >= 0 &&
            ny < _map.height &&
            !visited.contains((nx, ny)) &&
            layer.tileData![ny][nx].tile == targetGid.tile) {
          visited.add((nx, ny));
          queue.add((nx, ny));
        }
      }
    }

    notifyListeners();
  }
  
    void setTileSelection(Rect? rect, int layerId) {
    if (_floatingSelection != null) {
      stampFloatingSelection(layerId, cancelFloat: false);
    }
    _tileSelectionRect = rect;
    notifyListeners();
  }

  void cutSelection(int layerId) {
    final layer =_map.layers.firstWhereOrNull((l) => l.id == layerId) as TileLayer?;
    if (layer?.tileData == null || _tileSelectionRect == null) return;

    beginTileStroke(layerId);

    final rect = _tileSelectionRect!;
    _floatingSelection = [];
    for (int y = 0; y < rect.height; y++) {
      final row = <Gid>[];
      for (int x = 0; x < rect.width; x++) {
        final mapX = (rect.left + x).toInt();
        final mapY = (rect.top + y).toInt();
        if (mapX < 0 || mapX >= _map.width || mapY < 0 || mapY >= _map.height) {
          row.add(Gid.fromInt(0));
          continue;
        }
        row.add(layer!.tileData![mapY][mapX]);
        layer!.tileData![mapY][mapX] = Gid.fromInt(0);
      }
      _floatingSelection!.add(row);
    }

    _floatingSelectionPosition = Point(x:rect.left, y:rect.top);
    _tileSelectionRect = null;
    
    endTileStroke(layerId);
    notifyListeners();
  }
  
  void updateFloatingSelectionPosition(Point newPosition) {
    if (_floatingSelectionPosition != newPosition) {
      _floatingSelectionPosition = newPosition;
      notifyListeners();
    }
  }
  
  void stampFloatingSelection(int layerId, {bool cancelFloat = true}) {
    final layer = _map.layers.firstWhereOrNull((l) => l.id == layerId) as TileLayer?;
    if (layer?.tileData == null || _floatingSelection == null || _floatingSelectionPosition == null) return;

    beginTileStroke(layerId);

    final floatData = _floatingSelection!;
    final position = _floatingSelectionPosition!;

    for (int y = 0; y < floatData.length; y++) {
      for (int x = 0; x < floatData[y].length; x++) {
        final gid = floatData[y][x];
        if (gid.tile == 0) continue;

        final mapX = (position.x + x).toInt();
        final mapY = (position.y + y).toInt();

        if (mapX >= 0 && mapX < _map.width && mapY >= 0 && mapY < _map.height) {
          layer!.tileData![mapY][mapX] = gid;
        }
      }
    }

    endTileStroke(layerId);
    
    if (cancelFloat) {
      _floatingSelection = null;
      _floatingSelectionPosition = null;
    }
    notifyListeners();
  }
  
  void toggleObjectVisibility(int layerId, int objectId) {
    final layer = _map.layers.firstWhereOrNull((l) => l.id == layerId);
    if (layer is ObjectGroup) {
      final object = layer.objects.firstWhereOrNull((o) => o.id == objectId);
      if (object != null) {
        final before = deepCopyTiledObject(object);
        object.visible = !object.visible;
        final after = deepCopyTiledObject(object);
        
        recordPropertyChange(before, after);
        notifyListeners();
      }
    }
  }

  void deleteObject(int layerId, int objectId) {
    final layer = _map.layers.firstWhereOrNull((l) => l.id == layerId) as ObjectGroup?;
    if (layer == null) return;

    beginObjectChange(layerId);

    final object = layer.objects.firstWhereOrNull((o) => o.id == objectId);
    if (object != null) {
      layer.objects.remove(object);
      
      if (_selectedObjects.contains(object)) {
        _selectedObjects.remove(object);
      }
    }

    endObjectChange(layerId);
    notifyListeners();
  }

  void deleteFloatingSelection() {
    if (_floatingSelection != null) {
      _floatingSelection = null;
      _floatingSelectionPosition = null;
      notifyListeners();
    }
  }

 void reorderLayer(int oldIndex, int newIndex) {
    final item = _map.layers.removeAt(oldIndex);
    _map.layers.insert(newIndex, item);

    _pushHistory(_LayerReorderHistoryAction(oldIndex: oldIndex, newIndex: newIndex));
    notifyListeners();
  }

void toggleLayerVisibility(int layerId) {
    final layer = _map.layers.firstWhereOrNull((l) => l.id == layerId);
    if (layer != null) {
      final beforeState = deepCopyLayer(layer);
      layer.visible = !layer.visible;
      final afterState = deepCopyLayer(layer);
      
      recordPropertyChange(beforeState, afterState);
      notifyListeners();
    }
  }
  
  void recordPropertyChange(Object before, Object after) {
    _pushHistory(_PropertyChangeHistoryAction(before, after));
  }

  void updateMapProperties({
    required int width,
    required int height,
    required int tileWidth,
    required int tileHeight,
  }) {
    final oldLayersData = <int, List<List<Gid>>>{};
    for (final layer in _map.layers) {
      if (layer is TileLayer && layer.tileData != null) {
        oldLayersData[layer.id!] = layer.tileData!;
      }
    }

    _map.width = width;
    _map.height = height;
    _map.tileWidth = tileWidth;
    _map.tileHeight = tileHeight;

    for (final layer in _map.layers) {
      if (layer is TileLayer) {
        final oldData = oldLayersData[layer.id];
        final oldHeight = oldData?.length ?? 0;
        final oldWidth = oldHeight > 0 ? (oldData?[0].length ?? 0) : 0;

        layer.width = width;
        layer.height = height;
        layer.tileData = List.generate(
          height,
          (y) => List.generate(width, (x) {
            if (y < oldHeight && x < oldWidth) {
              return oldData![y][x];
            }
            return Gid.fromInt(0);
          }),
        );
      }
    }
    notifyListeners();
  }

  Future<void> addTileset(Tileset newTileset) async {
    _map.tilesets.add(newTileset);

    _pushHistory(_TilesetHistoryAction(
      tileset: newTileset,
      index: _map.tilesets.length - 1,
      wasAddOperation: true,
    ));

    if (_map.tilesets.length == 1) {
      _map.tileWidth = newTileset.tileWidth ?? _map.tileWidth;
      _map.tileHeight = newTileset.tileHeight ?? _map.tileHeight;
    }
    notifyListeners();
  }
  
  void deleteTileset(Tileset tilesetToDelete) {
    final index = _map.tilesets.indexWhere((ts) => ts.name == tilesetToDelete.name);
    if (index == -1) return;

    final tileset = _map.tilesets.removeAt(index);

    _pushHistory(_TilesetHistoryAction(
      tileset: tileset,
      index: index,
      wasAddOperation: false,
    ));
    notifyListeners();
  }
  
  List<Tileset> findUnusedTilesets() {
    final usedGids = <int>{};
    for (final layer in _map.layers) {
      if (layer is TileLayer && layer.tileData != null) {
        for (final row in layer.tileData!) {
          for (final gid in row) {
            if (gid.tile != 0) {
              usedGids.add(gid.tile);
            }
          }
        }
      } else if (layer is ObjectGroup) {
        for (final object in layer.objects) {
          if (object.gid != null) {
            usedGids.add(object.gid!);
          }
        }
      }
    }

    final unused = <Tileset>[];
    for (final tileset in _map.tilesets) {
      final firstGid = tileset.firstGid ?? 0;
      final lastGid = firstGid + (tileset.tileCount ?? 0) - 1;
      final isUsed = usedGids.any((gid) => gid >= firstGid && gid <= lastGid);
      if (!isUsed) {
        unused.add(tileset);
      }
    }
    return unused;
  }

  void removeTilesets(List<Tileset> tilesetsToRemove) {
    if (tilesetsToRemove.isEmpty) return;

    final removedTilesets = <Tileset>[];
    final originalIndices = <int>[];
    
    final namesToRemove = tilesetsToRemove.map((ts) => ts.name).toSet();
    
    for (int i = _map.tilesets.length - 1; i >= 0; i--) {
      final tileset = _map.tilesets[i];
      if (namesToRemove.contains(tileset.name)) {
        final removed = _map.tilesets.removeAt(i);
        removedTilesets.insert(0, removed);
        originalIndices.insert(0, i);
      }
    }

    if(removedTilesets.isNotEmpty) {
        _pushHistory(_BulkTilesetRemovalHistoryAction(
          removedTilesets: removedTilesets,
          originalIndices: originalIndices,
        ));
        notifyListeners();
    }
  }

void addLayer({required String name, required LayerType type}) {
    final int newLayerId;
    if (_map.nextLayerId != null) {
      newLayerId = _map.nextLayerId!;
    } else {
      final maxId = _map.layers
          .map((l) => l.id ?? 0)
          .fold(0, (max, id) => id > max ? id : max);
      newLayerId = maxId + 1;
    }
    _map.nextLayerId = newLayerId + 1;

    Layer? newLayer;
    switch (type) {
      case LayerType.tileLayer:
        final layer = TileLayer(
          id: newLayerId,
          name: name,
          width: _map.width,
          height: _map.height,
        );
        layer.tileData = List.generate(
          _map.height,
          (_) => List.generate(_map.width, (_) => Gid.fromInt(0)),
        );
        newLayer = layer;
        break;
      case LayerType.objectGroup:
        newLayer = ObjectGroup(id: newLayerId, name: name, objects: []);
        break;
      
      case LayerType.imageLayer:
        newLayer = ImageLayer(
          id: newLayerId,
          name: name,
          image: TiledImage(source: ''),
          repeatX: false,
          repeatY: false,
        );
        break;
      case LayerType.group:
        newLayer = Group(
          id: newLayerId,
          name: name,
          layers: [],
        );
        break;
      default:
        break;
    }

    if (newLayer != null) {
      _map.layers.add(newLayer);
      _pushHistory(_LayerAddHistoryAction(
        layer: newLayer,
        index: _map.layers.length - 1,
      ));
    }
    notifyListeners();
  }

  void renameLayer(int layerId, String newName) {
    final layer = _map.layers.firstWhereOrNull((l) => l.id == layerId);
    if (layer != null && layer.name != newName) {
      layer.name = newName;
      notifyListeners();
    }
  }
  
  void deleteLayer(int layerId) {
    final index = _map.layers.indexWhere((l) => l.id == layerId);
    if (index == -1) return;

    final layerToRemove = _map.layers.removeAt(index);

    _pushHistory(
      _LayerStructureHistoryAction(layer: layerToRemove, index: index),
    );
    notifyListeners();
  }
  
  void reorderObject(int layerId, int oldIndex, int newIndex) {
    final layer = _map.layers.firstWhereOrNull((l) => l.id == layerId);
    if (layer is! ObjectGroup) return;

    if (oldIndex < newIndex) {
      newIndex -= 1;
    }
    
    newIndex = newIndex.clamp(0, layer.objects.length - 1);

    if (oldIndex == newIndex) return;

    final obj = layer.objects.removeAt(oldIndex);
    layer.objects.insert(newIndex, obj);

    _pushHistory(_ObjectReorderHistoryAction(
      layerId: layerId,
      oldIndex: oldIndex,
      newIndex: newIndex,
    ));
    notifyListeners();
  }

  void deleteSelectedObjects(int layerId) {
    final layer =
        _map.layers.firstWhereOrNull((l) => l.id == layerId) as ObjectGroup?;
    if (layer == null || _selectedObjects.isEmpty) return;

    beginObjectChange(layerId);

    final selectedIds = _selectedObjects.map((o) => o.id).toSet();
    layer.objects.removeWhere((obj) => selectedIds.contains(obj.id));
    _selectedObjects.clear();

    endObjectChange(layerId);
  }
}

TiledObject deepCopyTiledObject(TiledObject other) {
  return TiledObject(
    id: other.id,
    name: other.name,
    type: other.type,
    x: other.x,
    y: other.y,
    width: other.width,
    height: other.height,
    rotation: other.rotation,
    gid: other.gid,
    visible: other.visible,
    rectangle: other.rectangle,
    ellipse: other.ellipse,
    point: other.point,
    polygon: List<Point>.from(other.polygon.map((p) => Point(x: p.x, y: p.y))),
    polyline: List<Point>.from(other.polyline.map((p) => Point(x: p.x, y: p.y))),
    text: other.text != null
        ? Text(
            text: other.text!.text,
            fontFamily: other.text!.fontFamily,
            pixelSize: other.text!.pixelSize,
            wrap: other.text!.wrap,
            color: other.text!.color,
            bold: other.text!.bold,
            italic: other.text!.italic,
            underline: other.text!.underline,
            strikeout: other.text!.strikeout,
            kerning: other.text!.kerning,
            hAlign: other.text!.hAlign,
            vAlign: other.text!.vAlign,
          )
        : null,
    properties: CustomProperties(
        {for (var p in other.properties) p.name: Property(name: p.name, type: p.type, value: p.value)}),
  );
}

Layer deepCopyLayer(Layer other) {
  if (other is TileLayer) {
    return TileLayer(
      id: other.id,
      name: other.name,
      width: other.width,
      height: other.height,
      class_: other.class_,
      x: other.x,
      y: other.y,
      offsetX: other.offsetX,
      offsetY: other.offsetY,
      parallaxX: other.parallaxX,
      parallaxY: other.parallaxY,
      startX: other.startX,
      startY: other.startY,
      tintColorHex: other.tintColorHex,
      tintColor: other.tintColor,
      opacity: other.opacity,
      visible: other.visible,
      properties: CustomProperties(Map.from(other.properties.byName)),
      compression: other.compression,
      encoding: other.encoding,
      chunks: other.chunks,
    )..tileData = other.tileData?.map((row) => List<Gid>.from(row)).toList();
  }
if (other is ObjectGroup) {
    return ObjectGroup(
      id: other.id,
      name: other.name,
      objects: other.objects.map(deepCopyTiledObject).toList(),
      drawOrder: other.drawOrder,
      color: other.color,
      class_: other.class_,
      x: other.x,
      y: other.y,
      offsetX: other.offsetX,
      offsetY: other.offsetY,
      parallaxX: other.parallaxX,
      parallaxY: other.parallaxY,
      startX: other.startX,
      startY: other.startY,
      tintColorHex: other.tintColorHex,
      tintColor: other.tintColor,
      opacity: other.opacity,
      visible: other.visible,
      properties: CustomProperties(Map.from(other.properties.byName)),
      colorHex: other.colorHex,
    );
  }
  if (other is ImageLayer) {
    return ImageLayer(
      id: other.id,
      name: other.name,
      image: other.image,
      repeatX: other.repeatX,
      repeatY: other.repeatY,
      class_: other.class_,
      x: other.x,
      y: other.y,
      offsetX: other.offsetX,
      offsetY: other.offsetY,
      parallaxX: other.parallaxX,
      parallaxY: other.parallaxY,
      startX: other.startX,
      startY: other.startY,
      tintColorHex: other.tintColorHex,
      tintColor: other.tintColor,
      opacity: other.opacity,
      visible: other.visible,
      properties: CustomProperties(Map.from(other.properties.byName)),
      transparentColorHex: other.transparentColorHex,
      transparentColor: other.transparentColor,
    );
  }
  return other;
}

Tileset deepCopyTileset(Tileset other) {
  return Tileset(
    name: other.name,
    firstGid: other.firstGid,
    tileWidth: other.tileWidth,
    tileHeight: other.tileHeight,
    spacing: other.spacing,
    margin: other.margin,
    tileCount: other.tileCount,
    columns: other.columns,
    objectAlignment: other.objectAlignment,
    image: other.image != null
        ? TiledImage(
            source: other.image!.source,
            width: other.image!.width,
            height: other.image!.height,
          )
        : null,
    tiles: other.tiles.map((t) => Tile(localId: t.localId)).toList(),
  );
}

// FILE: lib/editor/plugins/tiled_editor/tiled_map_painter.dart

import 'dart:ui' as ui;
import 'dart:typed_data';
import 'package:flutter/foundation.dart'hide StringProperty;
import 'package:flutter/material.dart' hide StringProperty;
import 'package:tiled/tiled.dart';
import 'package:vector_math/vector_math_64.dart' as vector;
import 'tiled_editor_settings_model.dart';
import '../../../asset_cache/asset_models.dart';
import 'package:path/path.dart' as p;
import 'tiled_asset_resolver.dart';

class TiledMapPainter extends CustomPainter {
  final TiledMap map;
  final TiledAssetResolver resolver;
  final bool showGrid;
  final Matrix4 transform;
  
  final List<TiledObject> selectedObjects;
  final Rect? previewShape;
  final List<Point> inProgressPoints;
  final Rect? marqueeSelection;
  final TiledEditorSettings settings;
  final List<List<Gid>>? floatingSelection;
  final Point? floatingSelectionPosition;


  final Map<int, TextPainter> _textPainterCache = {};

  TiledMapPainter({
    required this.map,
    required this.resolver,
    required this.showGrid,
    required this.transform,
    this.selectedObjects = const [],
    this.previewShape,
    this.inProgressPoints = const [],
    this.marqueeSelection,
    required this.settings,
    this.floatingSelection,
    this.floatingSelectionPosition,
  });
  

  @override
  void paint(Canvas canvas, Size size) {
    final visibleRect = canvas.getDestinationClipBounds();
    
    _paintLayerGroup(canvas, map.layers, 1.0, visibleRect);
    if (floatingSelection != null && floatingSelectionPosition != null) {
      _paintFloatingSelection(canvas);
    }

    _paintObjectPreviews(canvas);

    if (showGrid) {
      final startX = (visibleRect.left / map.tileWidth - 1).floor().clamp(0, map.width);
      final startY = (visibleRect.top / map.tileHeight - 1).floor().clamp(0, map.height);
      final endX = (visibleRect.right / map.tileWidth + 1).ceil().clamp(0, map.width);
      final endY = (visibleRect.bottom / map.tileHeight + 1).ceil().clamp(0, map.height);
      _paintGrid(canvas, startX, startY, endX, endY);
    }
  }
  
  TexturePackerSpriteData? _findSpriteData(String spriteName) {
    for (final asset in resolver.rawAssets.values) {
      if (asset is TexturePackerAssetData) {
        if (asset.frames.containsKey(spriteName)) {
          return asset.frames[spriteName];
        }
        if (asset.animations.containsKey(spriteName)) {
          final firstFrame = asset.animations[spriteName]!.firstOrNull;
          if (firstFrame != null && asset.frames.containsKey(firstFrame)) {
            return asset.frames[firstFrame];
          }
        }
      }
    }
    return null;
  }
  
  void _paintFloatingSelection(Canvas canvas) {
    final selection = floatingSelection!;
    final position = floatingSelectionPosition!;
    
    final Map<ui.Image, List<RSTransform>> transforms = {};
    final Map<ui.Image, List<Rect>> rects = {};

    for (int y = 0; y < selection.length; y++) {
      for (int x = 0; x < selection[y].length; x++) {
        final gid = selection[y][x];
        if (gid.tile == 0) continue;

        final tile = map.tileByGid(gid.tile);
        if (tile == null || tile.isEmpty) continue;
        
        final tileset = map.tilesetByTileGId(gid.tile);
        final imageSource = tile.image?.source ?? tileset.image?.source;
        if (imageSource == null) continue;

    final image = resolver.getImage(imageSource, tileset: tileset);
        if (image == null) continue;

        final srcRect = tileset.computeDrawRect(tile);
        final source = Rect.fromLTWH(srcRect.left.toDouble(), srcRect.top.toDouble(), srcRect.width.toDouble(), srcRect.height.toDouble());
        final tileWidth = (tileset.tileWidth ?? map.tileWidth).toDouble();
        final tileHeight = (tileset.tileHeight ?? map.tileHeight).toDouble();

        final dst = Rect.fromLTWH(
          ((position.x + x) * map.tileWidth).toDouble(),
          ((position.y + y) * map.tileHeight).toDouble() + map.tileHeight - tileHeight,
          tileWidth,
          tileHeight,
        );

        final transform = RSTransform.fromComponents(
            rotation: 0.0, scale: 1.0, anchorX: 0, anchorY: 0,
            translateX: dst.left, translateY: dst.top);
        
        transforms.putIfAbsent(image, () => []).add(transform);
        rects.putIfAbsent(image, () => []).add(source);
      }
    }
    
    final paint = Paint()..filterQuality = FilterQuality.none;
    for (final image in transforms.keys) {
      canvas.drawAtlas(image, transforms[image]!, rects[image]!, null, BlendMode.src, null, paint);
    }
    
    final selectionRect = Rect.fromLTWH(
      (position.x * map.tileWidth).toDouble(),
      (position.y * map.tileHeight).toDouble(),
      (selection.isNotEmpty ? selection[0].length : 0) * map.tileWidth.toDouble(),
      selection.length * map.tileHeight.toDouble(),
    );
    final borderPaint = Paint()
      ..color = Colors.amber
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.0;
    canvas.drawRect(selectionRect, borderPaint);
  }
  
  void _paintObjectPreviews(Canvas canvas) {
    if (selectedObjects.isNotEmpty) {
      final paint = Paint()
        ..color = Colors.blue.withOpacity(0.3)
        ..style = PaintingStyle.fill;
      final strokePaint = Paint()
        ..color = Colors.blue
        ..strokeWidth = 2.0
        ..style = PaintingStyle.stroke;

      for (final obj in selectedObjects) {
        final rect = Rect.fromLTWH(obj.x, obj.y, obj.width, obj.height);
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
      }
    }
    
    if (marqueeSelection != null) {
      final paint = Paint()
        ..color = Colors.blue.withOpacity(0.2)
        ..style = PaintingStyle.fill;
      final strokePaint = Paint()
        ..color = Colors.blue.withOpacity(0.8)
        ..strokeWidth = 1.0
        ..style = PaintingStyle.stroke;
      canvas.drawRect(marqueeSelection!, paint);
      canvas.drawRect(marqueeSelection!, strokePaint);
    }

    if (inProgressPoints.isNotEmpty) {
      final paint = Paint()
        ..color = Colors.amber
        ..strokeWidth = 2.0
        ..style = PaintingStyle.stroke;
      final path = Path();
      path.moveTo(inProgressPoints.first.x, inProgressPoints.first.y);
      for (var i = 1; i < inProgressPoints.length; i++) {
        path.lineTo(inProgressPoints[i].x, inProgressPoints[i].y);
      }
      canvas.drawPath(path, paint);
    }

    if (previewShape != null) {
      final paint = Paint()
        ..color = Colors.amber.withOpacity(0.5)
        ..style = PaintingStyle.fill;
      canvas.drawRect(previewShape!, paint);
    }
  }

  void _paintLayerGroup(Canvas canvas, List<Layer> layers, double parentOpacity, Rect visibleRect) {
    for (final layer in layers) {
      if (!layer.visible) continue;

      final combinedOpacity = parentOpacity * layer.opacity;

      canvas.save();

      if (combinedOpacity < 1.0) {
        final paint = Paint()..color = Color.fromRGBO(0, 0, 0, combinedOpacity);
        canvas.saveLayer(visibleRect, paint);
      }
      
      if (layer is Group) {
        canvas.translate(layer.offsetX, layer.offsetY);
        _paintLayerGroup(canvas, layer.layers, combinedOpacity, visibleRect);
      } else {
        if (layer is TileLayer) {
          canvas.translate(layer.offsetX, layer.offsetY);
          _paintTileLayer(canvas, layer);
        } else if (layer is ImageLayer) {
          _paintImageLayer(canvas, layer, visibleRect);
        } else if (layer is ObjectGroup) {
          canvas.translate(layer.offsetX, layer.offsetY);
          _paintObjectGroup(canvas, layer);
        }
      }

      if (combinedOpacity < 1.0) {
        canvas.restore();
      }
      canvas.restore();
    }
  }

  void _paintGrid(Canvas canvas, int startX, int startY, int endX, int endY) {
    final paint = Paint()
      ..color = Color(settings.gridColorValue)
      ..strokeWidth = settings.gridThickness;

    for (var x = startX; x <= endX; x++) {
      final lineX = (x * map.tileWidth).toDouble();
      canvas.drawLine(
        Offset(lineX, startY * map.tileHeight.toDouble()),
        Offset(lineX, endY * map.tileHeight.toDouble()),
        paint,
      );
    }
    for (var y = startY; y <= endY; y++) {
      final lineY = (y * map.tileHeight).toDouble();
      canvas.drawLine(
        Offset(startX * map.tileWidth.toDouble(), lineY),
        Offset(endX * map.tileWidth.toDouble(), lineY),
        paint,
      );
    }
  }

  void _paintTileLayer(Canvas canvas, TileLayer layer) {
    final visibleRect = canvas.getDestinationClipBounds();
    final startX = (visibleRect.left / map.tileWidth - 1).floor().clamp(0, layer.width);
    final startY = (visibleRect.top / map.tileHeight - 1).floor().clamp(0, layer.height);
    final endX = (visibleRect.right / map.tileWidth + 1).ceil().clamp(0, layer.width);
    final endY = (visibleRect.bottom / map.tileHeight + 1).ceil().clamp(0, layer.height);

    if (layer.tileData == null) return;

    final Map<ui.Image, List<RSTransform>> transforms = {};
    final Map<ui.Image, List<Rect>> rects = {};

    for (var y = startY; y < endY; y++) {
      for (var x = startX; x < endX; x++) {
        if (x >= layer.width || y >= layer.height) continue;
        final gid = layer.tileData![y][x];
        if (gid.tile == 0) continue;

        final tile = map.tileByGid(gid.tile);
        if (tile == null || tile.isEmpty) continue;

        final tileset = map.tilesetByTileGId(gid.tile);
        final imageSource = tile.image?.source ?? tileset.image?.source;
        if (imageSource == null) continue;
        final image = resolver.getImage(imageSource, tileset: tileset);
        
        final srcRect = tileset.computeDrawRect(tile);
        final source = Rect.fromLTWH(
          srcRect.left.toDouble(),
          srcRect.top.toDouble(),
          srcRect.width.toDouble(),
          srcRect.height.toDouble(),
        );

        final tileWidth = (tileset.tileWidth ?? map.tileWidth).toDouble();
        final tileHeight = (tileset.tileHeight ?? map.tileHeight).toDouble();

        final dst = Rect.fromLTWH(
          (x * map.tileWidth).toDouble(),
          (y * map.tileHeight).toDouble() + map.tileHeight - tileHeight,
          tileWidth,
          tileHeight,
        );
        
        if (image == null) {
          _drawMissingImagePlaceholder(canvas, dst, imageSource ?? 'Unknown');
          continue;
        }

        
        final needsFlip = gid.flips.horizontally || gid.flips.vertically || gid.flips.diagonally;

        if (!needsFlip) {
          transforms.putIfAbsent(image, () => []);
          rects.putIfAbsent(image, () => []);
          
          final transform = RSTransform.fromComponents(
            rotation: 0.0,
            scale: 1.0,
            anchorX: 0,
            anchorY: 0,
            translateX: dst.left,
            translateY: dst.top,
          );
          
          transforms[image]!.add(transform);
          rects[image]!.add(source);

        } else {
          canvas.save();
          canvas.translate(dst.left + dst.width / 2, dst.top + dst.height / 2);

          if (gid.flips.diagonally) {
            canvas.transform(Float64List.fromList([0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]));
          }
          if (gid.flips.horizontally) {
            canvas.scale(-1.0, 1.0);
          }
          if (gid.flips.vertically) {
            canvas.scale(1.0, -1.0);
          }
          
          canvas.translate(-dst.width / 2, -dst.height / 2);
          
          canvas.drawImageRect(
            image,
            source,
            Rect.fromLTWH(0, 0, dst.width, dst.height),
            Paint()..filterQuality = FilterQuality.none,
          );
          canvas.restore();
        }
        
        if (tile.objectGroup != null && tile.objectGroup is ObjectGroup) {
          final collisionGroup = tile.objectGroup as ObjectGroup;
          canvas.save();
          canvas.translate(dst.left, dst.top);
          _paintObjectGroup(canvas, collisionGroup, isForTile: true);
          canvas.restore();
        }
      }
    }
    
    final paint = Paint()..filterQuality = FilterQuality.none;
    for (final image in transforms.keys) {
      canvas.drawAtlas(
        image,
        transforms[image]!,
        rects[image]!,
        null,
        BlendMode.src,
        null,
        paint,
      );
    }
  }
  
  void _paintImageLayer(Canvas canvas, ImageLayer layer, Rect visibleRect) {
    if (layer.image.source == null) return;
    final image = resolver.getImage(layer.image.source); 

    if (image == null) {
        _drawMissingImagePlaceholder(canvas, Rect.fromLTWH(layer.offsetX, layer.offsetY, (layer.image.width ?? 100).toDouble(), (layer.image.height ?? 100).toDouble()), layer.image.source ?? 'Unknown');
        return;
    }

    final invertedMatrix = Matrix4.tryInvert(transform);
    if (invertedMatrix == null) return;

    final originalTranslation = transform.getTranslation();
    final originalScale = transform.getMaxScaleOnAxis();
    
    final totalOffsetX = layer.offsetX ;
    final totalOffsetY = - layer.offsetY ;

    final scaleX = (layer.image.width ?? image.width) / image.width;
    final scaleY = (layer.image.height ?? image.height) / image.height;
    
    
    final offsetMatrix = Matrix4.identity()
    ..translate(totalOffsetX, totalOffsetY)
    ..scale(scaleX, scaleY, 1);
    
    final transformWithoutTranslation = Matrix4.copy(transform)
    ..setTranslation(vector.Vector3.zero());
    
    
    
    final matrix = Matrix4.copy(invertedMatrix)
    ..multiply(transform)
    ..multiply(offsetMatrix);


    final shader = ImageShader(
      image,
      layer.repeatX ? TileMode.repeated : TileMode.clamp,
      layer.repeatY ? TileMode.repeated : TileMode.clamp,
      matrix.storage,
    );

    final paint = Paint()
      ..shader = shader
      ..filterQuality = FilterQuality.none;

    canvas.drawPaint(paint);
  }
  
Matrix4 applyParallax(
  Matrix4 transform,
  vector.Vector3 parallaxFactors,
) {
  final scale = vector.Vector3(
    vector.Vector3(transform[0], transform[1], transform[2]).length,
    vector.Vector3(transform[4], transform[5], transform[6]).length,
    vector.Vector3(transform[8], transform[9], transform[10]).length,
  );
  
  final zoomAffectedTranslation = transform.getTranslation();
  
  final worldTranslation = vector.Vector3(
    zoomAffectedTranslation.x / scale.x,
    zoomAffectedTranslation.y / scale.y,
    zoomAffectedTranslation.z / scale.z,
  );
  
  final parallaxTranslation = vector.Vector3(
    (worldTranslation.x * parallaxFactors.x),
    (worldTranslation.y * parallaxFactors.y),
    (worldTranslation.z),
  );
  
  
  final parallaxTransform = Matrix4.identity()
    ..setTranslation(parallaxTranslation);
  
  return parallaxTransform..multiply(Matrix4.tryInvert(transform) ?? Matrix4.identity());
}
  
  void _paintObjectGroup(Canvas canvas, ObjectGroup layer, {bool isForTile = false}) {
    final paint = isForTile
        ? (Paint()..color = Colors.lightGreen.withOpacity(0.5))
        : (Paint()..color = layer.color.toFlutterColor().withOpacity(0.5));
    paint.style = PaintingStyle.fill;
    
    final strokePaint = isForTile
        ? (Paint()..color = Colors.lightGreen)
        : (Paint()..color = layer.color.toFlutterColor());
    strokePaint.style = PaintingStyle.stroke;
    strokePaint.strokeWidth = 2.0;

    var objects = layer.objects;
    if (layer.drawOrder == DrawOrder.topDown) {
      objects = List.from(layer.objects)..sort((a, b) => a.y.compareTo(b.y));
    }
    
    for (final object in objects) {
      if (!object.visible) continue;

      canvas.save();
      
      final tpSpriteProp = object.properties.where((p) => p.name == 'tp_sprite').firstOrNull;
      final String? spriteName = (tpSpriteProp is StringProperty) ? tpSpriteProp.value : null;

      
      if (object.rotation != 0) {
        canvas.translate(object.x + object.width / 2, object.y + object.height / 2);
        canvas.rotate(vector.radians(object.rotation));
        canvas.translate(-(object.x + object.width / 2), -(object.y + object.height / 2));
      }
      
      bool customDrawDone = false;

      if (spriteName != null && spriteName.isNotEmpty) {
        final spriteData = _findSpriteData(spriteName);
        if (spriteData != null) {
          
          final srcRect = spriteData.sourceRect;
          final dstRect = Rect.fromLTWH(object.x, object.y, object.width, object.height);
          
          final drawRect = (object.width == 0 && object.height == 0)
              ? Rect.fromLTWH(object.x, object.y - srcRect.height, srcRect.width, srcRect.height)
              : dstRect;

          
          canvas.drawImageRect(
            spriteData.sourceImage, 
            srcRect, 
            drawRect, 
            Paint()..filterQuality = ui.FilterQuality.none
          );
          
          if (selectedObjects.contains(object)) {
             final strokePaint = Paint()..color = Colors.blue ..style=PaintingStyle.stroke ..strokeWidth=2;
             canvas.drawRect(drawRect, strokePaint);
          }
          
          customDrawDone = true;
        }
      }

      if (!customDrawDone) {

      if (object.gid != null) {
        _paintTileObject(canvas, object);
      } else {
        if (object.isRectangle) {
          final rect = Rect.fromLTWH(object.x, object.y, object.width, object.height);
          canvas.drawRect(rect, paint);
          canvas.drawRect(rect, strokePaint);
        } else if (object.isPoint) {
          final rect = Rect.fromLTWH(object.x, object.y, object.width, object.height);
          canvas.drawRect(rect, paint);
          canvas.drawRect(rect, strokePaint);
          
          final crossPaint = strokePaint;
          
          final centerX = object.x + object.width / 2;
          final centerY = object.y + object.height / 2;
          
          canvas.drawLine(
            Offset(centerX, object.y),
            Offset(centerX, object.y + object.height),
            crossPaint,
          );
          
          canvas.drawLine(
            Offset(object.x, centerY),
            Offset(object.x + object.width, centerY),
            crossPaint,
          );
        } else if (object.isEllipse) {
          final rect = Rect.fromLTWH(object.x, object.y, object.width, object.height);
          canvas.drawOval(rect, paint);
          canvas.drawOval(rect, strokePaint);
        } else if (object.isPolygon || object.isPolyline) {
          final points = object.isPolygon ? object.polygon : object.polyline;
          if (points.isNotEmpty) {
            final path = Path();
            path.moveTo(object.x + points.first.x, object.y + points.first.y);
            for (var i = 1; i < points.length; i++) {
              path.lineTo(object.x + points[i].x, object.y + points[i].y);
            }
            if (object.isPolygon) {
              path.close();
              canvas.drawPath(path, paint);
            }
            canvas.drawPath(path, strokePaint);
          }
        }
      }
      }

      if (object.text != null) {
        _paintTextObject(canvas, object);
      }
      
      canvas.restore();
    }
  }

  void _paintTileObject(Canvas canvas, TiledObject object) {
    final gid = Gid.fromInt(object.gid!);
    if (gid.tile == 0) return;

    final tile = map.tileByGid(gid.tile);
    if (tile == null || tile.isEmpty) return;

    final tileset = map.tilesetByTileGId(gid.tile);
    final imageSource = tile.image?.source ?? tileset.image?.source;
    if (imageSource == null) return;

    final image = resolver.getImage(imageSource, tileset: tileset);
    

    final rect = tileset.computeDrawRect(tile);
    final src = Rect.fromLTWH(
      rect.left.toDouble(), rect.top.toDouble(),
      rect.width.toDouble(), rect.height.toDouble(),
    );

    final dst = Rect.fromLTWH(object.x, object.y - object.height, object.width, object.height);
    
    if (image == null) {
      _drawMissingImagePlaceholder(canvas, dst, imageSource ?? 'Unknown');
      return;
    }

    canvas.save();
    canvas.translate(dst.left + dst.width / 2, dst.top + dst.height / 2);
    if (gid.flips.diagonally) canvas.transform(Float64List.fromList([0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]));
    if (gid.flips.horizontally) canvas.scale(-1.0, 1.0);
    if (gid.flips.vertically) canvas.scale(1.0, -1.0);
    canvas.translate(-dst.width / 2, -dst.height / 2);

    canvas.drawImageRect(
      image,
      src,
      Rect.fromLTWH(0, 0, dst.width, dst.height),
      Paint()..filterQuality = FilterQuality.none,
    );
    canvas.restore();
  }

  void _paintTextObject(Canvas canvas, TiledObject object) {
    final textInfo = object.text!;
    var painter = _textPainterCache[object.id];
    
    if (painter == null) {
      final textStyle = TextStyle(
        fontFamily: textInfo.fontFamily,
        fontSize: textInfo.pixelSize.toDouble(),
        color: textInfo.color.toFlutterColor(),
        fontWeight: textInfo.bold ? FontWeight.bold : FontWeight.normal,
        fontStyle: textInfo.italic ? FontStyle.italic : FontStyle.normal,
        decoration: TextDecoration.combine([
          if (textInfo.underline) TextDecoration.underline,
          if (textInfo.strikeout) TextDecoration.lineThrough,
        ]),
      );

      painter = TextPainter(
        text: TextSpan(text: textInfo.text, style: textStyle),
        textAlign: textInfo.hAlign.toFlutterTextAlign(),
        textDirection: ui.TextDirection.ltr,
      )
      ..layout(maxWidth: object.width > 0 ? object.width : double.infinity);
      
      _textPainterCache[object.id] = painter;
    }

    double yOffset;
    switch(textInfo.vAlign) {
      case VAlign.center:
        yOffset = (object.height - painter.height) / 2;
        break;
      case VAlign.bottom:
        yOffset = object.height - painter.height;
        break;
      case VAlign.top:
      default:
        yOffset = 0;
        break;
    }

    painter.paint(canvas, Offset(object.x, object.y + yOffset));
  }

  @override
  bool shouldRepaint(covariant TiledMapPainter oldDelegate) {
    if (oldDelegate.transform != transform) {
      _textPainterCache.clear();
    }
    return true;
  }
  
  void _drawMissingImagePlaceholder(Canvas canvas, Rect destinationRect, String path) {
    final paint = Paint()..color = Colors.pink.withOpacity(0.8);
    canvas.drawRect(destinationRect, paint);

    final errorPaint = Paint()..color = Colors.white;
    canvas.drawLine(destinationRect.topLeft, destinationRect.bottomRight, errorPaint);
    canvas.drawLine(destinationRect.bottomLeft, destinationRect.topRight, errorPaint);
    
  }
}

extension on String {
  Color toFlutterColor() {
    var hex = replaceAll("#", "");
    if (hex.length == 6) {
      hex = "FF$hex";
    }
    if (hex.length == 8) {
      return Color(int.parse("0x$hex"));
    }
    return Colors.black;
  }
}

extension on ColorData {
  Color toFlutterColor() => Color.fromARGB(alpha, red, green, blue);
}

extension on HAlign {
  TextAlign toFlutterTextAlign() {
    switch(this) {
      case HAlign.center:
        return TextAlign.center;
      case HAlign.right:
        return TextAlign.right;
      case HAlign.justify:
        return TextAlign.justify;
      case HAlign.left:
      default:
        return TextAlign.left;
    }
  }
}

// FILE: lib/editor/plugins/tiled_editor/tiled_paint_tools.dart


enum TiledPaintMode { paint, fill, erase, select, move }
enum TiledEditorMode { panZoom, paint, object }

enum ObjectTool {
  select,
  move,
  addRectangle,
  addEllipse,
  addPoint,
  addPolygon,
  addPolyline,
  addText,
  addSprite,
}

// FILE: lib/editor/plugins/tiled_editor/tmj_writer.dart

import 'dart:convert';
import 'package:tiled/tiled.dart';

extension _EnumWriter on Enum {
  String toJson() => name;
}

extension _ColorDataWriter on ColorData {
  String toJson() {
    final r = red.toRadixString(16).padLeft(2, '0');
    final g = green.toRadixString(16).padLeft(2, '0');
    final b = blue.toRadixString(16).padLeft(2, '0');
    final a = alpha.toRadixString(16).padLeft(2, '0');
    return '#$a$r$g$b';
  }
}

class TmjWriter {
  final TiledMap map;

  TmjWriter(this.map);

  String toTmj() {
    final mapJson = _buildMapJson();
    return const JsonEncoder.withIndent('  ').convert(mapJson);
  }

  Map<String, dynamic> _buildMapJson() {
    return {
      'type': 'map',
      'version': map.version,
      if (map.tiledVersion != null) 'tiledversion': map.tiledVersion,
      'orientation': map.orientation?.toJson() ?? 'orthogonal',
      'renderorder': map.renderOrder.toJson().replaceAllMapped(RegExp(r'([A-Z])'), (m) => '-${m.group(1)!.toLowerCase()}'),
      'width': map.width,
      'height': map.height,
      'tilewidth': map.tileWidth,
      'tileheight': map.tileHeight,
      'infinite': map.infinite,
      if (map.nextLayerId != null) 'nextlayerid': map.nextLayerId,
      if (map.nextObjectId != null) 'nextobjectid': map.nextObjectId,
      if (map.backgroundColorHex != null) 'backgroundcolor': map.backgroundColorHex,
      if (map.properties.isNotEmpty) 'properties': _buildPropertiesJson(map.properties),
      'tilesets': map.tilesets.map((ts) => _buildTilesetJson(ts)).toList(),
      'layers': map.layers.map((l) => _buildLayerJson(l)).toList(),
    };
  }

  List<Map<String, dynamic>> _buildPropertiesJson(CustomProperties properties) {
    return properties.map((prop) {
      final json = <String, dynamic>{
        'name': prop.name,
        'type': prop.type.name,
        'value': prop.value,
      };
      if (prop is ColorProperty) {
        json['value'] = prop.hexValue;
      }
      return json;
    }).toList();
  }

  Map<String, dynamic> _buildTilesetJson(Tileset tileset) {
    final json = <String, dynamic>{
      'firstgid': tileset.firstGid,
      if (tileset.source != null) 'source': tileset.source,
    };

    if (tileset.source == null) {
      json.addAll({
        if (tileset.name != null) 'name': tileset.name,
        'tilewidth': tileset.tileWidth,
        'tileheight': tileset.tileHeight,
        if (tileset.spacing != 0) 'spacing': tileset.spacing,
        if (tileset.margin != 0) 'margin': tileset.margin,
        if (tileset.tileCount != null) 'tilecount': tileset.tileCount,
        if (tileset.columns != null) 'columns': tileset.columns,
        if (tileset.image != null) 'image': tileset.image!.source,
        if (tileset.image != null) 'imagewidth': tileset.image!.width,
        if (tileset.image != null) 'imageheight': tileset.image!.height,
        if (tileset.objectAlignment != ObjectAlignment.unspecified) 'objectalignment': tileset.objectAlignment.toJson(),
        if (tileset.properties.isNotEmpty) 'properties': _buildPropertiesJson(tileset.properties),
      });
    }

    return json;
  }

  Map<String, dynamic> _buildLayerJson(Layer layer) {
    final common = {
      'id': layer.id,
      'name': layer.name,
      'x': layer.offsetX,
      'y': layer.offsetY,
      'width': layer is TileLayer ? layer.width : 0,
      'height': layer is TileLayer ? layer.height : 0,
      'opacity': layer.opacity,
      'visible': layer.visible,
      if (layer.class_ != null && layer.class_!.isNotEmpty) 'class': layer.class_,
      if (layer.tintColorHex != null) 'tintcolor': layer.tintColorHex,
      if (layer.properties.isNotEmpty) 'properties': _buildPropertiesJson(layer.properties),
    };

    if (layer is TileLayer) {
      common['type'] = 'tilelayer';
      final gids = layer.tileData?.expand((row) => row).map((gid) {
        int outputGid = gid.tile;
        if (gid.flips.horizontally) outputGid |= Gid.flippedHorizontallyFlag;
        if (gid.flips.vertically) outputGid |= Gid.flippedVerticallyFlag;
        if (gid.flips.diagonally) outputGid |= Gid.flippedDiagonallyFlag;
        return outputGid;
      }).toList();
      common['data'] = gids ?? [];
    } else if (layer is ObjectGroup) {
      common['type'] = 'objectgroup';
      common['draworder'] = layer.drawOrder?.toJson() ?? 'topdown';
      if (layer.color != null) {
        common['color'] = layer.color!.toJson();
      }
      common['objects'] = layer.objects.map((o) => _buildObjectJson(o)).toList();
    } else if (layer is ImageLayer) {
      common['type'] = 'imagelayer';
      common['image'] = layer.image.source;
      if(layer.repeatX) common['repeatx'] = true;
      if(layer.repeatY) common['repeaty'] = true;
    } else if (layer is Group) {
      common['type'] = 'group';
      common['layers'] = layer.layers.map((l) => _buildLayerJson(l)).toList();
    }
    return common;
  }

  Map<String, dynamic> _buildObjectJson(TiledObject obj) {
    return {
      'id': obj.id,
      'name': obj.name,
      'type': obj.type,
      if (obj.type.isNotEmpty) 'class': obj.type,
      'x': obj.x,
      'y': obj.y,
      'width': obj.width,
      'height': obj.height,
      'rotation': obj.rotation,
      'visible': obj.visible,
      if (obj.gid != null) 'gid': obj.gid,
      if (obj.isEllipse) 'ellipse': true,
      if (obj.isPoint) 'point': true,
      if (obj.isPolygon) 'polygon': obj.polygon.map((p) => {'x': p.x, 'y': p.y}).toList(),
      if (obj.isPolyline) 'polyline': obj.polyline.map((p) => {'x': p.x, 'y': p.y}).toList(),
      if (obj.properties.isNotEmpty) 'properties': _buildPropertiesJson(obj.properties),
      if (obj.text != null) 'text': _buildTextJson(obj.text!),
    };
  }

  Map<String, dynamic> _buildTextJson(Text text) {
    return {
      'text': text.text,
      'fontfamily': text.fontFamily,
      'pixelsize': text.pixelSize,
      'wrap': text.wrap,
      'color': text.color,
      'bold': text.bold,
      'italic': text.italic,
      'underline': text.underline,
      'strikeout': text.strikeout,
      'kerning': text.kerning,
      'halign': text.hAlign.toJson(),
      'valign': text.vAlign.toJson(),
    };
  }
}

// FILE: lib/editor/plugins/tiled_editor/tmx_writer.dart


import 'package:tiled/tiled.dart';
import 'package:xml/xml.dart';
import 'tmx_writer_extensions.dart'; // Import the new extensions file

class TmxWriter {
  final TiledMap map;

  TmxWriter(this.map);

  String toTmx() {
    final builder = XmlBuilder();
    builder.processing('xml', 'version="1.0" encoding="UTF-8"');

    map.writeTo(builder);

    return builder.buildDocument().toXmlString(pretty: true, indent: ' ');
  }
}

// FILE: lib/editor/plugins/tiled_editor/tmx_writer_extensions.dart

import 'package:tiled/tiled.dart';
import 'package:xml/xml.dart';

ColorData _colorDataFromHex(String hex) {
  var source = hex.replaceAll('#', '');
  if (source.length == 6) { source = 'ff$source'; }
  if (source.length == 8) {
    final val = int.parse(source, radix: 16);
    return ColorData.hex(val);
  }
  return const ColorData.argb(255, 0, 0, 0);
}

extension on ColorData {
  String toHex({String prefix = '#', bool includeAlpha = true}) {
    final r = red.toRadixString(16).padLeft(2, '0');
    final g = green.toRadixString(16).padLeft(2, '0');
    final b = blue.toRadixString(16).padLeft(2, '0');
    if (includeAlpha) {
      final a = alpha.toRadixString(16).padLeft(2, '0');
      return '$prefix$a$r$g$b';
    }
    return '$prefix$r$g$b';
  }
}


extension TiledMapWriter on TiledMap {
  void writeTo(XmlBuilder builder) {
    builder.element('map', nest: () {
      builder.attribute('version', version);
      if (tiledVersion != null) builder.attribute('tiledversion', tiledVersion!);
      if (orientation != null) builder.attribute('orientation', orientation!.name);
      builder.attribute('renderorder', renderOrder.name.replaceAll(RegExp(r'(?=[A-Z])'), '-').toLowerCase());
      builder.attribute('width', width);
      builder.attribute('height', height);
      builder.attribute('tilewidth', tileWidth);
      builder.attribute('tileheight', tileHeight);
      builder.attribute('infinite', infinite ? '1' : '0');
      if (nextLayerId != null) builder.attribute('nextlayerid', nextLayerId!);
      if (nextObjectId != null) builder.attribute('nextobjectid', nextObjectId!);
      if (backgroundColorHex != null) builder.attribute('backgroundcolor', backgroundColorHex!);

      properties.writeTo(builder);

      for (final tileset in tilesets) {
        tileset.writeTo(builder);
      }
      for (final layer in layers) {
        layer.writeTo(builder);
      }
    });
  }
}

extension TilesetWriter on Tileset {
  void writeTo(XmlBuilder builder) {
    builder.element('tileset', nest: () {
      if (firstGid != null) builder.attribute('firstgid', firstGid!);
      
      if (source != null) {
        builder.attribute('source', source!);
      } else {
        if (name != null) builder.attribute('name', name!);
        if (tileWidth != null) builder.attribute('tilewidth', tileWidth!);
        if (tileHeight != null) builder.attribute('tileheight', tileHeight!);
        if (spacing != 0) builder.attribute('spacing', spacing);
        if (margin != 0) builder.attribute('margin', margin);
        if (tileCount != null) builder.attribute('tilecount', tileCount!);
        if (columns != null) builder.attribute('columns', columns!);

        image?.writeTo(builder);

        for (final tile in tiles) {
          tile.writeTo(builder);
        }
      }
    });
  }
}

extension TiledImageWriter on TiledImage {
  void writeTo(XmlBuilder builder) {
    builder.element('image', nest: () {
      builder.attribute('source', source!);
      if (width != null) builder.attribute('width', width!);
      if (height != null) builder.attribute('height', height!);
    });
  }
}

extension TileWriter on Tile {
  void writeTo(XmlBuilder builder) {
    if (properties.isNotEmpty || animation.isNotEmpty || objectGroup != null) {
      builder.element('tile', nest: () {
        builder.attribute('id', localId);
        properties.writeTo(builder);
        
        if (animation.isNotEmpty) {
          builder.element('animation', nest: () {
            for (final frame in animation) {
              frame.writeTo(builder);
            }
          });
        }
        
        objectGroup?.writeTo(builder, isForTile: true);
      });
    }
  }
}

extension FrameWriter on Frame {
  void writeTo(XmlBuilder builder) {
    builder.element('frame', nest: () {
      builder.attribute('tileid', tileId);
      builder.attribute('duration', duration);
    });
  }
}

extension LayerWriter on Layer {
  void writeTo(XmlBuilder builder,  {bool isForTile = false}) {
    final layer = this;
    if (layer is TileLayer) {
      layer.writeTo(builder);
    } else if (layer is ObjectGroup) {
      layer.writeTo(builder, isForTile: isForTile);
    } else if (layer is ImageLayer) {
      layer.writeTo(builder);
    } else if (layer is Group) {
      layer.writeTo(builder);
    }
  }

  void _writeCommonAttributes(XmlBuilder builder) {
    if (id != null) builder.attribute('id', id!);
    builder.attribute('name', name);
    if (class_ != null && class_!.isNotEmpty) builder.attribute('class', class_!);
    if (offsetX != 0) builder.attribute('offsetx', offsetX);
    if (offsetY != 0) builder.attribute('offsety', offsetY);
    if (opacity < 1) builder.attribute('opacity', opacity);
    if (!visible) builder.attribute('visible', '0');
    if (tintColorHex != null) builder.attribute('tintcolor', tintColorHex!);
  }
}

extension TileLayerWriter on TileLayer {
  void writeTo(XmlBuilder builder) {
    builder.element('layer', nest: () {
      _writeCommonAttributes(builder);
      builder.attribute('width', width);
      builder.attribute('height', height);
      properties.writeTo(builder);

      builder.element('data', nest: () {
        builder.attribute('encoding', 'csv');
        final gids = <int>[];

        for (int y = 0; y < height; y++) {
          for (int x = 0; x < width; x++) {
            Gid gid;
            if (tileData != null && y < tileData!.length && x < tileData![y].length) {
              gid = tileData![y][x];
            } else {
              gid = Gid.fromInt(0);
            }
            
            int outputGid = gid.tile;
            if (gid.flips.horizontally) outputGid |= Gid.flippedHorizontallyFlag;
            if (gid.flips.vertically) outputGid |= Gid.flippedVerticallyFlag;
            if (gid.flips.diagonally) outputGid |= Gid.flippedDiagonallyFlag;
            gids.add(outputGid);
          }
        }
        builder.text('\n${gids.join(',')}\n');
      });
    });
  }
}

extension ObjectGroupWriter on ObjectGroup {
  void writeTo(XmlBuilder builder, {required bool isForTile}) {
    builder.element('objectgroup', nest: () {
      if (!isForTile) {
        _writeCommonAttributes(builder);
        if (color != null) {
          builder.attribute('color', color!.toHex(includeAlpha: true));
        }
        if (drawOrder != null) {
          builder.attribute('draworder', drawOrder!.name.replaceAll('Order', ''));
        }
      }
      properties.writeTo(builder);

      for (final object in objects) {
        object.writeTo(builder);
      }
    });
  }
}

extension ImageLayerWriter on ImageLayer {
  void writeTo(XmlBuilder builder) {
    builder.element('imagelayer', nest: () {
      _writeCommonAttributes(builder);
      if (repeatX) builder.attribute('repeatx', '1');
      if (repeatY) builder.attribute('repeaty', '1');
      properties.writeTo(builder);
      image.writeTo(builder);
    });
  }
}

extension GroupLayerWriter on Group {
  void writeTo(XmlBuilder builder) {
    builder.element('group', nest: () {
      _writeCommonAttributes(builder);
      properties.writeTo(builder);
      for (final subLayer in layers) {
        subLayer.writeTo(builder);
      }
    });
  }
}

extension TiledObjectWriter on TiledObject {
  void writeTo(XmlBuilder builder) {
    builder.element('object', nest: () {
      builder.attribute('id', id);
      if (name.isNotEmpty) builder.attribute('name', name);
      if (type.isNotEmpty) {
        builder.attribute('type', type); 
        builder.attribute('class', type);
      }
      if (gid != null) builder.attribute('gid', gid!);
      builder.attribute('x', x);
      builder.attribute('y', y);
      if (width != 0) builder.attribute('width', width);
      if (height != 0) builder.attribute('height', height);
      if (rotation != 0) builder.attribute('rotation', rotation);
      if (!visible) builder.attribute('visible', '0');
      if (template != null) builder.attribute('template', template!);

      properties.writeTo(builder);

      if (isEllipse) builder.element('ellipse');
      else if (isPoint) builder.element('point');
      else if (isPolygon) {
        builder.element('polygon', nest: () => builder.attribute('points', polygon.map((p) => '${p.x},${p.y}').join(' ')));
      } else if (isPolyline) {
        builder.element('polyline', nest: () => builder.attribute('points', polyline.map((p) => '${p.x},${p.y}').join(' ')));
      }

      text?.writeTo(builder);
    });
  }
}

extension TextWriter on Text {
  void writeTo(XmlBuilder builder) {
    builder.element('text', nest: () {
      if (fontFamily != 'sans-serif') builder.attribute('fontfamily', fontFamily);
      if (pixelSize != 16) builder.attribute('pixelsize', pixelSize);
      if (wrap) builder.attribute('wrap', '1');
      if (color != '#000000') builder.attribute('color', color);
      if (bold) builder.attribute('bold', '1');
      if (italic) builder.attribute('italic', '1');
      if (underline) builder.attribute('underline', '1');
      if (strikeout) builder.attribute('strikeout', '1');
      if (!kerning) builder.attribute('kerning', '0');
      if (hAlign != HAlign.left) builder.attribute('halign', hAlign.name);
      if (vAlign != VAlign.top) builder.attribute('valign', vAlign.name);
      builder.text(text);
    });
  }
}

extension PropertiesWriter on CustomProperties {
  void writeTo(XmlBuilder builder) {
    if (isEmpty) return;
    builder.element('properties', nest: () {
      for (final property in this) {
        property.writeTo(builder);
      }
    });
  }
}

extension PropertyWriter on Property {
  void writeTo(XmlBuilder builder) {
    builder.element('property', nest: () {
      builder.attribute('name', name);
      
      switch (runtimeType) {
        case IntProperty: builder.attribute('type', 'int'); break;
        case BoolProperty: builder.attribute('type', 'bool'); break;
        case FloatProperty: builder.attribute('type', 'float'); break;
        case FileProperty: builder.attribute('type', 'file'); break;
        case ObjectProperty: builder.attribute('type', 'object'); break;
        case ColorProperty:
          builder.attribute('type', 'color');
          builder.attribute('value', (this as ColorProperty).value.toHex(includeAlpha: true));
          return;
      }
      
      if (this is StringProperty && (value as String).contains('\n')) {
          builder.text(value);
      } else {
          builder.attribute('value', value.toString());
      }
    });
  }
}

// FILE: lib/editor/plugins/tiled_editor/widgets/export_dialog.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/app/app_notifier.dart';
import 'package:machine/data/file_handler/file_handler.dart';
import 'package:machine/data/repositories/project/project_repository.dart';
import 'package:machine/editor/plugins/tiled_editor/tiled_export_service.dart';
import 'package:machine/editor/plugins/tiled_editor/tiled_map_notifier.dart';
import 'package:machine/utils/toast.dart';
import 'package:machine/widgets/dialogs/folder_picker_dialog.dart';
import '../../../../logs/logs_provider.dart';
import 'package:machine/asset_cache/asset_models.dart';

class ExportDialog extends ConsumerStatefulWidget {
  final TiledMapNotifier notifier;
  final Talker talker;
  final Map<String, AssetData> assetDataMap;
  const ExportDialog({
    super.key,
    required this.notifier,
    required this.talker,
    required this.assetDataMap,
  });
  @override
  ConsumerState<ExportDialog> createState() => _ExportDialogState();
}

class _ExportDialogState extends ConsumerState<ExportDialog> {
  bool _removeUnusedTilesets = true;
  bool _exportAsJson = false;
  bool _packInAtlas = false;
  String? _destinationFolderUri;
  String _destinationFolderDisplay = 'Not selected';
  bool _isExporting = false;

  late final TextEditingController _mapNameController;
  late final TextEditingController _atlasNameController;

  @override
  void initState() {
    super.initState();
    final mapName = widget.notifier.map.name ?? 'exported_map';
    _mapNameController = TextEditingController(text: mapName);
    _atlasNameController = TextEditingController(text: 'packed_atlas');
  }
  
  @override
  void dispose() {
    _mapNameController.dispose();
    _atlasNameController.dispose();
    super.dispose();
  }


  Future<void> _pickDestinationFolder() async {
    final project = ref.read(appNotifierProvider).value!.currentProject!;
    final repo = ref.read(projectRepositoryProvider)!;

    // We can re-use the file/folder picker, but we only care about the path URI.
    final selectedRelativePath = await showDialog<String>(
      context: context,
      builder: (_) => const FileOrFolderPickerDialog(),
    );

    if (selectedRelativePath != null) {
      final file = await repo.fileHandler.resolvePath(project.rootUri, selectedRelativePath);
      if (file != null) {
        setState(() {
          // If the user selected a file, use its parent folder. Otherwise, use the selected folder.
          _destinationFolderUri = file.isDirectory ? file.uri : repo.fileHandler.getParentUri(file.uri);
          _destinationFolderDisplay = selectedRelativePath;
        });
      }
    }
  }

  Future<void> _startExport() async {
    if (_destinationFolderUri == null) {
      MachineToast.error("Please select a destination folder.");
      return;
    }
    
    setState(() => _isExporting = true);

    try {
      await ref.read(tiledExportServiceProvider).exportMap(
            map: widget.notifier.map,
            assetDataMap: widget.assetDataMap,
            destinationFolderUri: _destinationFolderUri!,
            mapFileName: _mapNameController.text.trim(),
            atlasFileName: _atlasNameController.text.trim(),
            removeUnused: _removeUnusedTilesets,
            asJson: _exportAsJson,
            packInAtlas: _packInAtlas,
          );
      MachineToast.info("Export successful!");
      if (mounted) Navigator.of(context).pop();
    } catch (e) {
      widget.talker.handle(e, StackTrace.current, 'Export failed');
      MachineToast.error("Export failed: ${e.toString()}");
    } finally {
      if (mounted) {
        setState(() => _isExporting = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Export Map'),
      content: SingleChildScrollView(
        child: SizedBox(
          width: double.maxFinite,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text('Destination', style: TextStyle(fontWeight: FontWeight.bold)),
              ListTile(
                contentPadding: EdgeInsets.zero,
                title: const Text('Export to folder'),
                subtitle: Text(_destinationFolderDisplay, overflow: TextOverflow.ellipsis),
                trailing: const Icon(Icons.folder_open_outlined),
                onTap: _pickDestinationFolder,
              ),
              const Divider(height: 24),
              const Text('Filenames', style: TextStyle(fontWeight: FontWeight.bold)),
              TextFormField(
                controller: _mapNameController,
                decoration: InputDecoration(
                  labelText: 'Map filename',
                  suffixText: _exportAsJson ? '.tmj' : '.tmx',
                ),
              ),
              if (_packInAtlas)
                Padding(
                  padding: const EdgeInsets.only(top: 8.0),
                  child: TextFormField(
                    controller: _atlasNameController,
                    decoration: const InputDecoration(
                      labelText: 'Atlas filename',
                      suffixText: '.png',
                    ),
                  ),
                ),
              const Divider(height: 24),
              const Text('Options', style: TextStyle(fontWeight: FontWeight.bold)),
              SwitchListTile(
                title: const Text('Export as JSON (.tmj)'),
                subtitle: const Text('Default is XML (.tmx)'),
                value: _exportAsJson,
                onChanged: (value) => setState(() => _exportAsJson = value),
              ),
              SwitchListTile(
                title: const Text('Remove unused tilesets'),
                subtitle: const Text('Cleans the exported map file'),
                value: _removeUnusedTilesets,
                onChanged: (value) => setState(() => _removeUnusedTilesets = value),
              ),
              SwitchListTile(
                title: const Text('Pack into a single atlas'),
                subtitle: const Text('Combines all tiles into one image (Not implemented)'),
                value: _packInAtlas,
                onChanged: (value) => setState(() => _packInAtlas = value),
              ),
            ],
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isExporting ? null : () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        FilledButton.icon(
          onPressed: _isExporting || _destinationFolderUri == null ? null : _startExport,
          icon: _isExporting
              ? const SizedBox(
                  width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2))
              : const Icon(Icons.output_outlined),
          label: Text(_isExporting ? 'Exporting...' : 'Export'),
        ),
      ],
    );
  }
}

// FILE: lib/editor/plugins/tiled_editor/widgets/layers_panel.dart


import 'package:flutter/material.dart';
import 'package:tiled/tiled.dart' hide Text;

class _LayerPanelDragData {
  final String type;
  final int id;
  final int index;
  final int? parentLayerId;

  _LayerPanelDragData.layer(this.id, this.index)
      : type = 'layer',
        parentLayerId = null;
  _LayerPanelDragData.object(this.id, this.index, this.parentLayerId)
      : type = 'object';
}

enum _DropPosition { above, below, inside }

class LayersPanel extends StatefulWidget {
  final List<Layer> layers;
  final int selectedLayerId;
  final List<TiledObject> selectedObjects;
  
  final ValueChanged<int> onLayerSelected;
  final ValueChanged<TiledObject> onObjectSelected;
  
  final ValueChanged<int> onLayerVisibilityChanged;
  final void Function(int layerId, int objectId) onObjectVisibilityChanged;
  
  final void Function(int oldIndex, int newIndex) onLayerReorder;
  final void Function(int layerId, int oldIndex, int newIndex) onObjectReorder;
  
  final VoidCallback onAddLayer;
  
  final ValueSetter<int> onLayerDelete;
  final void Function(int layerId, int objectId) onObjectDelete;
  
  final ValueSetter<Layer> onLayerInspect;
  final ValueSetter<TiledObject> onObjectInspect;

  const LayersPanel({
    super.key,
    required this.layers,
    required this.selectedLayerId,
    required this.selectedObjects,
    required this.onLayerSelected,
    required this.onObjectSelected,
    required this.onLayerVisibilityChanged,
    required this.onObjectVisibilityChanged,
    required this.onLayerReorder,
    required this.onObjectReorder,
    required this.onAddLayer,
    required this.onLayerDelete,
    required this.onObjectDelete,
    required this.onLayerInspect,
    required this.onObjectInspect,
  });

  @override
  State<LayersPanel> createState() => _LayersPanelState();
}

class _LayersPanelState extends State<LayersPanel> {
  final Set<int> _expandedLayerIds = {};

  void _toggleExpansion(int layerId) {
    setState(() {
      if (_expandedLayerIds.contains(layerId)) {
        _expandedLayerIds.remove(layerId);
      } else {
        _expandedLayerIds.add(layerId);
      }
    });
  }

  List<_FlatNode> _buildFlatList() {
    final List<_FlatNode> flatList = [];

    for (int i = widget.layers.length - 1; i >= 0; i--) {
      final layer = widget.layers[i];
      flatList.add(_FlatNode.layer(
        layer: layer,
        index: i,
        depth: 0,
      ));

      if (layer is ObjectGroup && _expandedLayerIds.contains(layer.id)) {
        for (int j = 0; j < layer.objects.length; j++) {
          flatList.add(_FlatNode.object(
            object: layer.objects[j],
            parentLayerId: layer.id!,
            index: j,
            depth: 1,
          ));
        }
      }
    }
    return flatList;
  }

  @override
  Widget build(BuildContext context) {
    final flatList = _buildFlatList();

    return Material(
      elevation: 4,
      borderRadius: const BorderRadius.only(
        topLeft: Radius.circular(8),
        topRight: Radius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: Text(
              'Hierarchy',
              style: Theme.of(context).textTheme.titleMedium,
              textAlign: TextAlign.center,
            ),
          ),
          const Divider(height: 1),
          Expanded(
            child: ListView.builder(
              itemCount: flatList.length,
              itemBuilder: (context, index) {
                final node = flatList[index];
                return _HierarchyRow(
                  node: node,
                  isSelectedLayer:
                      node.layer?.id == widget.selectedLayerId,
                  isObjectSelected: node.isObject
                      ? widget.selectedObjects.contains(node.object)
                      : false,
                  isExpanded: node.isLayer
                      ? _expandedLayerIds.contains(node.layer!.id)
                      : false,
                  onToggleExpand: () =>
                      _toggleExpansion(node.layer!.id!),
                  onTap: () {
                    if (node.isLayer) {
                      widget.onLayerSelected(node.layer!.id!);
                    } else {
                      widget.onLayerSelected(node.parentLayerId!);
                      widget.onObjectSelected(node.object!);
                    }
                  },
                  onVisibilityToggle: () {
                    if (node.isLayer) {
                      widget.onLayerVisibilityChanged(node.layer!.id!);
                    } else {
                      widget.onObjectVisibilityChanged(node.parentLayerId!, node.object!.id);
                    }
                  },
                  onInspect: () {
                    if (node.isLayer) {
                      widget.onLayerInspect(node.layer!);
                    } else {
                      widget.onObjectInspect(node.object!);
                    }
                  },
                  onDelete: () {
                    if (node.isLayer) {
                      widget.onLayerDelete(node.layer!.id!);
                    } else {
                      widget.onObjectDelete(node.parentLayerId!, node.object!.id);
                    }
                  },
                  onReorderLayer: widget.onLayerReorder,
                  onReorderObject: widget.onObjectReorder,
                );
              },
            ),
          ),
          const Divider(height: 1),
          Padding(
            padding: const EdgeInsets.all(4.0),
            child: OutlinedButton.icon(
              icon: const Icon(Icons.add),
              label: const Text('Add Layer'),
              onPressed: widget.onAddLayer,
            ),
          ),
        ],
      ),
    );
  }
}

class _FlatNode {
  final Layer? layer;
  final TiledObject? object;
  final int index;
  final int depth;
  final int? parentLayerId;

  _FlatNode.layer({
    required this.layer,
    required this.index,
    required this.depth,
  })  : object = null,
        parentLayerId = null;

  _FlatNode.object({
    required this.object,
    required this.parentLayerId,
    required this.index,
    required this.depth,
  }) : layer = null;

  bool get isLayer => layer != null;
  bool get isObject => object != null;
}

class _HierarchyRow extends StatefulWidget {
  final _FlatNode node;
  final bool isSelectedLayer;
  final bool isObjectSelected;
  final bool isExpanded;
  final VoidCallback onToggleExpand;
  final VoidCallback onTap;
  final VoidCallback onVisibilityToggle;
  final VoidCallback onInspect;
  final VoidCallback onDelete;
  final Function(int, int) onReorderLayer;
  final Function(int, int, int) onReorderObject;

  const _HierarchyRow({
    required this.node,
    required this.isSelectedLayer,
    required this.isObjectSelected,
    required this.isExpanded,
    required this.onToggleExpand,
    required this.onTap,
    required this.onVisibilityToggle,
    required this.onInspect,
    required this.onDelete,
    required this.onReorderLayer,
    required this.onReorderObject,
  });

  @override
  State<_HierarchyRow> createState() => _HierarchyRowState();
}

class _HierarchyRowState extends State<_HierarchyRow> {
  _DropPosition? _dropPosition;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isSelected = widget.node.isLayer
        ? widget.isSelectedLayer
        : widget.isObjectSelected;

    bool isVisible = false;
    if (widget.node.isLayer) {
      isVisible = widget.node.layer?.visible ?? true;
    } else {
      isVisible = widget.node.object?.visible ?? true;
    }

    Widget content = Container(
      height: 32,
      padding: EdgeInsets.only(left: widget.node.depth * 16.0 + 4.0),
      color: isSelected
          ? theme.colorScheme.primaryContainer.withOpacity(0.3)
          : null,
      child: Row(
        children: [
          if (widget.node.isLayer && widget.node.layer is ObjectGroup)
            GestureDetector(
              onTap: widget.onToggleExpand,
              child: Icon(
                widget.isExpanded ? Icons.arrow_drop_down : Icons.arrow_right,
                size: 20,
              ),
            )
          else
            const SizedBox(width: 20),

          Icon(_getIcon(), size: 16),
          const SizedBox(width: 8),

          Expanded(
            child: Text(
              _getName(),
              style: TextStyle(
                color: isSelected ? theme.colorScheme.primary : null,
                fontWeight: isSelected ? FontWeight.w500 : FontWeight.normal,
                fontStyle:
                    (widget.node.isLayer && widget.node.layer is! TileLayer)
                        ? FontStyle.italic
                        : FontStyle.normal,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),

          IconButton(
            icon: Icon(
              isVisible ? Icons.visibility : Icons.visibility_off,
              size: 16,
              color: theme.disabledColor,
            ),
            onPressed: widget.onVisibilityToggle,
          ),
          IconButton(
            icon: const Icon(Icons.edit_outlined, size: 16),
            onPressed: widget.onInspect,
          ),
          IconButton(
            icon: const Icon(Icons.delete_outline, size: 16, color: Colors.redAccent),
            onPressed: widget.onDelete,
          ),
        ],
      ),
    );

    if (_dropPosition != null) {
      content = CustomPaint(
        foregroundPainter: _DropIndicatorPainter(
          position: _dropPosition!,
          color: theme.colorScheme.primary,
        ),
        child: content,
      );
    }

    final draggable = LongPressDraggable<_LayerPanelDragData>(
      data: widget.node.isLayer
          ? _LayerPanelDragData.layer(
              widget.node.layer!.id!, widget.node.index)
          : _LayerPanelDragData.object(
              widget.node.object!.id, widget.node.index, widget.node.parentLayerId!),
      feedback: Material(
        elevation: 4,
        borderRadius: BorderRadius.circular(4),
        child: Container(
          padding: const EdgeInsets.all(8),
          color: theme.cardColor,
          child: Row(
            children: [
              const Icon(Icons.drag_indicator),
              const SizedBox(width: 8),
              Text(_getName()),
            ],
          ),
        ),
      ),
      childWhenDragging: Opacity(opacity: 0.5, child: content),
      child: content,
    );

    return DragTarget<_LayerPanelDragData>(
      onWillAccept: (data) {
        if (data == null) return false;
        if (data.type == 'layer' && widget.node.isLayer) {
          return data.id != widget.node.layer!.id;
        }
        if (data.type == 'object' && widget.node.isObject) {
          return data.parentLayerId == widget.node.parentLayerId &&
              data.id != widget.node.object!.id;
        }
        return false;
      },
      onMove: (details) {
        final renderBox = context.findRenderObject() as RenderBox;
        final localPos = renderBox.globalToLocal(details.offset);
        final height = renderBox.size.height;

        _DropPosition newPos;
        if (localPos.dy < height * 0.5) {
          newPos = _DropPosition.above;
        } else {
          newPos = _DropPosition.below;
        }

        if (_dropPosition != newPos) {
          setState(() => _dropPosition = newPos);
        }
      },
      onLeave: (_) => setState(() => _dropPosition = null),
      onAccept: (data) {
        setState(() => _dropPosition = null);
        if (data.type == 'layer' && widget.node.isLayer) {
          int targetIndex = widget.node.index;
          if (_dropPosition == _DropPosition.above) {
            targetIndex += 1;
          }
          widget.onReorderLayer(data.index, targetIndex);

        } else if (data.type == 'object' && widget.node.isObject) {
          int targetIndex = widget.node.index;
          if (_dropPosition == _DropPosition.below) {
            targetIndex += 1;
          }
          widget.onReorderObject(data.parentLayerId!, data.index, targetIndex);
        }
      },
      builder: (ctx, _, __) => InkWell(
        onTap: widget.onTap,
        child: draggable,
      ),
    );
  }

  String _getName() {
    if (widget.node.isLayer) return widget.node.layer!.name;
    final obj = widget.node.object!;
    return obj.name.isNotEmpty ? obj.name : 'Object ${obj.id}';
  }

  IconData _getIcon() {
    if (widget.node.isLayer) {
      final l = widget.node.layer!;
      if (l is TileLayer) return Icons.grid_on;
      if (l is ObjectGroup) {
        return widget.isExpanded ? Icons.folder_open : Icons.folder;
      }
      if (l is ImageLayer) return Icons.image_outlined;
      return Icons.layers;
    } else {
      final o = widget.node.object!;
      if (o.isPoint) return Icons.add_location_alt_outlined;
      if (o.isEllipse) return Icons.circle_outlined;
      if (o.isPolygon) return Icons.pentagon_outlined;
      if (o.isPolyline) return Icons.polyline_outlined;
      if (o.text != null) return Icons.text_fields_outlined;
      if (o.gid != null) return Icons.image_aspect_ratio_outlined;
      return Icons.rectangle_outlined;
    }
  }
}

class _DropIndicatorPainter extends CustomPainter {
  final _DropPosition position;
  final Color color;

  _DropIndicatorPainter({required this.position, required this.color});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;

    if (position == _DropPosition.above) {
      canvas.drawLine(Offset(0, 1), Offset(size.width, 1), paint);
    } else if (position == _DropPosition.below) {
      canvas.drawLine(
          Offset(0, size.height - 1), Offset(size.width, size.height - 1), paint);
    }
  }

  @override
  bool shouldRepaint(covariant _DropIndicatorPainter old) =>
      old.position != position || old.color != color;
}

// FILE: lib/editor/plugins/tiled_editor/widgets/map_properties_dialog.dart

import 'package:flutter/material.dart';
import 'package:tiled/tiled.dart' hide Text;

class MapPropertiesDialog extends StatefulWidget {
  final TiledMap map;
  const MapPropertiesDialog({super.key, required this.map});

  @override
  State<MapPropertiesDialog> createState() => _MapPropertiesDialogState();
}

class _MapPropertiesDialogState extends State<MapPropertiesDialog> {
  late final TextEditingController _widthController;
  late final TextEditingController _heightController;
  late final TextEditingController _tileWidthController;
  late final TextEditingController _tileHeightController;

  @override
  void initState() {
    super.initState();
    _widthController = TextEditingController(text: widget.map.width.toString());
    _heightController = TextEditingController(
      text: widget.map.height.toString(),
    );
    _tileWidthController = TextEditingController(
      text: widget.map.tileWidth.toString(),
    );
    _tileHeightController = TextEditingController(
      text: widget.map.tileHeight.toString(),
    );
  }

  @override
  void dispose() {
    _widthController.dispose();
    _heightController.dispose();
    _tileWidthController.dispose();
    _tileHeightController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Map Properties'),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: _widthController,
              decoration: const InputDecoration(labelText: 'Map Width (tiles)'),
              keyboardType: TextInputType.number,
            ),
            TextField(
              controller: _heightController,
              decoration: const InputDecoration(
                labelText: 'Map Height (tiles)',
              ),
              keyboardType: TextInputType.number,
            ),
            TextField(
              controller: _tileWidthController,
              decoration: const InputDecoration(labelText: 'Tile Width (px)'),
              keyboardType: TextInputType.number,
            ),
            TextField(
              controller: _tileHeightController,
              decoration: const InputDecoration(labelText: 'Tile Height (px)'),
              keyboardType: TextInputType.number,
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        FilledButton(
          onPressed: () {
            final result = {
              'width': int.tryParse(_widthController.text) ?? widget.map.width,
              'height':
                  int.tryParse(_heightController.text) ?? widget.map.height,
              'tileWidth':
                  int.tryParse(_tileWidthController.text) ??
                  widget.map.tileWidth,
              'tileHeight':
                  int.tryParse(_tileHeightController.text) ??
                  widget.map.tileHeight,
            };
            Navigator.of(context).pop(result);
          },
          child: const Text('Apply'),
        ),
      ],
    );
  }
}


// FILE: lib/editor/plugins/tiled_editor/widgets/new_layer_dialog.dart


import 'package:flutter/material.dart';
import 'package:tiled/tiled.dart' hide Text;

class NewLayerDialog extends StatefulWidget {
  const NewLayerDialog({super.key});

  @override
  State<NewLayerDialog> createState() => _NewLayerDialogState();
}

class _NewLayerDialogState extends State<NewLayerDialog> {
  late TextEditingController _nameController;
  LayerType _selectedType = LayerType.tileLayer;

  @override
  void initState() {
    super.initState();
    _nameController = TextEditingController();
    _updateDefaultName();
  }
  
  void _updateDefaultName() {
      String newDefaultName = '';
      switch(_selectedType) {
        case LayerType.tileLayer:
          newDefaultName = 'New Tile Layer';
          break;
        case LayerType.objectGroup:
          newDefaultName = 'New Object Layer';
          break;
        case LayerType.imageLayer:
          newDefaultName = 'New Image Layer';
          break;
        case LayerType.group:
        default:
          newDefaultName = 'New Layer';
          break;
      }
      if (_nameController.text == 'New Tile Layer' ||
          _nameController.text == 'New Object Layer' ||
          _nameController.text == 'New Image Layer' ||
          _nameController.text == 'New Layer') {
        _nameController.text = newDefaultName;
      }
    }

  @override
  void dispose() {
    _nameController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('New Layer'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          TextField(
            controller: _nameController,
            decoration: const InputDecoration(labelText: 'Layer Name'),
            autofocus: true,
            onTap: () => _nameController.selection = TextSelection(
              baseOffset: 0,
              extentOffset: _nameController.text.length,
            ),
          ),
          const SizedBox(height: 16),
          DropdownButtonFormField<LayerType>(
            decoration: const InputDecoration(labelText: 'Layer Type'),
            value: _selectedType,
            items: [
              const DropdownMenuItem(
                value: LayerType.tileLayer,
                child: Row(
                  children: [
                    Icon(Icons.grid_on, size: 20),
                    SizedBox(width: 8),
                    Text('Tile Layer'),
                  ],
                ),
              ),
              const DropdownMenuItem(
                value: LayerType.objectGroup,
                child: Row(
                  children: [
                    Icon(Icons.category_outlined, size: 20),
                    SizedBox(width: 8),
                    Text('Object Layer'),
                  ],
                ),
              ),
              const DropdownMenuItem(
                value: LayerType.imageLayer,
                child: Row(
                  children: [
                    Icon(Icons.image_outlined, size: 20),
                    SizedBox(width: 8),
                    Text('Image Layer'),
                  ],
                ),
              ),
            ],
            onChanged: (value) {
              if (value != null) {
                setState(() {
                  _selectedType = value;
                  _updateDefaultName();
                });
              }
            },
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        FilledButton(
          onPressed: () {
            final result = {
              'name': _nameController.text.trim(),
              'type': _selectedType,
            };
            Navigator.of(context).pop(result);
          },
          child: const Text('Add'),
        ),
      ],
    );
  }
}

// FILE: lib/editor/plugins/tiled_editor/widgets/new_tileset_dialog.dart

import 'package:flutter/material.dart';
import 'package:path/path.dart' as p;

class NewTilesetDialog extends StatefulWidget {
  final String imagePath;
  const NewTilesetDialog({super.key, required this.imagePath});

  @override
  State<NewTilesetDialog> createState() => _NewTilesetDialogState();
}

class _NewTilesetDialogState extends State<NewTilesetDialog> {
  late final TextEditingController _nameController;
  late final TextEditingController _tileWidthController;
  late final TextEditingController _tileHeightController;

  @override
  void initState() {
    super.initState();
    _nameController = TextEditingController(
      text: p.basenameWithoutExtension(widget.imagePath),
    );
    _tileWidthController = TextEditingController();
    _tileHeightController = TextEditingController();

    _tryParseDimensionsFromName();
  }

  void _tryParseDimensionsFromName() {
    final filename = p.basenameWithoutExtension(widget.imagePath).toLowerCase();
    final dimRegex = RegExp(r'(\d+)[x_-](\d+)');
    final match = dimRegex.firstMatch(filename);

    if (match != null) {
      final width = int.tryParse(match.group(1) ?? '');
      final height = int.tryParse(match.group(2) ?? '');
      if (width != null && height != null) {
        _tileWidthController.text = width.toString();
        _tileHeightController.text = height.toString();
        return;
      }
    }

    _tileWidthController.text = '16';
    _tileHeightController.text = '16';
  }

  @override
  void dispose() {
    _nameController.dispose();
    _tileWidthController.dispose();
    _tileHeightController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('New Tileset'),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              'From image: ${widget.imagePath}',
              style: Theme.of(context).textTheme.bodySmall,
            ),
            TextField(
              controller: _nameController,
              decoration: const InputDecoration(labelText: 'Tileset Name'),
            ),
            TextField(
              controller: _tileWidthController,
              decoration: const InputDecoration(labelText: 'Tile Width (px)'),
              keyboardType: TextInputType.number,
            ),
            TextField(
              controller: _tileHeightController,
              decoration: const InputDecoration(labelText: 'Tile Height (px)'),
              keyboardType: TextInputType.number,
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        FilledButton(
          onPressed: () {
            final result = {
              'name': _nameController.text.trim(),
              'tileWidth': int.tryParse(_tileWidthController.text) ?? 16,
              'tileHeight': int.tryParse(_tileHeightController.text) ?? 16,
            };
            Navigator.of(context).pop(result);
          },
          child: const Text('Add'),
        ),
      ],
    );
  }
}

// FILE: lib/editor/plugins/tiled_editor/widgets/object_editor_app_bar.dart


import 'package:flutter/material.dart';
import '../../../../command/command_widgets.dart';
import '../tiled_editor_plugin.dart';
import '../tiled_paint_tools.dart';

class ObjectEditorAppBar extends StatelessWidget implements PreferredSizeWidget {
  final VoidCallback onExit;
  final bool isSnapToGridEnabled;
  final VoidCallback onToggleSnapToGrid;
  final bool isObjectSelected;
  final VoidCallback onInspectObject;
  final VoidCallback onDeleteObject;
  final bool showFinishShapeButton;
  final VoidCallback onFinishShape;

  const ObjectEditorAppBar({
    super.key,
    required this.onExit,
    required this.isSnapToGridEnabled,
    required this.onToggleSnapToGrid,
    required this.isObjectSelected,
    required this.onInspectObject,
    required this.onDeleteObject,
    required this.showFinishShapeButton,
    required this.onFinishShape,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AppBar(
      leading: IconButton(
        icon: const Icon(Icons.arrow_back),
        tooltip: 'Exit Object Mode (Pan/Zoom)',
        onPressed: onExit,
      ),
      title: 
        showFinishShapeButton ?
          TextButton.icon(
            icon: const Icon(Icons.check),
            label: const Text('Finish'),
            onPressed: onFinishShape,
            style: TextButton.styleFrom(
                foregroundColor: theme.colorScheme.primary),
          ) :
      const SingleChildScrollView(
        scrollDirection: Axis.horizontal,
        child: CommandToolbar(
          position: TiledEditorPlugin.objectToolsToolbar,
        ),
      ),
      actions: [
        IconButton(
          icon: const Icon(Icons.delete_outline, color: Colors.redAccent),
          tooltip: 'Delete Selected Object(s)',
          onPressed: isObjectSelected ? onDeleteObject : null,
        ),
        IconButton(
          icon: const Icon(Icons.manage_search),
          tooltip: 'Inspect Selected Object',
          color: isObjectSelected ? theme.colorScheme.primary : null,
          onPressed: isObjectSelected ? onInspectObject : null,
        ),
        IconButton(
          icon: const Icon(Icons.grid_on_outlined),
          tooltip: 'Snap to Grid',
          color: isSnapToGridEnabled ? theme.colorScheme.primary : null,
          onPressed: onToggleSnapToGrid,
        ),
      ],
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}

// FILE: lib/editor/plugins/tiled_editor/widgets/paint_editor_app_bar.dart


import 'package:flutter/material.dart';
import '../../../../command/command_widgets.dart';
import '../tiled_editor_plugin.dart';

class PaintEditorAppBar extends StatelessWidget implements PreferredSizeWidget {
  final VoidCallback onExit;

  const PaintEditorAppBar({
    super.key,
    required this.onExit,
  });

  @override
  Widget build(BuildContext context) {
    return AppBar(
      leading: IconButton(
        icon: const Icon(Icons.arrow_back),
        tooltip: 'Exit Paint Mode (Pan/Zoom)',
        onPressed: onExit,
      ),
      title: const SingleChildScrollView(
        scrollDirection: Axis.horizontal,
        child: CommandToolbar(
          position: TiledEditorPlugin.paintToolsToolbar,
        ),
      ),
      actions: const [
      ],
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}

// FILE: lib/editor/plugins/tiled_editor/widgets/sprite_picker_dialog.dart

import 'package:flutter/material.dart';

class SpritePickerDialog extends StatefulWidget {
  final List<String> spriteNames;
  const SpritePickerDialog({super.key, required this.spriteNames});

  @override
  State<SpritePickerDialog> createState() => _SpritePickerDialogState();
}

class _SpritePickerDialogState extends State<SpritePickerDialog> {
  late List<String> _filtered;
  final TextEditingController _searchCtrl = TextEditingController();

  @override
  void initState() {
    super.initState();
    _filtered = widget.spriteNames;
  }

  void _filter(String query) {
    setState(() {
      if (query.isEmpty) {
        _filtered = widget.spriteNames;
      } else {
        _filtered = widget.spriteNames
            .where((s) => s.toLowerCase().contains(query.toLowerCase()))
            .toList();
      }
    });
  }

  @override
  void dispose() {
    _searchCtrl.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Select Sprite'),
      content: SizedBox(
        width: double.maxFinite,
        height: 400,
        child: Column(
          children: [
            TextField(
              controller: _searchCtrl,
              decoration: const InputDecoration(
                hintText: 'Search...',
                prefixIcon: Icon(Icons.search),
              ),
              autofocus: true,
              onChanged: _filter,
            ),
            const SizedBox(height: 8),
            Expanded(
              child: ListView.builder(
                itemCount: _filtered.length,
                itemBuilder: (context, index) {
                  final name = _filtered[index];
                  return ListTile(
                    title: Text(name),
                    onTap: () => Navigator.of(context).pop(name),
                  );
                },
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
      ],
    );
  }
}

// FILE: lib/editor/plugins/tiled_editor/widgets/tile_palette.dart

// FILE: lib/editor/plugins/tiled_editor/widgets/tile_palette.dart

import 'dart:ui' as ui;
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:tiled/tiled.dart' hide Text;
import 'package:vector_math/vector_math_64.dart' show Matrix4, Vector3;
import 'package:path/path.dart' as p;

import 'package:machine/asset_cache/asset_models.dart';
import '../tiled_asset_resolver.dart';

class TilePalette extends StatefulWidget {
  final TiledMap map;
  final TiledAssetResolver resolver;
  final Tileset? selectedTileset;
  final Rect? selectedTileRect;
  final ValueChanged<Tileset?> onTilesetChanged;
  final ValueChanged<Rect?> onTileSelectionChanged;
  final VoidCallback onAddTileset;
  final ValueChanged<DragUpdateDetails>? onResize;
  final VoidCallback? onInspectSelectedTileset;
  final VoidCallback? onDeleteSelectedTileset;
  final VoidCallback? onClearUnusedTilesets;

  const TilePalette({
    super.key,
    required this.map,
    required this.resolver,
    required this.selectedTileset,
    required this.selectedTileRect,
    required this.onTilesetChanged,
    required this.onTileSelectionChanged,
    required this.onAddTileset,
    this.onResize,
    this.onInspectSelectedTileset,
    this.onDeleteSelectedTileset,
    this.onClearUnusedTilesets,
  });

  @override
  State<TilePalette> createState() => _TilePaletteState();
}

class _TilePaletteState extends State<TilePalette> {
  late final TransformationController _transformationController;
  Offset? _dragStart;
  Offset? _lastDragPosition;
  Rect? _selectionRect;
  bool _isPanZoomMode = false;

  @override
  void initState() {
    super.initState();
    _transformationController = TransformationController();
  }

  @override
  void didUpdateWidget(covariant TilePalette oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.selectedTileRect == null && _selectionRect != null) {
      setState(() => _selectionRect = null);
    }
    if (widget.selectedTileset != oldWidget.selectedTileset) {
      _transformationController.value = Matrix4.identity();
    }
  }

  @override
  void dispose() {
    _transformationController.dispose();
    super.dispose();
  }

  void _handleDrag(Offset positionInContent, {bool isEnd = false}) {
    if (widget.selectedTileset == null) return;
    final tileset = widget.selectedTileset!;
    final tileWidth = (tileset.tileWidth ?? 0).toDouble();
    final tileHeight = (tileset.tileHeight ?? 0).toDouble();

    if (tileWidth == 0 || tileHeight == 0) return;
    if (_dragStart == null) return;

    final end = positionInContent;
    final startTileX = (_dragStart!.dx / tileWidth).floor();
    final startTileY = (_dragStart!.dy / tileHeight).floor();
    final endTileX = (end.dx / tileWidth).floor();
    final endTileY = (end.dy / tileHeight).floor();

    final left = (startTileX < endTileX ? startTileX : endTileX).toDouble();
    final top = (startTileY < endTileY ? startTileY : endTileY).toDouble();
    final width = ((startTileX - endTileX).abs() + 1).toDouble();
    final height = ((startTileY - endTileY).abs() + 1).toDouble();
    final newRect = Rect.fromLTWH(left, top, width, height);

    if (isEnd) {
      widget.onTileSelectionChanged(newRect);
    } else {
      setState(() => _selectionRect = newRect);
    }
  }

  void _handleTap(Offset positionInContent) {
    if (widget.selectedTileset == null) return;
    final tileset = widget.selectedTileset!;
    final tileWidth = (tileset.tileWidth ?? 0).toDouble();
    final tileHeight = (tileset.tileHeight ?? 0).toDouble();

    if (tileWidth <= 0 || tileHeight <= 0) return;

    final tileX = (positionInContent.dx / tileWidth).floor();
    final tileY = (positionInContent.dy / tileHeight).floor();

    final newSelection = Rect.fromLTWH(
      tileX.toDouble(),
      tileY.toDouble(),
      1,
      1,
    );

    if (widget.selectedTileRect == newSelection) {
      widget.onTileSelectionChanged(null);
    } else {
      widget.onTileSelectionChanged(newSelection);
    }
  }

  @override
  Widget build(BuildContext context) {
    final hasTilesets = widget.map.tilesets.isNotEmpty;

    return Material(
      elevation: 4,
      borderRadius: const BorderRadius.only(
        topLeft: Radius.circular(8),
        topRight: Radius.circular(8),
      ),
      child: Column(
        children: [
          if (widget.onResize != null)
            GestureDetector(
              onVerticalDragUpdate: widget.onResize,
              child: Container(
                width: double.infinity,
                height: 20,
                color: Colors.transparent,
                child: Center(
                  child: Container(
                    width: 40,
                    height: 5,
                    decoration: BoxDecoration(
                      color: Theme.of(context).dividerColor,
                      borderRadius: BorderRadius.circular(10),
                    ),
                  ),
                ),
              ),
            ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8.0),
            child: Row(
              children: [
                Expanded(
                  child: DropdownButton<Tileset?>(
                    value: widget.selectedTileset,
                    hint: const Text('Select a tileset'),
                    isExpanded: true,
                    underline: const SizedBox.shrink(),
                    items:
                        hasTilesets
                            ? widget.map.tilesets
                                .map(
                                  (ts) => DropdownMenuItem(
                                    value: ts,
                                    child: Text(
                                      ts.name ?? 'Unnamed',
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                  ),
                                )
                                .toList()
                            : [],
                    onChanged: (ts) {
                      widget.onTileSelectionChanged(null);
                      widget.onTilesetChanged(ts);
                    },
                  ),
                ),
                const SizedBox(width: 8),
                IconButton(
                  icon: const Icon(Icons.add_photo_alternate_outlined),
                  tooltip: 'Add New Tileset',
                  onPressed: widget.onAddTileset,
                ),
                IconButton(
                  icon: const Icon(Icons.delete_outline, color: Colors.redAccent),
                  tooltip: 'Delete Selected Tileset',
                  onPressed: widget.selectedTileset != null
                      ? widget.onDeleteSelectedTileset
                      : null,
                ),
                IconButton(
                  icon: const Icon(Icons.settings_outlined),
                  tooltip: 'Tileset Properties',
                  onPressed: widget.selectedTileset != null
                      ? widget.onInspectSelectedTileset
                      : null,
                ),
                IconButton(
                  icon: const Icon(Icons.layers_clear_outlined),
                  tooltip: 'Clear Unused Tilesets',
                  onPressed: hasTilesets ? widget.onClearUnusedTilesets : null,
                ),
                const SizedBox(width: 8),
                const VerticalDivider(width: 1, indent: 8, endIndent: 8),
                const SizedBox(width: 8),
                IconButton(
                  icon: Icon(
                    _isPanZoomMode
                        ? Icons.pan_tool_outlined
                        : Icons.select_all_outlined,
                  ),
                  tooltip: _isPanZoomMode ? 'Pan/Zoom Mode' : 'Select Mode',
                  color:
                      _isPanZoomMode
                          ? Theme.of(context).colorScheme.primary
                          : null,
                  onPressed:
                      () => setState(() => _isPanZoomMode = !_isPanZoomMode),
                ),
              ],
            ),
          ),
          const Divider(height: 1),
          Expanded(
            child: Padding(
              padding: const EdgeInsets.all(8.0),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(4),
                child: _buildPaletteView(),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPaletteView() {
    if (widget.selectedTileset == null) {
      return const Center(child: Text('No tileset selected.'));
    }
    final tileset = widget.selectedTileset!;
    final imageSource = tileset.image?.source;
    if (imageSource == null) {
      return const Center(child: Text('Tileset has no image.'));
    }
    
    final image = widget.resolver.getImage(imageSource, tileset: tileset);
    
    if (image == null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, color: Colors.red, size: 32),
            const SizedBox(height: 8),
            const Text('Image not found.'),
            const SizedBox(height: 8),
            ElevatedButton(
              onPressed: widget.onInspectSelectedTileset, 
              child: const Text('Fix Path'),
            )
          ],
        ),
      );
    }

    final imageSize = Size(image.width.toDouble(), image.height.toDouble());
    final currentSelection = _selectionRect ?? widget.selectedTileRect;

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      dragStartBehavior: DragStartBehavior.down,
      onTapUp: (details) {
        if (_isPanZoomMode) return;
        final inv = Matrix4.copy(_transformationController.value)..invert();
        final vec = inv.transform3(
          Vector3(details.localPosition.dx, details.localPosition.dy, 0),
        );
        _handleTap(Offset(vec.x, vec.y));
      },
      onPanStart: (details) {
        if (_isPanZoomMode) return;
        final inv = Matrix4.copy(_transformationController.value)..invert();
        final vec = inv.transform3(
          Vector3(details.localPosition.dx, details.localPosition.dy, 0),
        );
        final positionInContent = Offset(vec.x, vec.y);
        _dragStart = positionInContent;
        _lastDragPosition = _dragStart;
        _handleDrag(_dragStart!, isEnd: false);
      },
      onPanUpdate: (details) {
        if (_isPanZoomMode) return;
        final inv = Matrix4.copy(_transformationController.value)..invert();
        final vec = inv.transform3(
          Vector3(details.localPosition.dx, details.localPosition.dy, 0),
        );
        final positionInContent = Offset(vec.x, vec.y);
        _lastDragPosition = positionInContent;
        _handleDrag(positionInContent);
      },
      onPanEnd: (details) {
        if (_isPanZoomMode) return;
        final endPosition = _lastDragPosition ?? _dragStart;
        if (endPosition != null) {
          _handleDrag(endPosition, isEnd: true);
        }
        _dragStart = null;
        _lastDragPosition = null;
      },
      child: InteractiveViewer(
        transformationController: _transformationController,
        boundaryMargin: const EdgeInsets.all(double.infinity),
        minScale: 0.1,
        maxScale: 8.0,
        panEnabled: _isPanZoomMode,
        scaleEnabled: _isPanZoomMode,
        child: CustomPaint(
          size: imageSize,
          painter: _TilesetPainter(
            image: image,
            tileset: tileset,
            selection: currentSelection,
          ),
        ),
      ),
    );
  }
}

class _TilesetPainter extends CustomPainter {
  final ui.Image image;
  final Tileset tileset;
  final Rect? selection;

  _TilesetPainter({required this.image, required this.tileset, this.selection});

  @override
  void paint(Canvas canvas, Size size) {
    canvas.drawImage(image, Offset.zero, Paint()..filterQuality = FilterQuality.none);
    final tileWidth = (tileset.tileWidth ?? 0).toDouble();
    final tileHeight = (tileset.tileHeight ?? 0).toDouble();
    if (tileWidth == 0 || tileHeight == 0) return;
    final gridPaint =
        Paint()
          ..color = Colors.white.withOpacity(0.3)
          ..strokeWidth = 0.5;
    for (double x = 0; x <= size.width; x += tileWidth) {
      canvas.drawLine(Offset(x, 0), Offset(x, size.height), gridPaint);
    }
    for (double y = 0; y <= size.height; y += tileHeight) {
      canvas.drawLine(Offset(0, y), Offset(size.width, y), gridPaint);
    }
    if (selection != null) {
      final selectionPaint =
          Paint()
            ..color = Colors.blue.withOpacity(0.5)
            ..style = PaintingStyle.fill;
      final pixelRect = Rect.fromLTWH(
        selection!.left * tileWidth,
        selection!.top * tileHeight,
        selection!.width * tileWidth,
        selection!.height * tileHeight,
      );
      canvas.drawRect(pixelRect, selectionPaint);
    }
  }

  @override
  bool shouldRepaint(covariant _TilesetPainter oldDelegate) {
    return oldDelegate.image != image ||
        oldDelegate.tileset != tileset ||
        oldDelegate.selection != selection;
  }
}

// FILE: lib/editor/plugins/tiled_editor/widgets/tiled_editor_settings_widget.dart

import 'package:flex_color_picker/flex_color_picker.dart';
import 'package:flutter/material.dart';
import 'package:machine/editor/plugins/tiled_editor/tiled_editor_settings_model.dart';

class TiledEditorSettingsWidget extends StatelessWidget {
  final TiledEditorSettings settings;
  final void Function(TiledEditorSettings) onChanged;

  const TiledEditorSettingsWidget({
    super.key,
    required this.settings,
    required this.onChanged,
  });

  Future<void> _showColorPickerDialog(BuildContext context) async {
    final newColor = await showColorPickerDialog(
      context,
      Color(settings.gridColorValue),
      enableOpacity: true,
    );

    onChanged(
      settings.copyWith(gridColorValue: newColor.value),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        ListTile(
          contentPadding: EdgeInsets.zero,
          title: const Text('Grid Color'),
          trailing: ColorIndicator(
            color: Color(settings.gridColorValue),
            onSelect: () => _showColorPickerDialog(context),
          ),
          onTap: () => _showColorPickerDialog(context),
        ),
        const SizedBox(height: 16),
        Text('Grid Thickness: ${settings.gridThickness.toStringAsFixed(1)}'),
        Slider(
          value: settings.gridThickness,
          min: 0.5,
          max: 5.0,
          divisions: 9,
          label: settings.gridThickness.toStringAsFixed(1),
          onChanged: (value) {
            onChanged(
              settings.copyWith(gridThickness: value),
            );
          },
        ),
      ],
    );
  }
}

// FILE: lib/editor/services/editor_service.dart

import 'dart:async';
import 'dart:convert';

import 'package:flutter/material.dart';

import 'package:collection/collection.dart';
import 'package:crypto/crypto.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../app/app_notifier.dart';
import '../../data/dto/project_dto.dart';
import '../../data/repositories/project/project_repository.dart';
import '../../widgets/dialogs/file_explorer_dialogs.dart';
import '../../widgets/dialogs/save_as_dialog.dart';
import '../../explorer/services/explorer_service.dart';
import '../../logs/logs_provider.dart';
import '../../project/project_models.dart';
import '../../utils/toast.dart';
import '../models/editor_tab_models.dart';
import '../plugins/editor_plugin_registry.dart';
import '../tab_metadata_notifier.dart';
import '../../data/content_provider/file_content_provider.dart';
import '../models/text_editing_capability.dart';
import '../../data/cache/hot_state_cache_service.dart';

import '../../data/file_handler/file_handler.dart'
    show DocumentFile, ProjectDocumentFile;

final editorServiceProvider = Provider<EditorService>((ref) {
  return EditorService(ref);
});

class EditorService {
  final Ref _ref;
  EditorService(this._ref);

  Project? get _currentProject =>
      _ref.read(appNotifierProvider).value?.currentProject;
  EditorTab? get _currentTab => _currentProject?.session.currentTab;

  ProjectRepository get _repo {
    final repo = _ref.read(projectRepositoryProvider);
    if (repo == null) {
      throw StateError('ProjectRepository is not available.');
    }
    return repo;
  }

  FileContentProviderRegistry get _contentProviderRegistry =>
      _ref.read(fileContentProviderRegistryProvider);

  Future<TabSessionState> rehydrateTabSession(
    ProjectDto dto,
    ProjectMetadata projectMetadata,
  ) async {
    final plugins = _ref.read(activePluginsProvider);
    final metadataNotifier = _ref.read(tabMetadataProvider.notifier);
    final hotStateCacheService = _ref.read(hotStateCacheServiceProvider);
    final talker = _ref.read(talkerProvider);

    final List<EditorTab> rehydratedTabs = [];
    talker.info("Rehydrating tabs");

    for (final tabDto in dto.session.tabs) {
      final tabId = tabDto.id;
      final pluginId = tabDto.pluginType;
      final persistedMetadata = dto.session.tabMetadata[tabId];

      if (persistedMetadata == null) continue;

      final plugin = plugins.firstWhereOrNull((p) => p.id == pluginId);
      if (plugin == null) continue;

      try {
        final file = await _contentProviderRegistry.rehydrateFileFromDto(
          persistedMetadata,
        );

        if (file == null) continue;

        final contentProvider = _contentProviderRegistry.getProviderFor(file);

        final currentContentResult = await contentProvider.getContent(
          file,
          plugin.dataRequirement,
        );
        final currentDiskHash = currentContentResult.baseContentHash;

        TabHotStateDto? cachedDto = await hotStateCacheService.getTabState(
          projectMetadata.id,
          tabId,
        );

        if (cachedDto != null && cachedDto.baseContentHash != currentDiskHash) {
          talker.warning(
            'Cache conflict detected for ${file.name}. '
            'Cached Hash: ${cachedDto.baseContentHash}, '
            'Disk Hash: $currentDiskHash',
          );
          final context = _ref.read(navigatorKeyProvider).currentContext;
          if (context != null) {
            final resolution = await showCacheConflictDialog(
              context,
              fileName: file.name,
            );
            if (resolution == CacheConflictResolution.loadDisk) {
              talker.info('User chose to discard cache for ${file.name}.');
              await hotStateCacheService.clearTabState(
                projectMetadata.id,
                tabId,
              );
              cachedDto = null;
            }
          }
        }

        final initData = EditorInitData(
          initialContent: currentContentResult.content,
          hotState: cachedDto,
          baseContentHash: currentDiskHash,
        );

        final newTab = await plugin.createTab(file, initData, id: tabId);

        metadataNotifier.initTab(newTab.id, file);
        rehydratedTabs.add(newTab);
      } catch (e, st) {
        _ref
            .read(talkerProvider)
            .handle(
              e,
              st,
              'Could not restore tab for ${persistedMetadata.fileUri}',
            );
      }
    }

    return TabSessionState(
      tabs: rehydratedTabs,
      currentTabIndex: dto.session.currentTabIndex,
    );
  }

  Future<void> updateAndCacheDirtyTab(Project project, EditorTab tab) async {
    final hotStateCacheService = _ref.read(hotStateCacheServiceProvider);
    final metadata = _ref.read(tabMetadataProvider)[tab.id];

    if (metadata != null && metadata.isDirty) {
      final hotStateDto = await tab.editorKey.currentState?.serializeHotState();
      if (hotStateDto != null) {
        hotStateCacheService.updateTabState(project.id, tab.id, hotStateDto);
      }
    }
  }

  Future<void> flushAllHotTabs() async {
    final hotStateCacheService = _ref.read(hotStateCacheServiceProvider);
    await hotStateCacheService.flush();
  }

  void markCurrentTabDirty() {
    final tabId = _currentTab?.id;
    if (tabId != null) {
      _ref.read(tabMetadataProvider.notifier).markDirty(tabId);
    }
  }

  void markCurrentTabClean() {
    final tabId = _currentTab?.id;
    if (tabId != null) {
      _ref.read(tabMetadataProvider.notifier).markClean(tabId);
    }
  }

  void updateCurrentTabModel(EditorTab newTabModel) {
    final project = _currentProject;
    if (project == null) return;
    final newTabs = List<EditorTab>.from(project.session.tabs);
    newTabs[project.session.currentTabIndex] = newTabModel;
    final newProject = project.copyWith(
      session: project.session.copyWith(tabs: newTabs),
    );
    _ref.read(appNotifierProvider.notifier).updateCurrentProject(newProject);
  }

  void setBottomToolbarOverride(Widget? widget) {
    _ref.read(appNotifierProvider.notifier).setBottomToolbarOverride(widget);
  }

  void clearBottomToolbarOverride() {
    _ref.read(appNotifierProvider.notifier).clearBottomToolbarOverride();
  }

  Future<void> saveCurrentTabAs() async {
    final project = _currentProject;
    final tab = _currentTab;
    if (project == null || tab == null) return;

    final editorState = tab.editorKey.currentState;
    final metadata = _ref.read(tabMetadataProvider)[tab.id];
    if (editorState == null || metadata == null) return;

    final context = _ref.read(navigatorKeyProvider).currentContext;
    if (context == null || !context.mounted) return;

    try {
      final editorContent = await editorState.getContent();
      final result = await showDialog<SaveAsDialogResult>(
        context: context,
        builder: (_) => SaveAsDialog(initialFileName: metadata.file.name),
      );
      if (result == null) return;

      final ProjectDocumentFile newFile =
          (editorContent is EditorContentString)
              ? await _repo.createDocumentFile(
                result.parentUri,
                result.fileName,
                initialContent: editorContent.content,
                overwrite: true,
              )
              : await _repo.createDocumentFile(
                result.parentUri,
                result.fileName,
                initialBytes: (editorContent as EditorContentBytes).bytes,
                overwrite: true,
              );

      final newHash =
          (editorContent is EditorContentString)
              ? md5.convert(utf8.encode(editorContent.content)).toString()
              : md5
                  .convert((editorContent as EditorContentBytes).bytes)
                  .toString();

      _ref.read(tabMetadataProvider.notifier).updateFile(tab.id, newFile);
      _ref.read(tabMetadataProvider.notifier).markClean(tab.id);

      await _ref
          .read(hotStateCacheServiceProvider)
          .clearTabState(project.id, tab.id);
      editorState.onSaveSuccess(newHash);

      MachineToast.info("Saved as ${newFile.name}");
    } catch (e, st) {
      _ref.read(talkerProvider).handle(e, st, 'Save As operation failed');
      MachineToast.error("Save As operation failed.");
    }
  }

  void _handlePluginLifecycle(EditorTab? oldTab, EditorTab? newTab) {
    if (oldTab != null) oldTab.plugin.deactivateTab(oldTab, _ref);
    if (newTab != null) newTab.plugin.activateTab(newTab, _ref);
  }

  /// Opens a file from a relative path within the current project.
  /// If the file does not exist, it prompts the user to create it.
  Future<bool> openOrCreate(String relativePath) async {
    final project = _currentProject;
    if (project == null) {
      MachineToast.error("No project is open.");
      return false;
    }

    final repo = _ref.read(projectRepositoryProvider);
    final appNotifier = _ref.read(appNotifierProvider.notifier);
    final explorerService = _ref.read(explorerServiceProvider);
    final context = _ref.read(navigatorKeyProvider).currentContext;

    if (repo == null || context == null || !context.mounted) {
      return false;
    }

    final sanitizedPath = relativePath.replaceAll(r'\', '/');
    DocumentFile? file = await repo.fileHandler.resolvePath(
      project.rootUri,
      sanitizedPath,
    );

    if (file != null) {
      // File exists, open it directly.
      return await appNotifier.openFileInEditor(file);
    } else {
      // File does not exist, ask to create it.
      final shouldCreate = await showCreateFileConfirmationDialog(
        context,
        relativePath: sanitizedPath,
      );

      if (shouldCreate) {
        try {
          final newFile = await explorerService.createFileWithHierarchy(
            project.rootUri,
            sanitizedPath,
          );
          return await appNotifier.openFileInEditor(newFile);
        } catch (e, st) {
          _ref
              .read(talkerProvider)
              .handle(e, st, 'Failed to create file at path: $sanitizedPath');
          MachineToast.error("Could not create file: $e");
        }
      }
    }
    return false;
  }

  /// Opens a file if not already open, switches to its tab, and applies a generic [TextEdit].
  Future<bool> openAndApplyEdit(String relativePath, TextEdit edit) async {
    final project = _currentProject;
    if (project == null) {
      MachineToast.error("No project is open.");
      return false;
    }

    final sanitizedPath = relativePath.replaceAll(r'\', '/');
    final file = await _repo.fileHandler.resolvePath(
      project.rootUri,
      sanitizedPath,
    );

    if (file == null) {
      MachineToast.error("File not found: $sanitizedPath");
      return false;
    }

    final appNotifier = _ref.read(appNotifierProvider.notifier);
    final metadataMap = _ref.read(tabMetadataProvider);
    final existingTabId =
        metadataMap.entries
            .firstWhereOrNull((entry) => entry.value.file.uri == file.uri)
            ?.key;
    EditorTab? tabToEdit = (project.session.tabs).firstWhereOrNull(
      (t) => t.id == existingTabId,
    );

    try {
      final EditorWidgetState editorState;
      if (tabToEdit == null) {
        final onReadyCompleter = Completer<EditorWidgetState>();
        if (!await appNotifier.openFileInEditor(
          file,
          onReadyCompleter: onReadyCompleter,
        )) {
          return false;
        }
        editorState = await onReadyCompleter.future;
      } else {
        final index = project.session.tabs.indexOf(tabToEdit);
        appNotifier.switchTab(index);
        editorState = await tabToEdit.onReady.future;
      }

      if (editorState is TextEditable) {
        (editorState as TextEditable).applyEdit(edit);
        return true;
      } else {
        throw TypeError();
      }
    } catch (e, st) {
      final errorMessage =
          e is TypeError
              ? "The editor for this file does not support programmatic edits."
              : "Failed to apply edit: $e";
      _ref.read(talkerProvider).handle(e, st, 'Error in openAndApplyEdit');
      MachineToast.error(errorMessage);
      return false;
    }
  }

  Future<OpenFileResult> openFile(
    Project project,
    DocumentFile file, {
    EditorPlugin? explicitPlugin,
    Completer<EditorWidgetState>? onReadyCompleter,
  }) async {
    final metadataMap = _ref.read(tabMetadataProvider);
    final existingTabId =
        metadataMap.entries
            .firstWhereOrNull((entry) => entry.value.file.uri == file.uri)
            ?.key;
    if (existingTabId != null) {
      final existingIndex = project.session.tabs.indexWhere(
        (t) => t.id == existingTabId,
      );
      if (existingIndex != -1) {
        return OpenFileSuccess(
          project: switchTab(project, existingIndex),
          wasAlreadyOpen: true,
        );
      }
    }

    try {
      final EditorPlugin chosenPlugin;
      if (explicitPlugin != null) {
        chosenPlugin = explicitPlugin;
      } else {
        final allPlugins = _ref.read(activePluginsProvider);
        final compatiblePlugins =
            allPlugins.where((p) => p.supportsFile(file)).toList();
        if (compatiblePlugins.isEmpty) {
          return OpenFileError("No plugin available to open '${file.name}'.");
        }

        if (compatiblePlugins.length == 1) {
          chosenPlugin = compatiblePlugins.first;
        } else {
          final contentProvider = _contentProviderRegistry.getProviderFor(file);
          final contentResult = await contentProvider.getContent(
            file,
            PluginDataRequirement.string,
          );
          final fileContent =
              (contentResult.content as EditorContentString).content;

          final contentMatchingPlugins =
              compatiblePlugins
                  .where(
                    (p) =>
                        p.dataRequirement == PluginDataRequirement.string &&
                        p.canOpenFileContent(fileContent, file),
                  )
                  .toList();

          if (contentMatchingPlugins.isEmpty) {
            chosenPlugin = compatiblePlugins.first;
          } else if (contentMatchingPlugins.length == 1) {
            chosenPlugin = contentMatchingPlugins.first;
          } else {
            return OpenFileShowChooser(contentMatchingPlugins);
          }
        }
      }

      final contentProvider = _contentProviderRegistry.getProviderFor(file);
      final contentResult = await contentProvider.getContent(
        file,
        chosenPlugin.dataRequirement,
      );

      if (chosenPlugin.dataRequirement == PluginDataRequirement.string) {
        final fileContent =
            (contentResult.content as EditorContentString).content;
        if (!chosenPlugin.canOpenFileContent(fileContent, file)) {
          return OpenFileError(
            "${chosenPlugin.name} cannot open this file's content.",
          );
        }
      }

      final initData = EditorInitData(
        initialContent: contentResult.content,
        baseContentHash: contentResult.baseContentHash,
      );
      final newTab = await chosenPlugin.createTab(
        file,
        initData,
        onReadyCompleter: onReadyCompleter,
      );
      return _constructOpenFileSuccess(project, newTab, file);
    } catch (e, st) {
      _ref
          .read(talkerProvider)
          .handle(e, st, "Could not create tab for: ${file.uri}");
      return OpenFileError("Error opening file '${file.name}'.");
    }
  }

  OpenFileSuccess _constructOpenFileSuccess(
    Project project,
    EditorTab newTab,
    DocumentFile file,
  ) {
    _ref.read(tabMetadataProvider.notifier).initTab(newTab.id, file);
    final oldTab = project.session.currentTab;
    final newSession = project.session.copyWith(
      tabs: [...project.session.tabs, newTab],
      currentTabIndex: project.session.tabs.length,
    );
    _handlePluginLifecycle(oldTab, newTab);
    return OpenFileSuccess(
      project: project.copyWith(session: newSession),
      wasAlreadyOpen: false,
    );
  }

  Future<void> saveTab(Project project, EditorTab tabToSave) async {
    final editorState = tabToSave.editorKey.currentState;
    final metadata = _ref.read(tabMetadataProvider)[tabToSave.id];
    if (editorState == null || metadata == null) return;

    final file = metadata.file;
    final contentProvider = _contentProviderRegistry.getProviderFor(file);

    try {
      final editorContent = await editorState.getContent();
      final saveResult = await contentProvider.saveContent(file, editorContent);
      _ref.read(tabMetadataProvider.notifier).markClean(tabToSave.id);
      await _ref
          .read(hotStateCacheServiceProvider)
          .clearTabState(project.id, tabToSave.id);
      editorState.onSaveSuccess(saveResult.newContentHash);
      if (saveResult.savedFile.uri != file.uri) {
        _ref
            .read(tabMetadataProvider.notifier)
            .updateFile(tabToSave.id, saveResult.savedFile);
      }
    } on RequiresSaveAsException {
      await saveCurrentTabAs();
    } catch (e, st) {
      _ref
          .read(talkerProvider)
          .handle(e, st, "Failed to save tab: ${metadata.file.name}");
      MachineToast.error("Failed to save ${metadata.file.name}");
    }
  }

  Future<void> saveTabs(Project project, List<EditorTab> tabsToSave) async {
    final futures = tabsToSave.map((tab) => saveTab(project, tab));
    await Future.wait(futures);
  }

  Future<void> saveCurrentTab() async {
    final project = _currentProject;
    final tab = _currentTab;
    if (project != null && tab != null) {
      await saveTab(project, tab);
    }
  }

  Project switchTab(Project project, int index) {
    final oldTab = project.session.currentTab;
    final newSession = project.session.copyWith(currentTabIndex: index);
    final newProject = project.copyWith(session: newSession);
    final newTab = newProject.session.currentTab;

    _handlePluginLifecycle(oldTab, newTab);
    return newProject;
  }

  Project closeTab(Project project, int index) {
    final closedTab = project.session.tabs[index];
    final oldTab = project.session.currentTab;
    final newTabs = List<EditorTab>.from(project.session.tabs)..removeAt(index);

    int newCurrentIndex;
    if (newTabs.isEmpty) {
      newCurrentIndex = 0;
    } else {
      final oldIndex = project.session.currentTabIndex;
      if (oldIndex > index) {
        newCurrentIndex = oldIndex - 1;
      } else if (oldIndex == index) {
        newCurrentIndex = (oldIndex - 1).clamp(0, newTabs.length - 1);
      } else {
        newCurrentIndex = oldIndex;
      }
    }

    final newProject = project.copyWith(
      session: project.session.copyWith(
        tabs: newTabs,
        currentTabIndex: newCurrentIndex,
      ),
    );

    _ref.read(tabMetadataProvider.notifier).removeTab(closedTab.id);

    _ref
        .read(hotStateCacheServiceProvider)
        .clearTabState(project.id, closedTab.id);

    closedTab.plugin.deactivateTab(closedTab, _ref);
    closedTab.plugin.disposeTab(closedTab);
    closedTab.dispose();

    final newTab = newProject.session.currentTab;
    if (oldTab != newTab) {
      newTab?.plugin.activateTab(newTab, _ref);
    }
    return newProject;
  }

  Project reorderTabs(Project project, int oldIndex, int newIndex) {
    final currentOpenTab = project.session.currentTab;
    final newTabs = List<EditorTab>.from(project.session.tabs);
    final movedTab = newTabs.removeAt(oldIndex);
    if (oldIndex < newIndex) newIndex--;
    newTabs.insert(newIndex, movedTab);
    final newCurrentIndex =
        currentOpenTab != null ? newTabs.indexOf(currentOpenTab) : 0;
    return project.copyWith(
      session: project.session.copyWith(
        tabs: newTabs,
        currentTabIndex: newCurrentIndex,
      ),
    );
  }

  void updateTabForRenamedFile(String oldUri, DocumentFile newFile) {
    final metadataMap = _ref.read(tabMetadataProvider);
    final tabId =
        metadataMap.entries
            .firstWhereOrNull((entry) => entry.value.file.uri == oldUri)
            ?.key;
    if (tabId != null) {
      _ref.read(tabMetadataProvider.notifier).updateFile(tabId, newFile);
    }
  }
}

@immutable
sealed class OpenFileResult {}

class OpenFileSuccess extends OpenFileResult {
  final Project project;
  final bool wasAlreadyOpen;
  OpenFileSuccess({required this.project, required this.wasAlreadyOpen});
}

class OpenFileShowChooser extends OpenFileResult {
  final List<EditorPlugin> plugins;
  OpenFileShowChooser(this.plugins);
}

class OpenFileError extends OpenFileResult {
  final String message;
  OpenFileError(this.message);
}


// FILE: lib/editor/services/language/language_models.dart

import 'package:re_highlight/re_highlight.dart';

class LanguageConfig {
  final String id;
  final String name;
  final Set<String> extensions;
  final Mode? highlightMode;
  final CommentConfig? comments;
  final String Function(String path)? importFormatter;
  final List<RegExp> importPatterns;
  final List<String> importIgnoredPrefixes;

  const LanguageConfig({
    required this.id,
    required this.name,
    required this.extensions,
    this.highlightMode,
    this.comments,
    this.importFormatter,
    this.importPatterns = const [],
    this.importIgnoredPrefixes = const [],
  });
}

class CommentConfig {
  final String singleLine;
  final String? blockBegin;
  final String? blockEnd;

  const CommentConfig({
    this.singleLine = '',
    this.blockBegin,
    this.blockEnd,
  });
}

// FILE: lib/editor/services/language/language_registry.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:machine/editor/plugins/editor_plugin_registry.dart';
import 'package:re_highlight/languages/all.dart';
import 'package:re_highlight/languages/bash.dart';
import 'package:re_highlight/languages/cpp.dart';
import 'package:re_highlight/languages/css.dart';
import 'package:re_highlight/languages/dart.dart';
import 'package:re_highlight/languages/java.dart';
import 'package:re_highlight/languages/javascript.dart';
import 'package:re_highlight/languages/json.dart';
import 'package:re_highlight/languages/kotlin.dart';
import 'package:re_highlight/languages/latex.dart';
import 'package:re_highlight/languages/markdown.dart';
import 'package:re_highlight/languages/plaintext.dart';
import 'package:re_highlight/languages/properties.dart';
import 'package:re_highlight/languages/python.dart';
import 'package:re_highlight/languages/typescript.dart';
import 'package:re_highlight/languages/xml.dart';
import 'package:re_highlight/languages/yaml.dart';

import 'language_models.dart';
import 'package:re_highlight/languages/all.dart';

class Languages {
  Languages._();


  static LanguageConfig getForFile(String filename) {
    final ext = filename.split('.').last.toLowerCase();
    return _byExtension[ext] ?? _plaintext;
  }
  
  static LanguageConfig getById(String id) {
    return _byId[id] ?? _plaintext;
  }

  /// Returns true if we have explicit support (highlighting/features) for this file.
  static bool isSupported(String filename) {
    final ext = filename.split('.').last.toLowerCase();
    return _byExtension.containsKey(ext);
  }
  
  static List<LanguageConfig> get all => List.unmodifiable(_allLanguages);


  
  static final Map<String, LanguageConfig> _byExtension = {
    for (var lang in _allLanguages)
      for (var ext in lang.extensions) ext: lang
  };
  
  static final Map<String, LanguageConfig> _byId = {
    for (var lang in _allLanguages) lang.id: lang
  };

  static final LanguageConfig _plaintext = LanguageConfig(
    id: 'plaintext',
    name: 'Plain Text',
    extensions: {'txt', 'text', 'gitignore', 'env', 'LICENSE', ''},
    highlightMode: langPlaintext,
    comments: const CommentConfig(singleLine: '#'),
  );


  static final List<LanguageConfig> _allLanguages = [
    _plaintext,
    LanguageConfig(
      id: 'dart',
      name: 'Dart',
      extensions: {'dart'},
      highlightMode: langDart,
      comments: const CommentConfig(singleLine: '
      importFormatter: (path) => "import '$path';",
      importIgnoredPrefixes: ['dart:', 'package:', 'http:', 'https:'],
      importPatterns: [
        RegExp(r'''import\s+['"]([^'"]+)['"]'''),
        RegExp(r'''export\s+['"]([^'"]+)['"]'''),
        RegExp(r'''part\s+(?:of\s+)?['"]([^'"]+)['"]'''),
      ],
    ),

    LanguageConfig(
      id: 'javascript',
      name: 'JavaScript',
      extensions: {'js', 'jsx', 'mjs', 'cjs'},
      highlightMode: langJavascript,
      comments: const CommentConfig(singleLine: '
      importFormatter: (path) => "import '$path';",
      importIgnoredPrefixes: ['http:', 'https:', 'node:'],
      importPatterns: [
        RegExp(r'''from\s+['"]([^'"]+)['"]'''),
        RegExp(r'''import\s+['"]([^'"]+)['"]'''),
        RegExp(r'''require\s*\(\s*['"]([^'"]+)['"]\s*\)'''),
      ],
    ),

    LanguageConfig(
      id: 'typescript',
      name: 'TypeScript',
      extensions: {'ts', 'tsx'},
      highlightMode: langTypescript,
      comments: const CommentConfig(singleLine: '
      importFormatter: (path) => "import '$path';",
      importIgnoredPrefixes: ['http:', 'https:', 'node:'],
      importPatterns: [
        RegExp(r'''from\s+['"]([^'"]+)['"]'''),
        RegExp(r'''import\s+['"]([^'"]+)['"]'''),
        RegExp(r'''require\s*\(\s*['"]([^'"]+)['"]\s*\)'''),
      ],
    ),

    LanguageConfig(
      id: 'python',
      name: 'Python',
      extensions: {'py', 'pyw'},
      highlightMode: langPython,
      comments: const CommentConfig(singleLine: '#'),
    ),

    LanguageConfig(
      id: 'html',
      name: 'HTML',
      extensions: {'html', 'htm', 'xhtml'},
      highlightMode: langXml,
      comments: const CommentConfig(blockBegin: '<!--', blockEnd: '-->'),
      importIgnoredPrefixes: ['http:', 'https:', '
      importPatterns: [
        RegExp(r'''src=["']([^"']+)["']'''),
        RegExp(r'''href=["']([^"']+)["']'''),
      ],
    ),

    LanguageConfig(
      id: 'css',
      name: 'CSS',
      extensions: {'css', 'scss', 'less'},
      highlightMode: langCss,
      comments: const CommentConfig(blockBegin: '/*', blockEnd: '*/'),
      importFormatter: (path) => "@import '$path';",
      importIgnoredPrefixes: ['http:', 'https:', 'data:'],
      importPatterns: [
        RegExp(r'''@import\s+["']([^"']+)["']'''),
        RegExp(r'''url\s*\(\s*["']?([^"')]+)["']?\s*\)'''),
      ],
    ),

    LanguageConfig(
      id: 'cpp',
      name: 'C++',
      extensions: {'cpp', 'c', 'cc', 'h', 'hpp'},
      highlightMode: langCpp,
      comments: const CommentConfig(singleLine: '
      importFormatter: (path) => '#include "$path"',
      importPatterns: [
        RegExp(r'''#include\s+["']([^"']+)["']'''),
      ],
    ),

    LanguageConfig(
      id: 'java',
      name: 'Java',
      extensions: {'java'},
      highlightMode: langJava,
      comments: const CommentConfig(singleLine: '
    ),

    LanguageConfig(
      id: 'kotlin',
      name: 'Kotlin',
      extensions: {'kt', 'kts'},
      highlightMode: langKotlin,
      comments: const CommentConfig(singleLine: '
    ),

    LanguageConfig(
      id: 'bash',
      name: 'Bash',
      extensions: {'sh', 'bash', 'zsh'},
      highlightMode: langBash,
      comments: const CommentConfig(singleLine: '#'),
    ),

    LanguageConfig(
      id: 'json',
      name: 'JSON',
      extensions: {'json', 'arb', 'ipynb'},
      highlightMode: langJson,
    ),

    LanguageConfig(
      id: 'markdown',
      name: 'Markdown',
      extensions: {'md', 'markdown'},
      highlightMode: langMarkdown,
      comments: const CommentConfig(singleLine: '>'),
      importPatterns: [
        RegExp(r'''\]\(([^)]+)\)'''),
        RegExp(r'''!\[.*?\]\(([^)]+)\)'''),
      ],
    ),

    LanguageConfig(
      id: 'xml',
      name: 'XML',
      extensions: {'xml', 'xsd', 'svg', 'plist', 'manifest'},
      highlightMode: langXml,
      comments: const CommentConfig(blockBegin: '<!--', blockEnd: '-->'),
    ),

    LanguageConfig(
      id: 'yaml',
      name: 'YAML',
      extensions: {'yaml', 'yml'},
      highlightMode: langYaml,
      comments: const CommentConfig(singleLine: '#'),
    ),

    LanguageConfig(
      id: 'latex',
      name: 'LaTeX',
      extensions: {'tex', 'sty', 'cls'},
      highlightMode: langLatex,
      comments: const CommentConfig(singleLine: '%'),
      importFormatter: (path) => '\\input{$path}',
      importPatterns: [
        RegExp(r'''\\input\{([^}]+)\}'''),
        RegExp(r'''\\include\{([^}]+)\}'''),
        RegExp(r'''\\includegraphics(?:\[.*\])?\{([^}]+)\}'''),
      ],
    ),

    LanguageConfig(
      id: 'properties',
      name: 'Properties',
      extensions: {'properties', 'conf', 'ini'},
      highlightMode: langProperties,
      comments: const CommentConfig(singleLine: '#'),
    ),
  ];
}

// FILE: lib/editor/tab_context_commands.dart

// NEW FILE: lib/editor/tab_context_commands.dart

import 'package:flutter/material.dart';

import '../app/app_notifier.dart';
import '../command/command_models.dart';

class AppTabContextCommands {
  static List<TabContextCommand> getCommands() {
    return [
      BaseTabContextCommand(
        id: 'close_other_tabs',
        label: 'Close Other Tabs',
        icon: const Icon(Icons.close_rounded, size: 20),
        sourcePlugin: 'App',
        canExecuteFor: (ref, activeTab, targetTab) {
          final project = ref.read(appNotifierProvider).value?.currentProject;
          return (project?.session.tabs.length ?? 0) > 1;
        },
        executeFor: (ref, activeTab, targetTab) async {
          final notifier = ref.read(appNotifierProvider.notifier);
          final tabs =
              ref.read(appNotifierProvider).value!.currentProject!.session.tabs;
          final targetIndex = tabs.indexOf(targetTab);

          final indicesToClose = <int>[];
          for (int i = 0; i < tabs.length; i++) {
            if (i != targetIndex) {
              indicesToClose.add(i);
            }
          }
          notifier.closeMultipleTabs(indicesToClose);
        },
      ),
      // e.g., "Close Tabs to the Right", "Copy File Path", etc.
    ];
  }
}


// FILE: lib/editor/tab_metadata_notifier.dart

// FILE: lib/editor/tab_state_manager.dart


import 'package:flutter/material.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../data/file_handler/file_handler.dart';

import '../project/project_models.dart';

@immutable
class TabMetadata {
  final DocumentFile file;
  final bool isDirty;

  const TabMetadata({required this.file, this.isDirty = false});

  String get title => file.name;

  TabMetadata copyWith({DocumentFile? file, bool? isDirty}) {
    return TabMetadata(
      file: file ?? this.file,
      isDirty: isDirty ?? this.isDirty,
    );
  }

  Map<String, dynamic> toJson() => {
    'fileUri': file.uri,
    'isDirty': isDirty,
  };

  factory TabMetadata.fromJson(Map<String, dynamic> json) {
    return TabMetadata(
      file: IncompleteDocumentFile(uri: json['fileUri']),
      isDirty: json['isDirty'] ?? false,
    );
  }
}

final tabMetadataProvider =
    StateNotifierProvider<TabMetadataNotifier, Map<String, TabMetadata>>((ref) {
      return TabMetadataNotifier();
    });

class TabMetadataNotifier extends StateNotifier<Map<String, TabMetadata>> {
  TabMetadataNotifier() : super({});

  void initTab(String tabId, DocumentFile file) {
    if (state.containsKey(tabId)) return;
    state = {...state, tabId: TabMetadata(file: file)};
  }

  void removeTab(String tabId) {
    final newState = Map<String, TabMetadata>.from(state)..remove(tabId);
    state = newState;
  }

  void markDirty(String tabId) {
    if (state.containsKey(tabId) && state[tabId]?.isDirty == false) {
      state = {...state, tabId: state[tabId]!.copyWith(isDirty: true)};
    }
  }

  void markClean(String tabId) {
    if (state.containsKey(tabId) && state[tabId]?.isDirty == true) {
      state = {...state, tabId: state[tabId]!.copyWith(isDirty: false)};
    }
  }

  void updateFile(String tabId, DocumentFile newFile) {
    if (state.containsKey(tabId)) {
      state = {...state, tabId: state[tabId]!.copyWith(file: newFile)};
    }
  }

  void clear() {
    state = {};
  }
}


// FILE: lib/editor/widgets/editor_widgets.dart

// FILE: lib/editor/editor_widgets.dart


import 'package:flutter/material.dart';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:re_editor/re_editor.dart';

import '../../app/app_notifier.dart';
import '../../command/command_models.dart';
import '../../explorer/plugins/git_explorer/git_object_file.dart';
import '../../project/project_models.dart';
import '../models/editor_tab_models.dart';
import '../tab_metadata_notifier.dart';

class TabBarWidget extends ConsumerStatefulWidget {
  const TabBarWidget({super.key});

  @override
  ConsumerState<TabBarWidget> createState() => _TabBarWidgetState();
}

class _TabBarWidgetState extends ConsumerState<TabBarWidget> {
  late final ScrollController _scrollController;
  int? _dragStartIndex;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  void _showTabContextMenu(
    BuildContext context,
    WidgetRef ref,
    int targetIndex,
  ) {
    final project = ref.read(appNotifierProvider).value?.currentProject;
    final activeTab = project?.session.currentTab;
    if (project == null || activeTab == null) return;

    final targetTab = project.session.tabs[targetIndex];

    final allCommands = ref.read(allTabContextCommandsProvider);

    final executableCommands =
        allCommands
            .where((cmd) => cmd.canExecuteFor(ref, activeTab, targetTab))
            .toList();

    if (executableCommands.isEmpty) return;

    showModalBottomSheet(
      context: context,
      builder:
          (ctx) => SafeArea(
            child: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Text(
                      ref.read(tabMetadataProvider)[targetTab.id]?.title ??
                          'Tab Options',
                      style: Theme.of(context).textTheme.titleLarge,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  const Divider(height: 1),
                  ...executableCommands.map((command) {
                    return ListTile(
                      leading: command.icon,
                      title: Text(command.label),
                      onTap: () {
                        Navigator.pop(ctx);
                        command.executeFor(ref, activeTab, targetTab);
                      },
                    );
                  }),
                ],
              ),
            ),
          ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final tabs =
        ref.watch(
          appNotifierProvider.select(
            (s) => s.value?.currentProject?.session.tabs,
          ),
        ) ??
        [];

    if (tabs.isEmpty) {
      return const SizedBox.shrink();
    }

    return Container(
      color: Theme.of(
        context,
      ).tabBarTheme.unselectedLabelColor?.withValues(alpha: 0.1),
      height: 32,
      child: CodeEditorTapRegion(
        child: ReorderableListView(
          key: const PageStorageKey<String>('tabBarScrollPosition'),
          scrollController: _scrollController,
          scrollDirection: Axis.horizontal,
          onReorderStart: (index) {
            setState(() => _dragStartIndex = index);
          },
          onReorderEnd: (index) {
            if (_dragStartIndex == index) {
              _showTabContextMenu(context, ref, index);
            }
            setState(() => _dragStartIndex = null);
          },
          onReorder:
              (oldIndex, newIndex) => ref
                  .read(appNotifierProvider.notifier)
                  .reorderTabs(oldIndex, newIndex),
          buildDefaultDragHandles: false,
          children: [
            for (int i = 0; i < tabs.length; i++)
              ReorderableDelayedDragStartListener(
                key: ValueKey(tabs[i].id),
                index: i,
                child: TabWidget(tab: tabs[i], index: i),
              ),
          ],
        ),
      ),
    );
  }
}

class TabWidget extends ConsumerWidget {
  final EditorTab tab;
  final int index;

  const TabWidget({super.key, required this.tab, required this.index});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final isActive = ref.watch(
      appNotifierProvider.select(
        (s) => s.value?.currentProject?.session.currentTabIndex == index,
      ),
    );
    final metadata = ref.watch(
      tabMetadataProvider.select((map) => map[tab.id]),
    );

    if (metadata == null) {
      return const SizedBox.shrink();
    }

    final isDirty = metadata.isDirty;
    final title = metadata.title;
    final isVirtual = metadata.file is InternalAppFile;
    final isGit = metadata.file is GitObjectDocumentFile;

    final Color textColor;
    if (isGit) {
      textColor = Colors.lightBlue.shade300;
    } else if (isVirtual) {
      textColor = Colors.lime.shade300;
    } else if (isDirty) {
      textColor = Colors.orange.shade300;
    } else {
      textColor = Colors.white70;
    }

    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: () => ref.read(appNotifierProvider.notifier).switchTab(index),
        child: Container(
          constraints: const BoxConstraints(maxWidth: 220),
          padding: const EdgeInsets.only(right: 8),
          decoration: BoxDecoration(
            border: Border(
              right: BorderSide(
                color: theme.dividerColor.withValues(alpha: 0.2),
                width: 1,
              ),
              bottom:
                  isActive
                      ? BorderSide(color: theme.colorScheme.primary, width: 2)
                      : BorderSide.none,
            ),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              GestureDetector(
                behavior: HitTestBehavior.opaque,
                onTap:
                    () =>
                        ref.read(appNotifierProvider.notifier).closeTab(index),
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 8.0,
                    vertical: 4.0,
                  ),
                  child: Icon(
                    Icons.close,
                    size: 16,
                    color: isActive ? Colors.white70 : Colors.white54,
                  ),
                ),
              ),
              Flexible(
                child: Text(
                  title,
                  overflow: TextOverflow.ellipsis,
                  softWrap: false,
                  style: TextStyle(fontSize: 13, color: textColor),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class EditorView extends ConsumerWidget {
  const EditorView({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final project = ref.watch(appNotifierProvider).value?.currentProject;
    if (project == null || project.session.tabs.isEmpty) {
      return const Center(child: Text('Open a file to start editing'));
    }

    return IndexedStack(
      index: project.session.currentTabIndex,
      children: List.generate(project.session.tabs.length, (index) {
        final tab = project.session.tabs[index];
        final bool isActive = index == project.session.currentTabIndex;

        return KeyedSubtree(
          key: ValueKey(tab.id),
          child: TickerMode(
            enabled: isActive,
            child: FocusTraversalGroup(
              policy:
                  OrderedTraversalPolicy(),
              child: tab.plugin.buildEditor(tab, ref),
            ),
          ),
        );
      }),
    );
  }
}


// FILE: pubspec.yaml

name: machine
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https:
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https:
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.7.0

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8
  flutter_launcher_icons: ^0.14.3
  re_editor:
    path: ../re-editor
  dart_git:
    path: ../dart-git
    # git: https:
  file_picker: ^10.1.9
  path_provider: ^2.1.5
  re_highlight: ^0.0.3
  external_path: ^2.2.0
  permission_handler: ^12.0.0+1
  crypto: ^3.0.6
  diff_match_patch: ^0.4.1
  riverpod: ^2.6.1
  flutter_riverpod: ^2.6.1
  riverpod_annotation: ^2.6.1
  shared_preferences: ^2.5.2
  saf_stream: ^0.12.3
  saf_util: ^0.11.0
  async: any
  collection: any
  uuid: any
  talker: ^5.0.1
  talker_flutter: ^5.0.1
  talker_riverpod_logger: ^5.0.1
  fluttertoast: ^8.2.12
  back_button_interceptor: ^8.0.4
  flutter_foreground_task: ^9.1.0
  hive_ce: ^2.14.0
  hive_ce_flutter: ^2.3.2
  flutter_markdown: ^0.7.7+1
  http: ^1.5.0
  markdown: any
  scrollable_positioned_list: ^0.3.8
  glob: ^2.1.3
  path: ^1.9.1
  equatable: any
  tiled: ^0.11.1
  vector_math: ^2.1.4
  xml: any
  meta: any
  flex_color_picker: ^3.7.2
  flutter_native_splash: ^2.4.7
dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^6.0.0
  riverpod_generator: ^2.6.5
  build_runner: ^2.4.15
  custom_lint: ^0.7.5
  riverpod_lint: ^2.6.5
  hive_ce_generator: ^1.9.2
  import_sorter: ^4.6.0
# For information on the generic Dart part of this file, see the
# following page: https:

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https:

  # For details regarding adding assets from package dependencies, see
  # https:

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:

  fonts:
    - family: JetBrainsMono
      fonts:
        - asset: assets/fonts/JetBrainsMono-Regular.ttf
        - asset: assets/fonts/JetBrainsMono-Bold.ttf
          weight: 700
        - asset: assets/fonts/JetBrainsMono-Italic.ttf
          style: italic
        - asset: assets/fonts/JetBrainsMono-BoldItalic.ttf
          weight: 700
          style: italic
    - family: FiraCode
      fonts:
        - asset: assets/fonts/FiraCode/FiraCode-Regular.ttf
          weight: 400
        - asset: assets/fonts/FiraCode/FiraCode-Bold.ttf
          weight: 700
    - family: RobotoMono
      fonts:
        - asset: assets/fonts/RobotoMono/RobotoMono-Regular.ttf
          weight: 400
        - asset: assets/fonts/RobotoMono/RobotoMono-Bold.ttf
          weight: 700
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https:
flutter_launcher_icons:
     android: true
     image_path: "assets/icons/android/res/mipmap-hdpi/ic_launcher.png" # Path to your icon image
     adaptive_icon_background: "assets/icons/android/res/mipmap-hdpi/ic_launcher_background.png" # only available for Android 8.0 devices and above
     adaptive_icon_foreground: "assets/icons/android/res/mipmap-hdpi/ic_launcher_foreground.png" # only available for Android 8.0 devices and above
     adaptive_icon_foreground_inset: 0 # only available for Android 8.0 devices and above
     adaptive_icon_monochrome: "assets/icons/android/res/mipmap-hdpi/ic_launcher_monochrome.png" # only available for Android 13 devices and above

import_sorter:
  comments: false # Optional, defaults to true
  
flutter_native_splash:
  color: "#07121A"
  #color_dark: "#042a49"
  image: 'assets/icons/android/play_store_512.png'    
  #image_dark:
  fullscreen: true
  android_12:
    color: "#07121A"
    # color_dark: "#042a49"

    image: 'assets/icons/android/play_store_512.png'

// FILE: sandbox/flow_schema.json

[
  {
    "type": "DestroySelfNode",
    "label": "Destroy Self",
    "category": "Object",
    "inputs": [
      {
        "key": "exec",
        "name": "In",
        "type": "execution"
      }
    ],
    "outputs": [],
    "properties": []
  },
  {
    "type": "SetEnabledNode",
    "label": "Set Enabled",
    "category": "Object",
    "inputs": [
      {
        "key": "exec",
        "name": "In",
        "type": "execution"
      }
    ],
    "outputs": [
      {
        "key": "out",
        "name": "Out",
        "type": "execution"
      }
    ],
    "properties": [
      {
        "name": "Enabled",
        "type": "boolean",
        "default": true,
        "key": "enabled"
      }
    ]
  },
  {
    "type": "SetIntegerNode",
    "label": "Set Integer",
    "category": "Logic",
    "inputs": [
      {
        "key": "exec",
        "name": "In",
        "type": "execution"
      }
    ],
    "outputs": [
      {
        "key": "out",
        "name": "Out",
        "type": "execution"
      }
    ],
    "properties": [
      {
        "name": "Variable",
        "type": "string",
        "key": "variable"
      },
      {
        "name": "Value",
        "type": "integer",
        "default": 0,
        "key": "value"
      }
    ]
  },
  {
    "type": "CompareNode",
    "label": "Compare Int",
    "category": "Logic",
    "inputs": [
      {
        "key": "valB",
        "name": "B",
        "type": "integer"
      },
      {
        "key": "valA",
        "name": "A",
        "type": "integer"
      },
      {
        "key": "exec",
        "name": "In",
        "type": "execution"
      }
    ],
    "outputs": [
      {
        "key": "less",
        "name": "A < B",
        "type": "execution"
      },
      {
        "key": "greater",
        "name": "A > B",
        "type": "execution"
      },
      {
        "key": "equal",
        "name": "A == B",
        "type": "execution"
      }
    ],
    "properties": [
      {
        "name": "Variable (A)",
        "type": "string",
        "key": "variable"
      },
      {
        "name": "Default B",
        "type": "integer",
        "default": 0,
        "key": "valB"
      }
    ]
  },
  {
    "type": "OnLoadNode",
    "label": "On Level Load",
    "category": "Events",
    "inputs": [],
    "outputs": [
      {
        "key": "exec",
        "name": "Flow",
        "type": "execution"
      }
    ],
    "properties": []
  },
  {
    "type": "OnInteractNode",
    "label": "On Interact",
    "category": "Events",
    "inputs": [],
    "outputs": [
      {
        "key": "exec",
        "name": "Flow",
        "type": "execution"
      }
    ],
    "properties": []
  },
  {
    "type": "OnEnterZoneNode",
    "label": "On Enter Zone",
    "category": "Events",
    "inputs": [],
    "outputs": [
      {
        "key": "exec",
        "name": "Flow",
        "type": "execution"
      }
    ],
    "properties": []
  },
  {
    "type": "StartNode",
    "label": "Start",
    "category": "Events",
    "inputs": [],
    "outputs": [
      {
        "key": "exec",
        "name": "Flow",
        "type": "execution"
      }
    ],
    "properties": []
  },
  {
    "type": "LogNode",
    "label": "Print Log",
    "category": "Debug",
    "inputs": [
      {
        "key": "msgIn",
        "name": "Message",
        "type": "string"
      },
      {
        "key": "exec",
        "name": "In",
        "type": "execution"
      }
    ],
    "outputs": [
      {
        "key": "out",
        "name": "Out",
        "type": "execution"
      }
    ],
    "properties": [
      {
        "name": "Message",
        "type": "string",
        "default": "Hello",
        "key": "message"
      }
    ]
  }
]

// FILE: sandbox/ecs_schema.json

[
  {
    "name": "Visual",
    "label": "Visual Sprite",
    "description": "Renders an animated sprite",
    "properties": [
      {
        "key": "assetKey",
        "label": "Atlas Name",
        "type": "string"
      },
      {
        "key": "initialAnim",
        "label": "Initial Animation",
        "type": "string",
        "default": "idle"
      },
      {
        "key": "offsetX",
        "label": "Offset X",
        "type": "number",
        "default": 0
      },
      {
        "key": "offsetY",
        "label": "Offset Y",
        "type": "number",
        "default": 0
      }
    ]
  },
  {
    "name": "Trigger",
    "label": "Zone Trigger",
    "description": "Detects entity entry/exit",
    "properties": [
      {
        "key": "boundsType",
        "label": "Type",
        "type": "select",
        "options": [
          "Self",
          "Radius"
        ],
        "default": "Self"
      },
      {
        "key": "value",
        "label": "Value",
        "type": "string"
      },
      {
        "key": "offsetX",
        "label": "Offset X",
        "type": "number",
        "default": 0
      },
      {
        "key": "offsetY",
        "label": "Offset Y",
        "type": "number",
        "default": 0
      }
    ]
  },
  {
    "name": "Collider",
    "label": "Physics Collider",
    "description": "Blocks player movement",
    "properties": [
      {
        "key": "boundsType",
        "label": "Bounds Type",
        "type": "select",
        "options": [
          "Self",
          "Radius",
          "Object"
        ],
        "default": "Self"
      },
      {
        "key": "value",
        "label": "Value (Radius/ID)",
        "type": "string"
      },
      {
        "key": "offsetX",
        "label": "Offset X",
        "type": "number",
        "default": 0
      },
      {
        "key": "offsetY",
        "label": "Offset Y",
        "type": "number",
        "default": 0
      }
    ]
  }
]

